<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html week15.do.txt --pygments_html_style=default --html_style=bloodish --html_links_in_new_window --html_output=week15 --no_mako
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Advanced machine learning and data analysis for the physical sciences">
<title>Advanced machine learning and data analysis for the physical sciences</title>
<style type="text/css">
/* bloodish style */
body {
  font-family: Helvetica, Verdana, Arial, Sans-serif;
  color: #404040;
  background: #ffffff;
}
h1 { font-size: 1.8em; color: #8A0808; }
h2 { font-size: 1.6em; color: #8A0808; }
h3 { font-size: 1.4em; color: #8A0808; }
h4 { font-size: 1.2em; color: #8A0808; }
a { color: #8A0808; text-decoration:none; }
tt { font-family: "Courier New", Courier; }
p { text-indent: 0px; }
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-style: normal; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa; }div.highlight {
    border: 1px solid #cfcfcf;
    border-radius: 2px;
    line-height: 1.21429em;
}
div.cell {
    width: 100%;
    padding: 5px 5px 5px 0;
    margin: 0;
    outline: none;
}
div.input {
    page-break-inside: avoid;
    box-orient: horizontal;
    box-align: stretch;
    display: flex;
    flex-direction: row;
    align-items: stretch;
}
div.inner_cell {
    box-orient: vertical;
    box-align: stretch;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    box-flex: 1;
    flex: 1;
}
div.input_area {
    border: 1px solid #cfcfcf;
    border-radius: 4px;
    background: #f7f7f7;
    line-height: 1.21429em;
}
div.input_area > div.highlight {
    margin: .4em;
    border: none;
    padding: 0;
    background-color: transparent;
}
div.output_wrapper {
    position: relative;
    box-orient: vertical;
    box-align: stretch;
    display: flex;
    flex-direction: column;
    align-items: stretch;
}
.output {
    box-orient: vertical;
    box-align: stretch;
    display: flex;
    flex-direction: column;
    align-items: stretch;
}
div.output_area {
    padding: 0;
    page-break-inside: avoid;
    box-orient: horizontal;
    box-align: stretch;
    display: flex;
    flex-direction: row;
    align-items: stretch;
}
div.output_subarea {
    padding: .4em .4em 0 .4em;
    box-flex: 1;
    flex: 1;
}
div.output_text {
    text-align: left;
    color: #000;
    line-height: 1.21429em;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #bababa;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #f8f8f8;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_gray_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_gray_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_gray_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_gray_question.png); }
div { text-align: justify; text-justify: inter-word; }
.tab {
  padding-left: 1.5em;
}
div.toc p,a {
  line-height: 1.3;
  margin-top: 1.1;
  margin-bottom: 1.1;
}
</style>
</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Plans for the week of May 5-9, 2025',
               2,
               None,
               'plans-for-the-week-of-may-5-9-2025'),
              ('Readings', 2, None, 'readings'),
              ('Diffusion models, basics', 2, None, 'diffusion-models-basics'),
              ('Why diffusion models?', 2, None, 'why-diffusion-models'),
              ('What are diffusion models?',
               2,
               None,
               'what-are-diffusion-models'),
              ('Problems with probabilistic models',
               2,
               None,
               'problems-with-probabilistic-models'),
              ('Diffusion models', 2, None, 'diffusion-models'),
              ('Original idea', 2, None, 'original-idea'),
              ('Diffusion learning', 2, None, 'diffusion-learning'),
              ('How diffusion models work',
               2,
               None,
               'how-diffusion-models-work'),
              ('Data preprocessing', 2, None, 'data-preprocessing'),
              ('Mathematics of diffusion models',
               2,
               None,
               'mathematics-of-diffusion-models'),
              ('Chains of VAEs', 2, None, 'chains-of-vaes'),
              ('Mathematical representation',
               2,
               None,
               'mathematical-representation'),
              ('Back to the marginal probability',
               2,
               None,
               'back-to-the-marginal-probability'),
              ('Diffusion models for hierarchical VAE, from '
               'URL:"https://arxiv.org/abs/2208.11970"',
               2,
               None,
               'diffusion-models-for-hierarchical-vae-from-url-https-arxiv-org-abs-2208-11970'),
              ('Equation for the Markovian hierarchical VAE',
               2,
               None,
               'equation-for-the-markovian-hierarchical-vae'),
              ('Variational Diffusion Models',
               2,
               None,
               'variational-diffusion-models'),
              ('Second assumption', 2, None, 'second-assumption'),
              ('Parameterizing Gaussian encoder',
               2,
               None,
               'parameterizing-gaussian-encoder'),
              ('Encoder transitions', 2, None, 'encoder-transitions'),
              ('Third assumption', 2, None, 'third-assumption'),
              ('Noisification', 2, None, 'noisification'),
              ('Diffusion models, from URL:"https://arxiv.org/abs/2208.11970"',
               2,
               None,
               'diffusion-models-from-url-https-arxiv-org-abs-2208-11970'),
              ('Gaussian modeling', 2, None, 'gaussian-modeling'),
              ('Optimizing the variational diffusion model',
               2,
               None,
               'optimizing-the-variational-diffusion-model'),
              ('Continues', 2, None, 'continues'),
              ('Interpretations', 2, None, 'interpretations'),
              ('The last term', 2, None, 'the-last-term'),
              ('Diffusion models, part 2, from '
               'URL:"https://arxiv.org/abs/2208.11970"',
               2,
               None,
               'diffusion-models-part-2-from-url-https-arxiv-org-abs-2208-11970'),
              ('Optimization cost', 2, None, 'optimization-cost'),
              ('Image quality', 2, None, 'image-quality'),
              ('Training stability', 2, None, 'training-stability'),
              ('Input types', 2, None, 'input-types'),
              ('Denoising diffusion probabilistic models (DDPMs)',
               2,
               None,
               'denoising-diffusion-probabilistic-models-ddpms'),
              ('Techniques for speeding up diffusion models',
               2,
               None,
               'techniques-for-speeding-up-diffusion-models'),
              ('Applications of diffusion models',
               2,
               None,
               'applications-of-diffusion-models'),
              ('PyTorch implementation of a Denoising Diffusion Probabilistic '
               'Model (DDPM) trained on the MNIST dataset',
               2,
               None,
               'pytorch-implementation-of-a-denoising-diffusion-probabilistic-model-ddpm-trained-on-the-mnist-dataset'),
              ('What is a U-net?', 2, None, 'what-is-a-u-net'),
              ('Problem with diffusion models',
               2,
               None,
               'problem-with-diffusion-models'),
              ('Imports and Utilities', 2, None, 'imports-and-utilities'),
              ('Hyperparameters and schedules',
               2,
               None,
               'hyperparameters-and-schedules'),
              ('Data Loading', 2, None, 'data-loading'),
              ('Model definition', 2, None, 'model-definition'),
              ('Forward Diffusion $q(x_t\\vert x_0)$',
               2,
               None,
               'forward-diffusion-q-x-t-vert-x-0'),
              ('Cost/Loss function', 2, None, 'cost-loss-function'),
              ('Training loop', 2, None, 'training-loop'),
              ('Sampling (Reverse Diffusion)',
               2,
               None,
               'sampling-reverse-diffusion'),
              ('More details and plans for next week',
               2,
               None,
               'more-details-and-plans-for-next-week')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- ------------------- main content ---------------------- -->
<center>
<h1>Advanced machine learning and data analysis for the physical sciences</h1>
</center>  <!-- document title -->

<!-- author(s): Morten Hjorth-Jensen -->
<center>
<b>Morten Hjorth-Jensen</b> 
</center>
<!-- institution -->
<center>
<b>Department of Physics and Center for Computing in Science Education, University of Oslo, Norway</b>
</center>
<br>
<center>
<h4>May 8, 2025</h4>
</center> <!-- date -->
<br>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="plans-for-the-week-of-may-5-9-2025">Plans for the week of May 5-9, 2025  </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b>Deep generative models</b>
<p>
<ol>
<li> Mathematics of diffusion models and selected examples</li>
</ol>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="readings">Readings </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b>Reading on diffusion models</b>
<p>
<ol>
<li> A central paper is the one by Sohl-Dickstein et al, Deep Unsupervised Learning using Nonequilibrium Thermodynamics, <a href="https://arxiv.org/abs/1503.03585" target="_blank"><tt>https://arxiv.org/abs/1503.03585</tt></a></li>
<li> Calvin Luo at <a href="https://arxiv.org/abs/2208.11970" target="_blank"><tt>https://arxiv.org/abs/2208.11970</tt></a></li>
<li> See also Diederik P. Kingma, Tim Salimans, Ben Poole, Jonathan Ho, Variational Diffusion Models, <a href="https://arxiv.org/abs/2107.00630" target="_blank"><tt>https://arxiv.org/abs/2107.00630</tt></a></li>
<li> See also David Foster <em>Generative Deep Learning</em>, chapter 8 on diffusion models.</li>
</ol>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="diffusion-models-basics">Diffusion models, basics </h2>

<p>Diffusion models are inspired by non-equilibrium thermodynamics. They
define a Markov chain of diffusion steps to slowly add random noise to
data and then learn to reverse the diffusion process to construct
desired data samples from the noise. Unlike VAE or flow models,
diffusion models are learned with a fixed procedure and the latent
variable has high dimensionality (same as the original data).
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="why-diffusion-models">Why diffusion models? </h2>

<p>Diffusion models are prominent in generating high-quality images,
video, sound, etc. They are named for their similarity to the natural
diffusion process in physics, which describes how molecules move from
high-concentration to low-concentration areas. In the context of
machine learning, diffusion models generate new data by reversing a
diffusion process, that is information loss due to noise
intervention. The main idea here is to add random noise to data and
then undo the process to get the original data distribution from the
noisy data.
</p>

<p>The famous DALL-E 2, Midjourney, and open-source Stable Diffusion that
create realistic images based on the user's text input are all
examples of diffusion models.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="what-are-diffusion-models">What are diffusion models? </h2>

<p>Diffusion models are advanced machine learning algorithms that
uniquely generate high-quality data by progressively adding noise to a
dataset and then learning to reverse this process. This innovative
approach enables them to create remarkably accurate and detailed
outputs, from lifelike images to coherent text sequences. Central to
their function is the concept of gradually degrading data quality,
only to reconstruct it to its original form or transform it into
something new. This technique enhances the fidelity of generated data
and offers new possibilities in areas like medical imaging, autonomous
vehicles, and personalized AI assistants.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="problems-with-probabilistic-models">Problems with probabilistic models </h2>

<p>Historically, probabilistic models suffer from a tradeoff between two
conflicting objectives: <em>tractability</em> and
<em>flexibility</em>. Models that are <em>tractable</em> can be
analytically evaluated and easily fit to data (e.g. a Gaussian or
Laplace). However, these models are unable to aptly describe structure
in rich datasets. On the other hand, models that are <em>flexible</em>
can be molded to fit structure in arbitrary data. For example, we can
define models in terms of any (non-negative) function \( \phi(\boldsymbol{x}) \)
yielding the flexible distribution
</p>
$$
p\left(\boldsymbol{x}\right) =\frac{\phi\left(\boldsymbol{x} \right)}{Z},
$$

<p>where \( Z \) is a normalization
constant. However, computing this normalization constant is generally
intractable. Evaluating, training, or drawing samples from such
flexible models typically requires a very expensive Monte Carlo
process.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="diffusion-models">Diffusion models </h2>
<p>Diffusion models have several interesting features</p>
<ul>
<li> extreme flexibility in model structure,</li>
<li> exact sampling,</li>
<li> easy multiplication with other distributions, e.g. in order to compute a posterior, and</li>
<li> the model log likelihood, and the probability of individual states, to be cheaply evaluated.</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="original-idea">Original idea </h2>

<p>In the original formulation, one uses a Markov chain to gradually
convert one distribution into another, an idea used in non-equilibrium
statistical physics and sequential Monte Carlo. Diffusion models build
a generative Markov chain which converts a simple known distribution
(e.g. a Gaussian) into a target (data) distribution using a diffusion
process. Rather than use this Markov chain to approximately evaluate a
model which has been otherwise defined, one can  explicitly define the
probabilistic model as the endpoint of the Markov chain. Since each
step in the diffusion chain has an analytically evaluable probability,
the full chain can also be analytically evaluated.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="diffusion-learning">Diffusion learning </h2>

<p>Learning in this framework involves estimating small perturbations to
a diffusion process. Estimating small, analytically tractable,
perturbations is more tractable than explicitly describing the full
distribution with a single, non-analytically-normalizable, potential
function.  Furthermore, since a diffusion process exists for any
smooth target distribution, this method can capture data distributions
of arbitrary form.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="how-diffusion-models-work">How diffusion models work </h2>

<p>Diffusion models work in a dual-phase mechanism: They first train a
neural network to introduce noise into the dataset(a staple in the
forward diffusion process) and then methodically reverse this
process. 
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="data-preprocessing">Data preprocessing </h2>

<p>Before the diffusion process begins, data needs to be appropriately
formatted for model training. This process involves data cleaning to
remove outliers, data normalization to scale features consistently,
and data augmentation to increase dataset diversity, especially in the
case of image data. Standardization is also applied to achieve normal
data distribution, which is important for handling noisy image
data. Different data types, such as text or images, may require
specific preprocessing steps, like addressing class-imbalance
issues. Well-executed data processing ensures high-quality training
data and contributes to the model's ability to learn meaningful
patterns and generate high-quality images (or other data types) during
inference.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="mathematics-of-diffusion-models">Mathematics of diffusion models </h2>

<p>Let us go back our discussions of the variational autoencoders from the lecture of April 24, see
<a href="https://github.com/CompPhysics/AdvancedMachineLearning/blob/main/doc/pub/week14/ipynb/week14.ipynb" target="_blank"><tt>https://github.com/CompPhysics/AdvancedMachineLearning/blob/main/doc/pub/week14/ipynb/week14.ipynb</tt></a>. As
a first attempt at understanding diffusion models, we can think of
these as stacked VAEs, or better, recursive VAEs.
</p>

<p>Let us try to see why. As an intermediate step, we consider so-called
hierarchical VAEs, which can be seen as a generalization of VAEs that
include multiple hierarchies of latent spaces.
</p>

<p><b>Note</b>: Many of the derivations and figures here are inspired and borrowed from the excellent exposition of diffusion models by Calvin Luo at <a href="https://arxiv.org/abs/2208.11970" target="_blank"><tt>https://arxiv.org/abs/2208.11970</tt></a>. </p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="chains-of-vaes">Chains of VAEs </h2>

<p>Markovian
VAEs represent a  generative process where we use  Markov chain to build a hierarchy of VAEs.
</p>

<p>Each transition down the hierarchy is Markovian, where we decode each
latent set of variables \( \boldsymbol{h}_t \) in terms of the previous latent variable \( \boldsymbol{h}_{t-1} \).
Intuitively, and visually, this can be seen as simply stacking VAEs on
top of each other (see figure next slide).
</p>

<p>One can think of such a model as a recursive VAE.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="mathematical-representation">Mathematical representation </h2>

<p>Mathematically, we represent the joint distribution and the posterior
of a Markovian VAE as
</p>
$$
\begin{align*}
    p(\boldsymbol{x}, \boldsymbol{h}_{1:T}) &= p(\boldsymbol{h}_T)p_{\boldsymbol{\theta}}(\boldsymbol{x}|\boldsymbol{h}_1)\prod_{t=2}^{T}p_{\boldsymbol{\theta}}(\boldsymbol{h}_{t-1}|\boldsymbol{h}_{t})\\
    q_{\boldsymbol{\phi}}(\boldsymbol{h}_{1:T}|\boldsymbol{x}) &= q_{\boldsymbol{\phi}}(\boldsymbol{h}_1|\boldsymbol{x})\prod_{t=2}^{T}q_{\boldsymbol{\phi}}(\boldsymbol{h}_{t}|\boldsymbol{h}_{t-1})
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="back-to-the-marginal-probability">Back to the marginal probability </h2>

<p>We can then define the marginal probability we want to optimize as</p>
$$
\begin{align*}
\log p(\boldsymbol{x}) &= \log \int p(\boldsymbol{x}, \boldsymbol{h}_{1:T}) d\boldsymbol{h}_{1:T}  \\
&= \log \int \frac{p(\boldsymbol{x}, \boldsymbol{h}_{1:T})q_{\boldsymbol{\phi}}(\boldsymbol{h}_{1:T}|\boldsymbol{x})}{q_{\boldsymbol{\phi}}(\boldsymbol{h}_{1:T}|\boldsymbol{x})} d\boldsymbol{h}_{1:T}         && \text{(Multiply by 1 = $\frac{q_{\boldsymbol{\phi}}(\boldsymbol{h}_{1:T}|\boldsymbol{x})}{q_{\boldsymbol{\phi}}(\boldsymbol{h}_{1:T}|\boldsymbol{x})}$)}\\
&= \log \mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}_{1:T}|\boldsymbol{x})}\left[\frac{p(\boldsymbol{x}, \boldsymbol{h}_{1:T})}{q_{\boldsymbol{\phi}}(\boldsymbol{h}_{1:T}|\boldsymbol{x})}\right]         && \text{(Definition of Expectation)}\\
&\geq \mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}_{1:T}|\boldsymbol{x})}\left[\log \frac{p(\boldsymbol{x}, \boldsymbol{h}_{1:T})}{q_{\boldsymbol{\phi}}(\boldsymbol{h}_{1:T}|\boldsymbol{x})}\right]         && \text{(Discussed last week)}
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="diffusion-models-for-hierarchical-vae-from-url-https-arxiv-org-abs-2208-11970">Diffusion models for hierarchical VAE, from <a href="https://arxiv.org/abs/2208.11970" target="_blank"><tt>https://arxiv.org/abs/2208.11970</tt></a>  </h2>

<p>A Markovian hierarchical Variational Autoencoder with \( T \) hierarchical
latents.  The generative process is modeled as a Markov chain, where
each latent \( \boldsymbol{h}_t \) is generated only from the previous latent
\( \boldsymbol{h}_{t+1} \). Here \( \boldsymbol{z} \) is our latent variable \( \boldsymbol{h} \).
</p>

<br/><br/>
<center>
<p><img src="figures/figure1.png" width="800" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="equation-for-the-markovian-hierarchical-vae">Equation for the Markovian hierarchical VAE </h2>

<p>We obtain then</p>
$$
\begin{align*}
\mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}_{1:T}|\boldsymbol{x})}\left[\log \frac{p(\boldsymbol{x}, \boldsymbol{h}_{1:T})}{q_{\boldsymbol{\phi}}(\boldsymbol{h}_{1:T}|\boldsymbol{x})}\right]
&= \mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}_{1:T}|\boldsymbol{x})}\left[\log \frac{p(\boldsymbol{h}_T)p_{\boldsymbol{\theta}}(\boldsymbol{x}|\boldsymbol{h}_1)\prod_{t=2}^{T}p_{\boldsymbol{\theta}}(\boldsymbol{h}_{t-1}|\boldsymbol{h}_{t})}{q_{\boldsymbol{\phi}}(\boldsymbol{h}_1|\boldsymbol{x})\prod_{t=2}^{T}q_{\boldsymbol{\phi}}(\boldsymbol{h}_{t}|\boldsymbol{h}_{t-1})}\right]
\end{align*}
$$

<p>We will modify this equation when we discuss what are normally called Variational Diffusion Models.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="variational-diffusion-models">Variational Diffusion Models </h2>

<p>The easiest way to think of a Variational Diffusion Model (VDM) is as a Markovian Hierarchical Variational Autoencoder with three key restrictions:</p>

<ol>
<li> The latent dimension is exactly equal to the data dimension</li>
<li> The structure of the latent encoder at each timestep is not learned; it is pre-defined as a linear Gaussian model.  In other words, it is a Gaussian distribution centered around the output of the previous timestep</li>
<li> The Gaussian parameters of the latent encoders vary over time in such a way that the distribution of the latent at final timestep \( T \) is a standard Gaussian</li>
</ol>
<p>The VDM posterior is</p>
$$
\begin{align*}
    q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0) = \prod_{t = 1}^{T}q(\boldsymbol{x}_{t}|\boldsymbol{x}_{t-1})
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="second-assumption">Second assumption </h2>

<p>The distribution of each latent variable in the encoder is a Gaussian centered around its previous hierarchical latent.
Here then, the structure of the encoder at each timestep \( t \) is not learned; it
is fixed as a linear Gaussian model, where the mean and standard
deviation can be set beforehand as hyperparameters, or learned as
parameters.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="parameterizing-gaussian-encoder">Parameterizing Gaussian encoder </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>We parameterize the Gaussian encoder with mean \( \boldsymbol{\mu}_t(\boldsymbol{x}_t) =
\sqrt{\alpha_t} \boldsymbol{x}_{t-1} \), and variance \( \boldsymbol{\Sigma}_t(\boldsymbol{x}_t) =
(1 - \alpha_t) \textbf{I} \), where the form of the coefficients are
chosen such that the variance of the latent variables stay at a
similar scale; in other words, the encoding process is
variance-preserving.
</p>
</div>


<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Note that alternate Gaussian parameterizations
are allowed, and lead to similar derivations.  The main takeaway is
that \( \alpha_t \) is a (potentially learnable) coefficient that can vary
with the hierarchical depth \( t \), for flexibility.
</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="encoder-transitions">Encoder transitions </h2>

<p>Mathematically, the encoder transitions are defined as</p>
$$
\begin{align*}
    q(\boldsymbol{x}_{t}|\boldsymbol{x}_{t-1}) = \mathcal{N}(\boldsymbol{x}_{t} ; \sqrt{\alpha_t} \boldsymbol{x}_{t-1}, (1 - \alpha_t) \textbf{I}) \label{eq:27}
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="third-assumption">Third assumption </h2>

<p>From the third assumption, we know that \( \alpha_t \) evolves over time
according to a fixed or learnable schedule structured such that the
distribution of the final latent \( p(\boldsymbol{x}_T) \) is a standard Gaussian.
We can then update the joint distribution of a Markovian VAE to write
the joint distribution for a VDM as
</p>

$$
\begin{align*}
p(\boldsymbol{x}_{0:T}) &= p(\boldsymbol{x}_T)\prod_{t=1}^{T}p_{\boldsymbol{\theta}}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t) \\
\text{where,}&\nonumber\\
p(\boldsymbol{x}_T) &= \mathcal{N}(\boldsymbol{x}_T; \boldsymbol{0}, \textbf{I})
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="noisification">Noisification </h2>

<p>Collectively, what this set of assumptions describes is a steady
noisification of an image input over time. We progressively corrupt an
image by adding Gaussian noise until eventually it becomes completely
identical to pure Gaussian noise.  See figure on next slide.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="diffusion-models-from-url-https-arxiv-org-abs-2208-11970">Diffusion models, from <a href="https://arxiv.org/abs/2208.11970" target="_blank"><tt>https://arxiv.org/abs/2208.11970</tt></a>  </h2>

<br/><br/>
<center>
<p><img src="figures/figure2.png" width="800" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="gaussian-modeling">Gaussian modeling </h2>

<p>Note that our encoder distributions \( q(\boldsymbol{x}_t|\boldsymbol{x}_{t-1}) \) are no
longer parameterized by \( \boldsymbol{\phi} \), as they are completely modeled as
Gaussians with defined mean and variance parameters at each timestep.
Therefore, in a VDM, we are only interested in learning conditionals
\( p_{\boldsymbol{\theta}}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_{t}) \), so that we can simulate
new data.  After optimizing the VDM, the sampling procedure is as
simple as sampling Gaussian noise from \( p(\boldsymbol{x}_T) \) and iteratively
running the denoising transitions
\( p_{\boldsymbol{\theta}}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_{t}) \) for \( T \) steps to generate a
novel \( \boldsymbol{x}_0 \).
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="optimizing-the-variational-diffusion-model">Optimizing the variational diffusion model </h2>

$$
\begin{align*}
\log p(\boldsymbol{x})
&= \log \int p(\boldsymbol{x}_{0:T}) d\boldsymbol{x}_{1:T}\\
&= \log \int \frac{p(\boldsymbol{x}_{0:T})q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} d\boldsymbol{x}_{1:T}\\
&= \log \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\left[\frac{p(\boldsymbol{x}_{0:T})}{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\right]\\
&\geq {\mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\left[\log \frac{p(\boldsymbol{x}_{0:T})}{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\right]}\\
&= {\mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\left[\log \frac{p(\boldsymbol{x}_T)\prod_{t=1}^{T}p_{\boldsymbol{\theta}}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)}{\prod_{t = 1}^{T}q(\boldsymbol{x}_{t}|\boldsymbol{x}_{t-1})}\right]}\\
&= {\mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\left[\log \frac{p(\boldsymbol{x}_T)p_{\boldsymbol{\theta}}(\boldsymbol{x}_0|\boldsymbol{x}_1)\prod_{t=2}^{T}p_{\boldsymbol{\theta}}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)}{q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1})\prod_{t = 1}^{T-1}q(\boldsymbol{x}_{t}|\boldsymbol{x}_{t-1})}\right]}\\
&= {\mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\left[\log \frac{p(\boldsymbol{x}_T)p_{\boldsymbol{\theta}}(\boldsymbol{x}_0|\boldsymbol{x}_1)\prod_{t=1}^{T-1}p_{\boldsymbol{\theta}}(\boldsymbol{x}_{t}|\boldsymbol{x}_{t+1})}{q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1})\prod_{t = 1}^{T-1}q(\boldsymbol{x}_{t}|\boldsymbol{x}_{t-1})}\right]}\\
&= {\mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\left[\log \frac{p(\boldsymbol{x}_T)p_{\boldsymbol{\theta}}(\boldsymbol{x}_0|\boldsymbol{x}_1)}{q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1})}\right] + \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\left[\log \prod_{t = 1}^{T-1}\frac{p_{\boldsymbol{\theta}}(\boldsymbol{x}_{t}|\boldsymbol{x}_{t+1})}{q(\boldsymbol{x}_{t}|\boldsymbol{x}_{t-1})}\right]}\\
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="continues">Continues </h2>

$$
\begin{align*}
\log p(\boldsymbol{x})
&= {\mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\left[\log \frac{p(\boldsymbol{x}_T)p_{\boldsymbol{\theta}}(\boldsymbol{x}_0|\boldsymbol{x}_1)}{q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1})}\right] + \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\left[\log \prod_{t = 1}^{T-1}\frac{p_{\boldsymbol{\theta}}(\boldsymbol{x}_{t}|\boldsymbol{x}_{t+1})}{q(\boldsymbol{x}_{t}|\boldsymbol{x}_{t-1})}\right]}\\
&= {\mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\left[\log p_{\boldsymbol{\theta}}(\boldsymbol{x}_0|\boldsymbol{x}_1)\right] + \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\left[\log \frac{p(\boldsymbol{x}_T)}{q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1})}\right] + \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\left[ \sum_{t=1}^{T-1} \log \frac{p_{\boldsymbol{\theta}}(\boldsymbol{x}_{t}|\boldsymbol{x}_{t+1})}{q(\boldsymbol{x}_{t}|\boldsymbol{x}_{t-1})}\right]}\\
&= {\mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\left[\log p_{\boldsymbol{\theta}}(\boldsymbol{x}_0|\boldsymbol{x}_1)\right] + \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\left[\log \frac{p(\boldsymbol{x}_T)}{q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1})}\right] + \sum_{t=1}^{T-1}\mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\left[ \log \frac{p_{\boldsymbol{\theta}}(\boldsymbol{x}_{t}|\boldsymbol{x}_{t+1})}{q(\boldsymbol{x}_{t}|\boldsymbol{x}_{t-1})}\right]}\\
&= {\mathbb{E}_{q(\boldsymbol{x}_{1}|\boldsymbol{x}_0)}\left[\log p_{\boldsymbol{\theta}}(\boldsymbol{x}_0|\boldsymbol{x}_1)\right] + \mathbb{E}_{q(\boldsymbol{x}_{T-1}, \boldsymbol{x}_T|\boldsymbol{x}_0)}\left[\log \frac{p(\boldsymbol{x}_T)}{q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1})}\right] + \sum_{t=1}^{T-1}\mathbb{E}_{q(\boldsymbol{x}_{t-1}, \boldsymbol{x}_t, \boldsymbol{x}_{t+1}|\boldsymbol{x}_0)}\left[\log \frac{p_{\boldsymbol{\theta}}(\boldsymbol{x}_{t}|\boldsymbol{x}_{t+1})}{q(\boldsymbol{x}_{t}|\boldsymbol{x}_{t-1})}\right]}\\
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="interpretations">Interpretations </h2>

<p>These equations can be interpreted as</p>

<ul>
<li> \( \mathbb{E}_{q(\boldsymbol{x}_{1}|\boldsymbol{x}_0)}\left[\log p_{\boldsymbol{\theta}}(\boldsymbol{x}_0|\boldsymbol{x}_1)\right] \) can be interpreted as a <b>reconstruction term</b>, predicting the log probability of the original data sample given the first-step latent.  This term also appears in a vanilla VAE, and can be trained similarly.</li>
<li> \( \mathbb{E}_{q(\boldsymbol{x}_{T-1}|\boldsymbol{x}_0)}\left[D_{KL}(q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1})\vert\vert p(\boldsymbol{x}_T))\right] \) is a <b>prior matching term</b>; it is minimized when the final latent distribution matches the Gaussian prior.  This term requires no optimization, as it has no trainable parameters; furthermore, as we have assumed a large enough \( T \) such that the final distribution is Gaussian, this term effectively becomes zero.</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-last-term">The last term </h2>

<ul>
<li> \( \mathbb{E}_{q(\boldsymbol{x}_{t-1}, \boldsymbol{x}_{t+1}|\boldsymbol{x}_0)}\left[D_{KL}(q(\boldsymbol{x}_{t}|\boldsymbol{x}_{t-1})\vert\vert p_{\boldsymbol{\theta}}(\boldsymbol{x}_{t}|\boldsymbol{x}_{t+1}))\right] \) is a <em>consistency term</em>; it attempts to make the distribution at \( \boldsymbol{x}_t \) consistent, from both forward and backward processes.  That is, a denoising step from a noisier image should match the corresponding noising step from a cleaner image, for every intermediate timestep; this is reflected mathematically by the KL Divergence.  This term is minimized when we train \( p_{\theta}(\boldsymbol{x}_t|\boldsymbol{x}_{t+1}) \) to match the Gaussian distribution \( q(\boldsymbol{x}_t|\boldsymbol{x}_{t-1}) \).</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="diffusion-models-part-2-from-url-https-arxiv-org-abs-2208-11970">Diffusion models, part 2, from <a href="https://arxiv.org/abs/2208.11970" target="_blank"><tt>https://arxiv.org/abs/2208.11970</tt></a>  </h2>

<br/><br/>
<center>
<p><img src="figures/figure3.png" width="800" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="optimization-cost">Optimization cost </h2>

<p>The cost of optimizing a VDM is primarily dominated by the third term, since we must optimize over all timesteps \( t \).</p>

<p>Under this derivation, all three terms are computed as expectations,
and can therefore be approximated using Monte Carlo estimates.
However, actually optimizing the ELBO using the terms we just derived
might be suboptimal; because the consistency term is computed as an
expectation over two random variables \( \left\{\boldsymbol{x}_{t-1},
\boldsymbol{x}_{t+1}\right\} \) for every timestep, the variance of its Monte
Carlo estimate could potentially be higher than a term that is
estimated using only one random variable per timestep.  As it is
computed by summing up \( T-1 \) consistency terms, the final estimated
value may have high variance for large \( T \) values.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="image-quality">Image quality </h2>

<p>An advantage of diffusion models over for example VAEs (and also GANs
to be discussed next time) is the ease of training with simple and
efficient loss functions and their ability to generate highly
realistic images. They excel at closely matching the distribution of
real images, outperforming GANs in this aspect. This proficiency is
due to the distinct mechanisms in diffusion models, allowing for more
precise replication of real-world imagery.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="training-stability">Training stability </h2>

<p>Regarding training stability, generative diffusion models have an edge
over GANs. GANs often struggle with <em>mode collapse</em>, which is  a limitation
where they produce a limited output variety. Diffusion models
effectively avoid this issue through their gradual data smoothing
process, leading to a more diverse range of generated images.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="input-types">Input types </h2>

<p>It is also important to mention that diffusion models handle various
input types. They perform diverse generative tasks like text-to-image
synthesis, layout-to-image generation, inpainting, and
super-resolution tasks.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="denoising-diffusion-probabilistic-models-ddpms">Denoising diffusion probabilistic models (DDPMs) </h2>

<p>Denoising diffusion probabilistic models (DDPMs) are a specific type
of diffusion model that focuses on probabilistically removing noise
from data. During training, they learn how noise is added to data over
time and how to reverse this process to recover the original
data. This involves using probabilities to make educated guesses about
what the data looked like before noise was added. This approach is
essential for the model's capability to accurately reconstruct data,
ensuring the outputs aren&#8217;t just noise-free but also closely resemble
the original data.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="techniques-for-speeding-up-diffusion-models">Techniques for speeding up diffusion models </h2>

<p>Generating a sample from DDPM using the reverse diffusion process is
quite slow because it involves many steps, possibly up to a
thousand. For instance, according to Song et al. (2020), it takes
about 20 hours to generate 50,000 small images with a DDPM, while a
GAN can create the same amount in less than a minute using an Nvidia
2080 Ti GPU.
</p>

<p>There is an alternative method called Denoising Diffusion Implicit
Model (DDIM) that stands out for its efficiency and quality. Unlike
traditional models, DDIM needs fewer steps to create clear images from
noisy data.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="applications-of-diffusion-models">Applications of diffusion models </h2>

<p>There are very diverse applications of diffusion models, one of the most exciting being digital art creation.
The document at <a href="https://www.superannotate.com/blog/diffusion-models#:~:text=A%20primary%20advantage%20of%20diffusion,to%20generate%20highly%20realistic%20images" target="_blank"><tt>https://www.superannotate.com/blog/diffusion-models#:~:text=A%20primary%20advantage%20of%20diffusion,to%20generate%20highly%20realistic%20images</tt></a> gives many nice examples of applications.
.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="pytorch-implementation-of-a-denoising-diffusion-probabilistic-model-ddpm-trained-on-the-mnist-dataset">PyTorch implementation of a Denoising Diffusion Probabilistic Model (DDPM) trained on the MNIST dataset </h2>

<p>The code covers:</p>
<ol>
<li> Model definition (a simple U-Net-style convolutional network)</li>
<li> Forward diffusion (adding noise over \( T \) timesteps)</li>
<li> Reverse denoising process</li>
<li> Training loop</li>
<li> Sampling from the trained model</li>
</ol>
<p>This example is adapted from several open-source tutorials and
implementations, demonstrating how to build a diffusion model from
scratch in under 200 lines of PyTorch.
I have borrowed extensively from 
</p>
<ol>
<li> Jackson-Kang&#8217;s PyTorch diffusion tutorial, see <a href="https://github.com/Jackson-Kang/Pytorch-Diffusion-Model-Tutorial" target="_blank"><tt>https://github.com/Jackson-Kang/Pytorch-Diffusion-Model-Tutorial</tt></a>  and</li>
<li> awjuliani&#8217;s PyTorch DDPM implementation, see <a href="https://github.com/awjuliani/pytorch-diffusion" target="_blank"><tt>https://github.com/awjuliani/pytorch-diffusion</tt></a></li>  
</ol>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="what-is-a-u-net">What is a U-net? </h2>

<p>UNet is a type of convolutional neural network (CNN) Architecture that is primarily used for image segmentation tasks. See <a href="https://en.wikipedia.org/wiki/U-Net" target="_blank"><tt>https://en.wikipedia.org/wiki/U-Net</tt></a> or <a href="https://www.sciencedirect.com/topics/computer-science/u-net" target="_blank"><tt>https://www.sciencedirect.com/topics/computer-science/u-net</tt></a></p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="problem-with-diffusion-models">Problem with diffusion models </h2>

<p>Diffusion models gradually corrupt data by adding Gaussian noise over
a sequence of timesteps and then learn to reverse this noising process
with a neural network.
</p>

<p>The corruption schedule is typically linear or cosine in variance.</p>

<p>During training, the network is optimized to predict the original
noise added at each timestep, using a mean-squared error loss.
</p>

<p>At inference, one starts from random noise and iteratively applies the
learned denoising steps to generate new samples.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="imports-and-utilities">Imports and Utilities </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torch</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torch.nn</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">nn</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torch.nn.functional</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">F</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">torchvision</span> <span style="color: #008000; font-weight: bold">import</span> datasets, transforms
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">torch.utils.data</span> <span style="color: #008000; font-weight: bold">import</span> DataLoader
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">math</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="hyperparameters-and-schedules">Hyperparameters and schedules </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">device <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;cuda&#39;</span> <span style="color: #008000; font-weight: bold">if</span> torch<span style="color: #666666">.</span>cuda<span style="color: #666666">.</span>is_available() <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">&#39;cpu&#39;</span>

<span style="color: #408080; font-style: italic"># Training settings</span>
batch_size <span style="color: #666666">=</span> <span style="color: #666666">128</span>
epochs     <span style="color: #666666">=</span> <span style="color: #666666">5</span>
lr         <span style="color: #666666">=</span> <span style="color: #666666">2e-4</span>
img_size   <span style="color: #666666">=</span> <span style="color: #666666">28</span>
channels   <span style="color: #666666">=</span> <span style="color: #666666">1</span>

<span style="color: #408080; font-style: italic"># Diffusion hyperparameters</span>
T <span style="color: #666666">=</span> <span style="color: #666666">300</span>  <span style="color: #408080; font-style: italic"># number of diffusion steps  [oai_citation:5‡Medium](https://papers-100-lines.medium.com/diffusion-models-from-scratch-mnist-data-tutorial-in-100-lines-of-pytorch-code-a609e1558cee?utm_source=chatgpt.com)</span>
beta_start, beta_end <span style="color: #666666">=</span> <span style="color: #666666">1e-4</span>, <span style="color: #666666">0.02</span>
betas <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>linspace(beta_start, beta_end, T, device<span style="color: #666666">=</span>device)  <span style="color: #408080; font-style: italic"># linear schedule  [oai_citation:6‡Medium](https://medium.com/data-science/diffusion-model-from-scratch-in-pytorch-ddpm-9d9760528946?utm_source=chatgpt.com)</span>
alphas <span style="color: #666666">=</span> <span style="color: #666666">1.</span> <span style="color: #666666">-</span> betas
alphas_cumprod <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>cumprod(alphas, dim<span style="color: #666666">=0</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="data-loading">Data Loading </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">transform <span style="color: #666666">=</span> transforms<span style="color: #666666">.</span>Compose([
    transforms<span style="color: #666666">.</span>ToTensor(),
    transforms<span style="color: #666666">.</span>Normalize((<span style="color: #666666">0.5</span>,), (<span style="color: #666666">0.5</span>,)),
])

train_ds <span style="color: #666666">=</span> datasets<span style="color: #666666">.</span>MNIST(<span style="color: #BA2121">&#39;.&#39;</span>, train<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>, download<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>, transform<span style="color: #666666">=</span>transform)
train_loader <span style="color: #666666">=</span> DataLoader(train_ds, batch_size<span style="color: #666666">=</span>batch_size, shuffle<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="model-definition">Model definition </h2>

<p>We present a  lightweight U-Net inspired model for noise prediction:</p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SimpleUNet</span>(nn<span style="color: #666666">.</span>Module):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, c):
        <span style="color: #008000">super</span>()<span style="color: #666666">.</span><span style="color: #0000FF">__init__</span>()
        <span style="color: #008000">self</span><span style="color: #666666">.</span>enc1 <span style="color: #666666">=</span> nn<span style="color: #666666">.</span>Conv2d(c, <span style="color: #666666">64</span>, <span style="color: #666666">3</span>, padding<span style="color: #666666">=1</span>)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>enc2 <span style="color: #666666">=</span> nn<span style="color: #666666">.</span>Conv2d(<span style="color: #666666">64</span>, <span style="color: #666666">128</span>, <span style="color: #666666">3</span>, padding<span style="color: #666666">=1</span>)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>dec1 <span style="color: #666666">=</span> nn<span style="color: #666666">.</span>ConvTranspose2d(<span style="color: #666666">128</span>, <span style="color: #666666">64</span>, <span style="color: #666666">3</span>, padding<span style="color: #666666">=1</span>)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>dec2 <span style="color: #666666">=</span> nn<span style="color: #666666">.</span>ConvTranspose2d(<span style="color: #666666">64</span>, c, <span style="color: #666666">3</span>, padding<span style="color: #666666">=1</span>)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>act  <span style="color: #666666">=</span> nn<span style="color: #666666">.</span>ReLU()
        <span style="color: #408080; font-style: italic"># timestep embedding to condition on t</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>time_mlp <span style="color: #666666">=</span> nn<span style="color: #666666">.</span>Sequential(nn<span style="color: #666666">.</span>Linear(<span style="color: #666666">1</span>, <span style="color: #666666">128</span>), nn<span style="color: #666666">.</span>ReLU(),nn<span style="color: #666666">.</span>Linear(<span style="color: #666666">128</span>, <span style="color: #666666">128</span>))

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">forward</span>(<span style="color: #008000">self</span>, x, t):
        <span style="color: #408080; font-style: italic"># x: [B, C, H, W], t: [B]</span>
        h <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>act(<span style="color: #008000">self</span><span style="color: #666666">.</span>enc1(x))
        h <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>act(<span style="color: #008000">self</span><span style="color: #666666">.</span>enc2(h))
        <span style="color: #408080; font-style: italic"># add time embedding</span>
        t <span style="color: #666666">=</span> t<span style="color: #666666">.</span>unsqueeze(<span style="color: #666666">-1</span>)                             
        temb <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>time_mlp(t)
        temb <span style="color: #666666">=</span> temb<span style="color: #666666">.</span>view(<span style="color: #666666">-1</span>, <span style="color: #666666">128</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1</span>)
        h <span style="color: #666666">=</span> h <span style="color: #666666">+</span> temb
        h <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>act(<span style="color: #008000">self</span><span style="color: #666666">.</span>dec1(h))
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>dec2(h)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="forward-diffusion-q-x-t-vert-x-0">Forward Diffusion \( q(x_t\vert x_0) \) </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">q_sample</span>(x0, t, noise<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">None</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Add noise to x0 at timestep t.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">if</span> noise <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
        noise <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>randn_like(x0)
    sqrt_acp <span style="color: #666666">=</span> alphas_cumprod[t]<span style="color: #666666">**0.5</span>
    sqrt_1macp <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> alphas_cumprod[t])<span style="color: #666666">**0.5</span>
    <span style="color: #008000; font-weight: bold">return</span> sqrt_acp<span style="color: #666666">.</span>view(<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>,<span style="color: #666666">1</span>,<span style="color: #666666">1</span>)<span style="color: #666666">*</span>x0 <span style="color: #666666">+</span> sqrt_1macp<span style="color: #666666">.</span>view(<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>,<span style="color: #666666">1</span>,<span style="color: #666666">1</span>)<span style="color: #666666">*</span>noise
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="cost-loss-function">Cost/Loss function </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">diffusion_loss</span>(model, x0):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Compute MSE between predicted noise and true noise.&quot;&quot;&quot;</span>
    B <span style="color: #666666">=</span> x0<span style="color: #666666">.</span>size(<span style="color: #666666">0</span>)
    t <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>randint(<span style="color: #666666">0</span>, T, (B,), device<span style="color: #666666">=</span>device)<span style="color: #666666">.</span>long()
    noise <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>randn_like(x0)
    x_noisy <span style="color: #666666">=</span> q_sample(x0, t, noise)
    pred_noise <span style="color: #666666">=</span> model(x_noisy, t<span style="color: #666666">.</span>float()<span style="color: #666666">/</span>T)
    <span style="color: #008000; font-weight: bold">return</span> F<span style="color: #666666">.</span>mse_loss(pred_noise, noise)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="training-loop">Training loop </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">model <span style="color: #666666">=</span> SimpleUNet(channels)<span style="color: #666666">.</span>to(device)
opt   <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>optim<span style="color: #666666">.</span>Adam(model<span style="color: #666666">.</span>parameters(), lr<span style="color: #666666">=</span>lr)

<span style="color: #008000; font-weight: bold">for</span> epoch <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(epochs):
    total_loss <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> x, _ <span style="color: #AA22FF; font-weight: bold">in</span> train_loader:
        x <span style="color: #666666">=</span> x<span style="color: #666666">.</span>to(device)
        loss <span style="color: #666666">=</span> diffusion_loss(model, x)
        opt<span style="color: #666666">.</span>zero_grad()
        loss<span style="color: #666666">.</span>backward()
        opt<span style="color: #666666">.</span>step()
        total_loss <span style="color: #666666">+=</span> loss<span style="color: #666666">.</span>item()
    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;Epoch </span><span style="color: #BB6688; font-weight: bold">{</span>epoch<span style="color: #666666">+1</span><span style="color: #BB6688; font-weight: bold">}</span><span style="color: #BA2121">/</span><span style="color: #BB6688; font-weight: bold">{</span>epochs<span style="color: #BB6688; font-weight: bold">}</span><span style="color: #BA2121">, Loss: </span><span style="color: #BB6688; font-weight: bold">{</span>total_loss<span style="color: #666666">/</span><span style="color: #008000">len</span>(train_loader)<span style="color: #BB6688; font-weight: bold">:</span><span style="color: #BA2121">.4f</span><span style="color: #BB6688; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="sampling-reverse-diffusion">Sampling (Reverse Diffusion) </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #AA22FF">@torch</span><span style="color: #666666">.</span>no_grad()
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">p_sample_loop</span>(model, shape):
    x <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>randn(shape, device<span style="color: #666666">=</span>device)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">reversed</span>(<span style="color: #008000">range</span>(T)):
        t <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>full((shape[<span style="color: #666666">0</span>],), i, device<span style="color: #666666">=</span>device)<span style="color: #666666">.</span>float()<span style="color: #666666">/</span>T
        eps_pred <span style="color: #666666">=</span> model(x, t)
        beta_t <span style="color: #666666">=</span> betas[i]
        alpha_t <span style="color: #666666">=</span> alphas[i]
        acp_t   <span style="color: #666666">=</span> alphas_cumprod[i]
        coef1 <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">/</span> alpha_t<span style="color: #666666">.</span>sqrt()
        coef2 <span style="color: #666666">=</span> beta_t <span style="color: #666666">/</span> ( (<span style="color: #666666">1</span> <span style="color: #666666">-</span> acp_t)<span style="color: #666666">.</span>sqrt() )
        x <span style="color: #666666">=</span> coef1<span style="color: #666666">*</span>(x <span style="color: #666666">-</span> coef2<span style="color: #666666">*</span>eps_pred)
        <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>:
            z <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>randn_like(x)
            sigma <span style="color: #666666">=</span> beta_t<span style="color: #666666">.</span>sqrt()
            x <span style="color: #666666">=</span> x <span style="color: #666666">+</span> sigma<span style="color: #666666">*</span>z
    <span style="color: #008000; font-weight: bold">return</span> x

<span style="color: #408080; font-style: italic"># Generate samples</span>
samples <span style="color: #666666">=</span> p_sample_loop(model, (<span style="color: #666666">16</span>, channels, img_size, img_size))
samples <span style="color: #666666">=</span> samples<span style="color: #666666">.</span>clamp(<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>)<span style="color: #666666">.</span>cpu()
grid <span style="color: #666666">=</span> torchvision<span style="color: #666666">.</span>utils<span style="color: #666666">.</span>make_grid(samples, nrow<span style="color: #666666">=4</span>, normalize<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
plt<span style="color: #666666">.</span>figure(figsize<span style="color: #666666">=</span>(<span style="color: #666666">5</span>,<span style="color: #666666">5</span>))
plt<span style="color: #666666">.</span>imshow(grid<span style="color: #666666">.</span>permute(<span style="color: #666666">1</span>,<span style="color: #666666">2</span>,<span style="color: #666666">0</span>))
plt<span style="color: #666666">.</span>axis(<span style="color: #BA2121">&#39;off&#39;</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="more-details-and-plans-for-next-week">More details and plans for next week </h2>

<p>For more details and implementations, see Calvin Luo at <a href="https://arxiv.org/abs/2208.11970" target="_blank"><tt>https://arxiv.org/abs/2208.11970</tt></a></p>
<div class="alert alert-block alert-block alert-text-normal">
<b>Plans for next week</b>
<p>
<ol>
<li> Finalizing discussion of diffusion models</li>
<li> Presenting generalized adversarial networks (GANs)</li>
<li> Possible summary of works</li>
<li> Discussion of project 2</li>
</ol>
</div>


<!-- ------------------- end of main content --------------- -->
<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2025, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>
</body>
</html>

