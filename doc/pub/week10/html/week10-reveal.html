<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html week10-reveal.html week10-reveal reveal --html_slide_theme=beige
-->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Advanced machine learning and data analysis for the physical sciences">
<title>Advanced machine learning and data analysis for the physical sciences</title>

<!-- reveal.js: https://lab.hakim.se/reveal-js/ -->

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<!--
<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/beigesmall.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/serif.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/moon.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/darkgray.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/cbc.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simula.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
-->

<!-- For syntax highlighting -->
<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<style type="text/css">
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.reveal .alert-text-small   { font-size: 80%;  }
.reveal .alert-text-large   { font-size: 130%; }
.reveal .alert-text-normal  { font-size: 90%;  }
.reveal .alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:5px solid #bababa;
  -webkit-border-radius: 14px; -moz-border-radius: 14px;
  border-radius:14px;
  background-position: 10px 10px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 30px; /* 55px; if icon */
}
.reveal .alert-block {padding-top:14px; padding-bottom:14px}
.reveal .alert-block > p, .alert-block > ul {margin-bottom:1em}
/*.reveal .alert li {margin-top: 1em}*/
.reveal .alert-block p+p {margin-top:5px}
/*.reveal .alert-notice { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_notice.png); }
.reveal .alert-summary  { background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_summary.png); }
.reveal .alert-warning { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_warning.png); }
.reveal .alert-question {background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */
/* Override reveal.js table border */
.reveal table td {
  border: 0;
}

<style type="text/css">
/* Override h1, h2, ... styles */
h1 { font-size: 2.8em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.4em; }
h4 { font-size: 1.3em; }
h1, h2, h3, h4 { font-weight: bold; line-height: 1.2; }
body { overflow: auto; } /* vertical scrolling */
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.slide .alert-text-small   { font-size: 80%;  }
.slide .alert-text-large   { font-size: 130%; }
.slide .alert-text-normal  { font-size: 90%;  }
.slide .alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:5px solid #bababa;
    -webkit-border-radius:14px; -moz-border-radius:14px;
  border-radius:14px
  background-position: 10px 10px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 30px; /* 55px; if icon */
}
.slide .alert-block {padding-top:14px; padding-bottom:14px}
.slide .alert-block > p, .alert-block > ul {margin-bottom:0}
/*.slide .alert li {margin-top: 1em}*/
.deck .alert-block p+p {margin-top:5px}
/*.slide .alert-notice { background-image: url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_notice.png); }
.slide .alert-summary  { background-image:url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_summary.png); }
.slide .alert-warning { background-image: url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_warning.png); }
.slide .alert-question {background-image:url(https://hplgit.github.io/doconce/
bundled/html_images/small_gray_question.png); } */
.dotable table, .dotable th, .dotable tr, .dotable tr td {
  border: 2px solid black;
  border-collapse: collapse;
  padding: 2px;
}
</style>


<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>


<body>
<div class="reveal">
<div class="slides">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




<section>
<!-- ------------------- main content ---------------------- -->
<center>
<h1 style="text-align: center;">Advanced machine learning and data analysis for the physical sciences</h1>
</center>  <!-- document title -->

<!-- author(s): Morten Hjorth-Jensen -->
<center>
<b>Morten Hjorth-Jensen</b> 
</center>
<!-- institution -->
<center>
<b>Department of Physics and Center for Computing in Science Education, University of Oslo, Norway</b>
</center>
<br>
<center>
<h4>March 27</h4>
</center> <!-- date -->
<br>


<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2025, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>
</section>

<section>
<h2 id="plans-for-the-week-march-24-28">Plans for the week March 24-28  </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ol>
<p><li> Finalizing discussion on autoencoders and implementing Autoencoders with TensorFlow/Keras and PyTorch</li>
<p><li> Overview of generative models</li>
<p><li> Probability distributions and Markov Chain Monte Carlo simulations</li>
<p><li> If we get time, we end the lecture  with Boltzmann machines and energy models</li>
<p><li> Reading recommendation: Goodfellow et al chapters 16 and 18.1 and 18.2. Chapter 17 gives a background to Monte Carlo Markov Chains.
<!-- o <a href="https://youtu.be/8s0QC1MvdYg" target="_blank">Video of lecture</a> -->
<!-- o <a href="https://github.com/CompPhysics/AdvancedMachineLearning/blob/main/doc/HandwrittenNotes/2024/NotesMarch19.pdf" target="_blank">Whiteboard notes</a> --></li>
</ol>
</div>
</section>

<section>
<h2 id="autoencoders-code-examples">Autoencoders: code examples </h2>

<p>These examples here are based the codes from A. Geron's textbook. They
can be easily  modified and adapted to different data sets. The first example is a straightforward AE.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sys</span>
<span style="color: #8B008B; font-weight: bold">assert</span> sys.version_info &gt;= (<span style="color: #B452CD">3</span>, <span style="color: #B452CD">5</span>)

<span style="color: #228B22"># Is this notebook running on Colab or Kaggle?</span>
IS_COLAB = <span style="color: #CD5555">&quot;google.colab&quot;</span> <span style="color: #8B008B">in</span> sys.modules
IS_KAGGLE = <span style="color: #CD5555">&quot;kaggle_secrets&quot;</span> <span style="color: #8B008B">in</span> sys.modules

<span style="color: #228B22"># Scikit-Learn &gt;=0.20 is required</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sklearn</span>
<span style="color: #8B008B; font-weight: bold">assert</span> sklearn.__version__ &gt;= <span style="color: #CD5555">&quot;0.20&quot;</span>

<span style="color: #228B22"># TensorFlow &gt;= 2.0 is required</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">tensorflow</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">tf</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tensorflow</span> <span style="color: #8B008B; font-weight: bold">import</span> keras
<span style="color: #8B008B; font-weight: bold">assert</span> tf.__version__ &gt;= <span style="color: #CD5555">&quot;2.0&quot;</span>

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> tf.config.list_physical_devices(<span style="color: #CD5555">&#39;GPU&#39;</span>):
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;No GPU was detected. LSTMs and CNNs can be very slow without a GPU.&quot;</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> IS_COLAB:
        <span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Go to Runtime &gt; Change runtime and select a GPU hardware accelerator.&quot;</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> IS_KAGGLE:
        <span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Go to Settings &gt; Accelerator and select GPU.&quot;</span>)

<span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>

<span style="color: #228B22"># to make this notebook&#39;s output stable across runs</span>
np.random.seed(<span style="color: #B452CD">42</span>)
tf.random.set_seed(<span style="color: #B452CD">42</span>)

<span style="color: #228B22"># To plot pretty figures</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">mpl</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
mpl.rc(<span style="color: #CD5555">&#39;axes&#39;</span>, labelsize=<span style="color: #B452CD">14</span>)
mpl.rc(<span style="color: #CD5555">&#39;xtick&#39;</span>, labelsize=<span style="color: #B452CD">12</span>)
mpl.rc(<span style="color: #CD5555">&#39;ytick&#39;</span>, labelsize=<span style="color: #B452CD">12</span>)

<span style="color: #228B22"># Where to save the figures</span>
PROJECT_ROOT_DIR = <span style="color: #CD5555">&quot;.&quot;</span>
CHAPTER_ID = <span style="color: #CD5555">&quot;autoencoders&quot;</span>
IMAGES_PATH = os.path.join(PROJECT_ROOT_DIR, <span style="color: #CD5555">&quot;images&quot;</span>, CHAPTER_ID)
os.makedirs(IMAGES_PATH, exist_ok=<span style="color: #8B008B; font-weight: bold">True</span>)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">save_fig</span>(fig_id, tight_layout=<span style="color: #8B008B; font-weight: bold">True</span>, fig_extension=<span style="color: #CD5555">&quot;png&quot;</span>, resolution=<span style="color: #B452CD">300</span>):
    path = os.path.join(IMAGES_PATH, fig_id + <span style="color: #CD5555">&quot;.&quot;</span> + fig_extension)
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&quot;Saving figure&quot;</span>, fig_id)
    <span style="color: #8B008B; font-weight: bold">if</span> tight_layout:
        plt.tight_layout()
    plt.savefig(path, <span style="color: #658b00">format</span>=fig_extension, dpi=resolution)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">plot_image</span>(image):
    plt.imshow(image, cmap=<span style="color: #CD5555">&quot;binary&quot;</span>)
    plt.axis(<span style="color: #CD5555">&quot;off&quot;</span>)


np.random.seed(<span style="color: #B452CD">4</span>)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">generate_3d_data</span>(m, w1=<span style="color: #B452CD">0.1</span>, w2=<span style="color: #B452CD">0.3</span>, noise=<span style="color: #B452CD">0.1</span>):
    angles = np.random.rand(m) * <span style="color: #B452CD">3</span> * np.pi / <span style="color: #B452CD">2</span> - <span style="color: #B452CD">0.5</span>
    data = np.empty((m, <span style="color: #B452CD">3</span>))
    data[:, <span style="color: #B452CD">0</span>] = np.cos(angles) + np.sin(angles)/<span style="color: #B452CD">2</span> + noise * np.random.randn(m) / <span style="color: #B452CD">2</span>
    data[:, <span style="color: #B452CD">1</span>] = np.sin(angles) * <span style="color: #B452CD">0.7</span> + noise * np.random.randn(m) / <span style="color: #B452CD">2</span>
    data[:, <span style="color: #B452CD">2</span>] = data[:, <span style="color: #B452CD">0</span>] * w1 + data[:, <span style="color: #B452CD">1</span>] * w2 + noise * np.random.randn(m)
    <span style="color: #8B008B; font-weight: bold">return</span> data

X_train = generate_3d_data(<span style="color: #B452CD">60</span>)
X_train = X_train - X_train.mean(axis=<span style="color: #B452CD">0</span>, keepdims=<span style="color: #B452CD">0</span>)


np.random.seed(<span style="color: #B452CD">42</span>)
tf.random.set_seed(<span style="color: #B452CD">42</span>)

encoder = keras.models.Sequential([keras.layers.Dense(<span style="color: #B452CD">2</span>, input_shape=[<span style="color: #B452CD">3</span>])])
decoder = keras.models.Sequential([keras.layers.Dense(<span style="color: #B452CD">3</span>, input_shape=[<span style="color: #B452CD">2</span>])])
autoencoder = keras.models.Sequential([encoder, decoder])

autoencoder.compile(loss=<span style="color: #CD5555">&quot;mse&quot;</span>, optimizer=keras.optimizers.SGD(learning_rate=<span style="color: #B452CD">1.5</span>))

codings = encoder.predict(X_train)
fig = plt.figure(figsize=(<span style="color: #B452CD">4</span>,<span style="color: #B452CD">3</span>))
plt.plot(codings[:,<span style="color: #B452CD">0</span>], codings[:, <span style="color: #B452CD">1</span>], <span style="color: #CD5555">&quot;b.&quot;</span>)
plt.xlabel(<span style="color: #CD5555">&quot;$z_1$&quot;</span>, fontsize=<span style="color: #B452CD">18</span>)
plt.ylabel(<span style="color: #CD5555">&quot;$z_2$&quot;</span>, fontsize=<span style="color: #B452CD">18</span>, rotation=<span style="color: #B452CD">0</span>)
plt.grid(<span style="color: #8B008B; font-weight: bold">True</span>)
save_fig(<span style="color: #CD5555">&quot;linear_autoencoder_pca_plot&quot;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="more-advanced-features-stacked-aes">More advanced features, stacked AEs </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># You can select the so-called fashion data as well, here we just use the MNIST standard set</span>
<span style="color: #228B22">#(X_train_full, y_train_full), (X_test, y_test) = keras.datasets.fashion_mnist.load_data()</span>
(X_train_full, y_train_full), (X_test, y_test) = keras.datasets.mnist.load_data()
X_train_full = X_train_full.astype(np.float32) / <span style="color: #B452CD">255</span>
X_test = X_test.astype(np.float32) / <span style="color: #B452CD">255</span>
X_train, X_valid = X_train_full[:-<span style="color: #B452CD">5000</span>], X_train_full[-<span style="color: #B452CD">5000</span>:]
y_train, y_valid = y_train_full[:-<span style="color: #B452CD">5000</span>], y_train_full[-<span style="color: #B452CD">5000</span>:]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>We can now train all layers at once by building a stacked AE with 3 hidden layers and 1 output layer (i.e., 2 stacked Autoencoders).</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">rounded_accuracy</span>(y_true, y_pred):
    <span style="color: #8B008B; font-weight: bold">return</span> keras.metrics.binary_accuracy(tf.round(y_true), tf.round(y_pred))
tf.random.set_seed(<span style="color: #B452CD">42</span>)
np.random.seed(<span style="color: #B452CD">42</span>)

stacked_encoder = keras.models.Sequential([
    keras.layers.Flatten(input_shape=[<span style="color: #B452CD">28</span>, <span style="color: #B452CD">28</span>]),
    keras.layers.Dense(<span style="color: #B452CD">100</span>, activation=<span style="color: #CD5555">&quot;selu&quot;</span>),
    keras.layers.Dense(<span style="color: #B452CD">30</span>, activation=<span style="color: #CD5555">&quot;selu&quot;</span>),
])
stacked_decoder = keras.models.Sequential([
    keras.layers.Dense(<span style="color: #B452CD">100</span>, activation=<span style="color: #CD5555">&quot;selu&quot;</span>, input_shape=[<span style="color: #B452CD">30</span>]),
    keras.layers.Dense(<span style="color: #B452CD">28</span> * <span style="color: #B452CD">28</span>, activation=<span style="color: #CD5555">&quot;sigmoid&quot;</span>),
    keras.layers.Reshape([<span style="color: #B452CD">28</span>, <span style="color: #B452CD">28</span>])
])
stacked_ae = keras.models.Sequential([stacked_encoder, stacked_decoder])
stacked_ae.compile(loss=<span style="color: #CD5555">&quot;binary_crossentropy&quot;</span>,
                   optimizer=keras.optimizers.SGD(learning_rate=<span style="color: #B452CD">1.5</span>), metrics=[rounded_accuracy])
history = stacked_ae.fit(X_train, X_train, epochs=<span style="color: #B452CD">20</span>,
                         validation_data=(X_valid, X_valid))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>This function processes a few test images through the autoencoder and
displays the original images and their reconstructions.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">show_reconstructions</span>(model, images=X_valid, n_images=<span style="color: #B452CD">5</span>):
    reconstructions = model.predict(images[:n_images])
    fig = plt.figure(figsize=(n_images * <span style="color: #B452CD">1.5</span>, <span style="color: #B452CD">3</span>))
    <span style="color: #8B008B; font-weight: bold">for</span> image_index <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n_images):
        plt.subplot(<span style="color: #B452CD">2</span>, n_images, <span style="color: #B452CD">1</span> + image_index)
        plot_image(images[image_index])
        plt.subplot(<span style="color: #B452CD">2</span>, n_images, <span style="color: #B452CD">1</span> + n_images + image_index)
        plot_image(reconstructions[image_index])
show_reconstructions(stacked_ae)
save_fig(<span style="color: #CD5555">&quot;reconstruction_plot&quot;</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Then visualize </p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">np.random.seed(<span style="color: #B452CD">42</span>)
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sklearn.manifold</span> <span style="color: #8B008B; font-weight: bold">import</span> TSNE
X_valid_compressed = stacked_encoder.predict(X_valid)
tsne = TSNE()
X_valid_2D = tsne.fit_transform(X_valid_compressed)
X_valid_2D = (X_valid_2D - X_valid_2D.min()) / (X_valid_2D.max() - X_valid_2D.min())
plt.scatter(X_valid_2D[:, <span style="color: #B452CD">0</span>], X_valid_2D[:, <span style="color: #B452CD">1</span>], c=y_valid, s=<span style="color: #B452CD">10</span>, cmap=<span style="color: #CD5555">&quot;tab10&quot;</span>)
plt.axis(<span style="color: #CD5555">&quot;off&quot;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>And visualize in a nicer way</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># adapted from https://scikit-learn.org/stable/auto_examples/manifold/plot_lle_digits.html</span>
plt.figure(figsize=(<span style="color: #B452CD">10</span>, <span style="color: #B452CD">8</span>))
cmap = plt.cm.tab10
plt.scatter(X_valid_2D[:, <span style="color: #B452CD">0</span>], X_valid_2D[:, <span style="color: #B452CD">1</span>], c=y_valid, s=<span style="color: #B452CD">10</span>, cmap=cmap)
image_positions = np.array([[<span style="color: #B452CD">1.</span>, <span style="color: #B452CD">1.</span>]])
<span style="color: #8B008B; font-weight: bold">for</span> index, position <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(X_valid_2D):
    dist = np.sum((position - image_positions) ** <span style="color: #B452CD">2</span>, axis=<span style="color: #B452CD">1</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> np.min(dist) &gt; <span style="color: #B452CD">0.02</span>: <span style="color: #228B22"># if far enough from other images</span>
        image_positions = np.r_[image_positions, [position]]
        imagebox = mpl.offsetbox.AnnotationBbox(
            mpl.offsetbox.OffsetImage(X_valid[index], cmap=<span style="color: #CD5555">&quot;binary&quot;</span>),
            position, bboxprops={<span style="color: #CD5555">&quot;edgecolor&quot;</span>: cmap(y_valid[index]), <span style="color: #CD5555">&quot;lw&quot;</span>: <span style="color: #B452CD">2</span>})
        plt.gca().add_artist(imagebox)
plt.axis(<span style="color: #CD5555">&quot;off&quot;</span>)
save_fig(<span style="color: #CD5555">&quot;fashion_mnist_visualization_plot&quot;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="using-convolutional-layers-instead-of-dense-layers">Using Convolutional Layers Instead of Dense Layers </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">tf.random.set_seed(<span style="color: #B452CD">42</span>)
np.random.seed(<span style="color: #B452CD">42</span>)

conv_encoder = keras.models.Sequential([
    keras.layers.Reshape([<span style="color: #B452CD">28</span>, <span style="color: #B452CD">28</span>, <span style="color: #B452CD">1</span>], input_shape=[<span style="color: #B452CD">28</span>, <span style="color: #B452CD">28</span>]),
    keras.layers.Conv2D(<span style="color: #B452CD">16</span>, kernel_size=<span style="color: #B452CD">3</span>, padding=<span style="color: #CD5555">&quot;SAME&quot;</span>, activation=<span style="color: #CD5555">&quot;selu&quot;</span>),
    keras.layers.MaxPool2D(pool_size=<span style="color: #B452CD">2</span>),
    keras.layers.Conv2D(<span style="color: #B452CD">32</span>, kernel_size=<span style="color: #B452CD">3</span>, padding=<span style="color: #CD5555">&quot;SAME&quot;</span>, activation=<span style="color: #CD5555">&quot;selu&quot;</span>),
    keras.layers.MaxPool2D(pool_size=<span style="color: #B452CD">2</span>),
    keras.layers.Conv2D(<span style="color: #B452CD">64</span>, kernel_size=<span style="color: #B452CD">3</span>, padding=<span style="color: #CD5555">&quot;SAME&quot;</span>, activation=<span style="color: #CD5555">&quot;selu&quot;</span>),
    keras.layers.MaxPool2D(pool_size=<span style="color: #B452CD">2</span>)
])
conv_decoder = keras.models.Sequential([
    keras.layers.Conv2DTranspose(<span style="color: #B452CD">32</span>, kernel_size=<span style="color: #B452CD">3</span>, strides=<span style="color: #B452CD">2</span>, padding=<span style="color: #CD5555">&quot;VALID&quot;</span>, activation=<span style="color: #CD5555">&quot;selu&quot;</span>,
                                 input_shape=[<span style="color: #B452CD">3</span>, <span style="color: #B452CD">3</span>, <span style="color: #B452CD">64</span>]),
    keras.layers.Conv2DTranspose(<span style="color: #B452CD">16</span>, kernel_size=<span style="color: #B452CD">3</span>, strides=<span style="color: #B452CD">2</span>, padding=<span style="color: #CD5555">&quot;SAME&quot;</span>, activation=<span style="color: #CD5555">&quot;selu&quot;</span>),
    keras.layers.Conv2DTranspose(<span style="color: #B452CD">1</span>, kernel_size=<span style="color: #B452CD">3</span>, strides=<span style="color: #B452CD">2</span>, padding=<span style="color: #CD5555">&quot;SAME&quot;</span>, activation=<span style="color: #CD5555">&quot;sigmoid&quot;</span>),
    keras.layers.Reshape([<span style="color: #B452CD">28</span>, <span style="color: #B452CD">28</span>])
])
conv_ae = keras.models.Sequential([conv_encoder, conv_decoder])

conv_ae.compile(loss=<span style="color: #CD5555">&quot;binary_crossentropy&quot;</span>, optimizer=keras.optimizers.SGD(learning_rate=<span style="color: #B452CD">1.0</span>),
                metrics=[rounded_accuracy])
history = conv_ae.fit(X_train, X_train, epochs=<span style="color: #B452CD">5</span>,
                      validation_data=(X_valid, X_valid))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">conv_encoder.summary()
conv_decoder.summary()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">show_reconstructions(conv_ae)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="recurrent-autoencoders">Recurrent Autoencoders </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">recurrent_encoder = keras.models.Sequential([
    keras.layers.LSTM(<span style="color: #B452CD">100</span>, return_sequences=<span style="color: #8B008B; font-weight: bold">True</span>, input_shape=[<span style="color: #B452CD">28</span>, <span style="color: #B452CD">28</span>]),
    keras.layers.LSTM(<span style="color: #B452CD">30</span>)
])
recurrent_decoder = keras.models.Sequential([
    keras.layers.RepeatVector(<span style="color: #B452CD">28</span>, input_shape=[<span style="color: #B452CD">30</span>]),
    keras.layers.LSTM(<span style="color: #B452CD">100</span>, return_sequences=<span style="color: #8B008B; font-weight: bold">True</span>),
    keras.layers.TimeDistributed(keras.layers.Dense(<span style="color: #B452CD">28</span>, activation=<span style="color: #CD5555">&quot;sigmoid&quot;</span>))
])
recurrent_ae = keras.models.Sequential([recurrent_encoder, recurrent_decoder])
recurrent_ae.compile(loss=<span style="color: #CD5555">&quot;binary_crossentropy&quot;</span>, optimizer=keras.optimizers.SGD(<span style="color: #B452CD">0.1</span>),
                     metrics=[rounded_accuracy])
history = recurrent_ae.fit(X_train, X_train, epochs=<span style="color: #B452CD">10</span>, validation_data=(X_valid, X_valid))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">show_reconstructions(recurrent_ae)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="stacked-denoising-autoencoder-with-gaussian-noise">Stacked denoising Autoencoder with Gaussian noise </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">tf.random.set_seed(<span style="color: #B452CD">42</span>)
np.random.seed(<span style="color: #B452CD">42</span>)

denoising_encoder = keras.models.Sequential([
    keras.layers.Flatten(input_shape=[<span style="color: #B452CD">28</span>, <span style="color: #B452CD">28</span>]),
    keras.layers.GaussianNoise(<span style="color: #B452CD">0.2</span>),
    keras.layers.Dense(<span style="color: #B452CD">100</span>, activation=<span style="color: #CD5555">&quot;selu&quot;</span>),
    keras.layers.Dense(<span style="color: #B452CD">30</span>, activation=<span style="color: #CD5555">&quot;selu&quot;</span>)
])
denoising_decoder = keras.models.Sequential([
    keras.layers.Dense(<span style="color: #B452CD">100</span>, activation=<span style="color: #CD5555">&quot;selu&quot;</span>, input_shape=[<span style="color: #B452CD">30</span>]),
    keras.layers.Dense(<span style="color: #B452CD">28</span> * <span style="color: #B452CD">28</span>, activation=<span style="color: #CD5555">&quot;sigmoid&quot;</span>),
    keras.layers.Reshape([<span style="color: #B452CD">28</span>, <span style="color: #B452CD">28</span>])
])
denoising_ae = keras.models.Sequential([denoising_encoder, denoising_decoder])
denoising_ae.compile(loss=<span style="color: #CD5555">&quot;binary_crossentropy&quot;</span>, optimizer=keras.optimizers.SGD(learning_rate=<span style="color: #B452CD">1.0</span>),
                     metrics=[rounded_accuracy])
history = denoising_ae.fit(X_train, X_train, epochs=<span style="color: #B452CD">10</span>,
                           validation_data=(X_valid, X_valid))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">tf.random.set_seed(<span style="color: #B452CD">42</span>)
np.random.seed(<span style="color: #B452CD">42</span>)

noise = keras.layers.GaussianNoise(<span style="color: #B452CD">0.2</span>)
show_reconstructions(denoising_ae, noise(X_valid, training=<span style="color: #8B008B; font-weight: bold">True</span>))
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>And using dropout</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">tf.random.set_seed(<span style="color: #B452CD">42</span>)
np.random.seed(<span style="color: #B452CD">42</span>)

dropout_encoder = keras.models.Sequential([
    keras.layers.Flatten(input_shape=[<span style="color: #B452CD">28</span>, <span style="color: #B452CD">28</span>]),
    keras.layers.Dropout(<span style="color: #B452CD">0.5</span>),
    keras.layers.Dense(<span style="color: #B452CD">100</span>, activation=<span style="color: #CD5555">&quot;selu&quot;</span>),
    keras.layers.Dense(<span style="color: #B452CD">30</span>, activation=<span style="color: #CD5555">&quot;selu&quot;</span>)
])
dropout_decoder = keras.models.Sequential([
    keras.layers.Dense(<span style="color: #B452CD">100</span>, activation=<span style="color: #CD5555">&quot;selu&quot;</span>, input_shape=[<span style="color: #B452CD">30</span>]),
    keras.layers.Dense(<span style="color: #B452CD">28</span> * <span style="color: #B452CD">28</span>, activation=<span style="color: #CD5555">&quot;sigmoid&quot;</span>),
    keras.layers.Reshape([<span style="color: #B452CD">28</span>, <span style="color: #B452CD">28</span>])
])
dropout_ae = keras.models.Sequential([dropout_encoder, dropout_decoder])
dropout_ae.compile(loss=<span style="color: #CD5555">&quot;binary_crossentropy&quot;</span>, optimizer=keras.optimizers.SGD(learning_rate=<span style="color: #B452CD">1.0</span>),
                   metrics=[rounded_accuracy])
history = dropout_ae.fit(X_train, X_train, epochs=<span style="color: #B452CD">10</span>,
                         validation_data=(X_valid, X_valid))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">tf.random.set_seed(<span style="color: #B452CD">42</span>)
np.random.seed(<span style="color: #B452CD">42</span>)

dropout = keras.layers.Dropout(<span style="color: #B452CD">0.5</span>)
show_reconstructions(dropout_ae, dropout(X_valid, training=<span style="color: #8B008B; font-weight: bold">True</span>))
save_fig(<span style="color: #CD5555">&quot;dropout_denoising_plot&quot;</span>, tight_layout=<span style="color: #8B008B; font-weight: bold">False</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="pytorch-example">PyTorch example </h2>
<p>We will continue with the MNIST database, which has \( 60000 \) training examples and a test set of 10000 handwritten numbers. The images have
only one color channel and have a size of \( 28\times 28 \) pixels.
We start by uploading the data set.
</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># import the Torch packages</span>
<span style="color: #228B22"># transforms are used to preprocess the images, e.g. crop, rotate, normalize, etc</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">torch</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">torchvision</span> <span style="color: #8B008B; font-weight: bold">import</span> datasets,transforms

<span style="color: #228B22"># specify the data path in which you would like to store the downloaded files</span>
<span style="color: #228B22"># ToTensor() here is used to convert data type to tensor</span>

train_dataset = datasets.MNIST(root=<span style="color: #CD5555">&#39;./mnist_data/&#39;</span>, train=<span style="color: #8B008B; font-weight: bold">True</span>, transform=transforms.ToTensor(), download=<span style="color: #8B008B; font-weight: bold">True</span>)
test_dataset = datasets.MNIST(root=<span style="color: #CD5555">&#39;./mnist_data/&#39;</span>, train=<span style="color: #8B008B; font-weight: bold">False</span>, transform=transforms.ToTensor(), download=<span style="color: #8B008B; font-weight: bold">True</span>)
<span style="color: #658b00">print</span>(train_dataset)
batchSize=<span style="color: #B452CD">128</span>

<span style="color: #228B22">#only after packed in DataLoader, can we feed the data into the neural network iteratively</span>
train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=batchSize, shuffle=<span style="color: #8B008B; font-weight: bold">True</span>)
test_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=batchSize, shuffle=<span style="color: #8B008B; font-weight: bold">False</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>We visualize the images here using the \( imshow \) function  function and the \( make\_grid \) function from PyTorch to arrange and display them.</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># package we used to manipulate matrix</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #228B22"># package we used for image processing</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">matplotlib</span> <span style="color: #8B008B; font-weight: bold">import</span> pyplot <span style="color: #8B008B; font-weight: bold">as</span> plt
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">torchvision.utils</span> <span style="color: #8B008B; font-weight: bold">import</span> make_grid

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">imshow</span>(img):
    npimg = img.numpy()
    <span style="color: #228B22">#transpose: change array axis to correspond to the plt.imshow() function     </span>
    plt.imshow(np.transpose(npimg, (<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>, <span style="color: #B452CD">0</span>))) 
    plt.show()

<span style="color: #228B22"># load the first 16 training samples from next iteration</span>
<span style="color: #228B22"># [:16,:,:,:] for the 4 dimension of examples, first dimension take first 16, other dimension take all data</span>
<span style="color: #228B22"># arrange the image in grid</span>
examples, _ = <span style="color: #658b00">next</span>(<span style="color: #658b00">iter</span>(train_loader))
example_show=make_grid(examples[:<span style="color: #B452CD">16</span>,:,:,:], <span style="color: #B452CD">4</span>)

<span style="color: #228B22"># then display them</span>
imshow(example_show)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Our autoencoder consists of two parts, see also the TensorFlow example
above. The encoder and decoder parts are represented by two fully
connected feed forward neural networks where we use the standard
Sigmoid function.  In the encoder part we reduce the dimensionality of
the image from \( 28\times 28=784 \) pixels to first \( 16\times 16=256 \)
pixels and then to 128 pixels. The 128 pixel representation is then
used to define the representation of the input and the input to the
decoder part.  The latter attempts to reconstruct the images.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">torch.nn</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">nn</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">torch.nn.functional</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">F</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">torch.optim</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">optim</span>

<span style="color: #228B22"># Network Parameters</span>
num_hidden_1 = <span style="color: #B452CD">256</span>  <span style="color: #228B22"># 1st layer num features</span>
num_hidden_2 = <span style="color: #B452CD">128</span>  <span style="color: #228B22"># 2nd layer num features (the latent dim)</span>
num_input = <span style="color: #B452CD">784</span>  <span style="color: #228B22"># MNIST data input (img shape: 28*28)</span>


<span style="color: #228B22"># Building the encoder</span>
<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">Autoencoder</span>(nn.Module):
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>, x_dim, h_dim1, h_dim2):
        <span style="color: #658b00">super</span>(Autoencoder, <span style="color: #658b00">self</span>).<span style="color: #008b45">__init__</span>()
        <span style="color: #228B22"># encoder part</span>
        <span style="color: #658b00">self</span>.fc1 = nn.Linear(x_dim, h_dim1)
        <span style="color: #658b00">self</span>.fc2 = nn.Linear(h_dim1, h_dim2)
        <span style="color: #228B22"># decoder part</span>
        <span style="color: #658b00">self</span>.fc3 = nn.Linear(h_dim2, h_dim1)
        <span style="color: #658b00">self</span>.fc4 = nn.Linear(h_dim1, x_dim)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">encoder</span>(<span style="color: #658b00">self</span>, x):
        x = torch.sigmoid(<span style="color: #658b00">self</span>.fc1(x))
        x = torch.sigmoid(<span style="color: #658b00">self</span>.fc2(x))
        <span style="color: #8B008B; font-weight: bold">return</span> x

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">decoder</span>(<span style="color: #658b00">self</span>, x):
        x = torch.sigmoid(<span style="color: #658b00">self</span>.fc3(x))
        x = torch.sigmoid(<span style="color: #658b00">self</span>.fc4(x))
        <span style="color: #8B008B; font-weight: bold">return</span> x

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">forward</span>(<span style="color: #658b00">self</span>, x):
        x = <span style="color: #658b00">self</span>.encoder(x)
        x = <span style="color: #658b00">self</span>.decoder(x)
        <span style="color: #8B008B; font-weight: bold">return</span> x

<span style="color: #228B22"># When initializing, it will run __init__() function as above</span>
model = Autoencoder(num_input, num_hidden_1, num_hidden_2)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>We define here the cost/loss function and the optimizer we employ (Adam here).</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># define loss function and parameters</span>
optimizer = optim.Adam(model.parameters())
epoch = <span style="color: #B452CD">100</span>
<span style="color: #228B22"># MSE loss will calculate Mean Squared Error between the inputs </span>
loss_function = nn.MSELoss()

<span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;====Training start====&#39;</span>)
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(epoch):
    train_loss = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> batch_idx, (data, _) <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(train_loader):
        <span style="color: #228B22"># prepare input data</span>
        inputs = torch.reshape(data,(-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">784</span>)) <span style="color: #228B22"># -1 can be any value.</span>
        <span style="color: #228B22"># set gradient to zero</span>
        optimizer.zero_grad()
        <span style="color: #228B22"># feed inputs into model</span>
        recon_x = model(inputs)
        <span style="color: #228B22"># calculating loss </span>
        loss = loss_function(recon_x, inputs)
        <span style="color: #228B22"># calculate gradient of each parameter</span>
        loss.backward()
        train_loss += loss.item()
        <span style="color: #228B22"># update the weight based on the gradient calculated</span>
        optimizer.step()
    <span style="color: #8B008B; font-weight: bold">if</span> i%<span style="color: #B452CD">10</span>==<span style="color: #B452CD">0</span>:    
        <span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;====&gt; Epoch: {} Average loss: {:.9f}&#39;</span>.format(i, train_loss ))
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;====Training finish====&#39;</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>As we have trained the network, we will now reconstruct various test samples to see if the model can generalize to data which
were not included in the training set. 
</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># load 16 images from testset</span>
inputs, _ = <span style="color: #658b00">next</span>(<span style="color: #658b00">iter</span>(test_loader))
inputs_example = make_grid(inputs[:<span style="color: #B452CD">16</span>,:,:,:],<span style="color: #B452CD">4</span>)
imshow(inputs_example)

<span style="color: #228B22">#convert from image to tensor</span>
<span style="color: #228B22">#inputs=inputs.cuda()</span>
inputs=torch.reshape(inputs,(-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">784</span>))

<span style="color: #228B22"># get the outputs from the trained model</span>
outputs=model(inputs)

<span style="color: #228B22">#convert from tensor to image</span>
outputs=torch.reshape(outputs,(-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>,<span style="color: #B452CD">28</span>,<span style="color: #B452CD">28</span>))
outputs=outputs.detach().cpu()

<span style="color: #228B22">#show the output images</span>
outputs_example = make_grid(outputs[:<span style="color: #B452CD">16</span>,:,:,:],<span style="color: #B452CD">4</span>)
imshow(outputs_example)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>After training the auto-encoder, we can now use the model to reconstruct some images.
In order to reconstruct different training images, the model
has learned to recognize how the image looks like and describe it in
the 128-dimensional  latent space. In other words, the visual information of
images is compressed and encoded in the 128-dimensional representations. As we
assume that samples from the same categories should be more visually
similar than those from different classes, the representations can
then be used for image recognition, i.e., handwritten digit images
recognition in our case.
</p>

<p>One simple way to recognize images is to randomly select ten training
samples from each class and annotate them with the corresponding label.
Then given the
test data, we can predict which classes they belong to by finding the
most similar labelled training samples to them.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># get 100 image-label pairs from training set</span>
x_train, y_train = <span style="color: #658b00">next</span>(<span style="color: #658b00">iter</span>(train_loader))

<span style="color: #228B22"># 10 classes, 10 samples per class, 100 in total</span>
candidates = np.random.choice(batchSize, <span style="color: #B452CD">10</span>*<span style="color: #B452CD">10</span>)

<span style="color: #228B22"># randomly select 100 samples</span>
x_train = x_train[candidates]
y_train = y_train[candidates]

<span style="color: #228B22"># display the selected samples and print their labels</span>

imshow(make_grid(x_train[:<span style="color: #B452CD">100</span>,:,:,:],<span style="color: #B452CD">10</span>))
<span style="color: #658b00">print</span>(y_train.reshape(<span style="color: #B452CD">10</span>, <span style="color: #B452CD">10</span>))

<span style="color: #228B22"># get 100 image-label pairs from test set</span>
x_test, y_test = <span style="color: #658b00">next</span>(<span style="color: #658b00">iter</span>(train_loader))
candidates_test = np.random.choice(batchSize, <span style="color: #B452CD">10</span>*<span style="color: #B452CD">10</span>)

x_test = x_test[candidates_test]
y_test = y_test[candidates_test]

<span style="color: #228B22"># display the selected samples and print their labels</span>
imshow(make_grid(x_test[:<span style="color: #B452CD">100</span>,:,:,:],<span style="color: #B452CD">10</span>))

<span style="color: #658b00">print</span>(y_test.reshape(<span style="color: #B452CD">10</span>, <span style="color: #B452CD">10</span>))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># compute the representations of training and test samples</span>
<span style="color: #228B22">#h_train=model.encoder(torch.reshape(x_train.cuda(),(-1,784)))</span>
<span style="color: #228B22">#h_test=model.encoder(torch.reshape(x_test.cuda(),(-1,784)))</span>
h_train=model.encoder(torch.reshape(x_train,(-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">784</span>)))
h_test=model.encoder(torch.reshape(x_test,(-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">784</span>)))

<span style="color: #228B22"># find the nearest training samples to each test instance, in terms of MSE</span>
MSEs = np.mean(np.power(np.expand_dims(h_test.detach().cpu(), axis=<span style="color: #B452CD">1</span>) - np.expand_dims(h_train.detach().cpu(), axis=<span style="color: #B452CD">0</span>), <span style="color: #B452CD">2</span>), axis=<span style="color: #B452CD">2</span>)
neighbours = MSEs.argmin(axis=<span style="color: #B452CD">1</span>)
predicts = y_train[neighbours]

<span style="color: #228B22"># print(np.stack([y_test, predicts], axis=1))</span>
<span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Recognition accuracy according to the learned representation is %.1f%%&#39;</span> % (<span style="color: #B452CD">100</span> * (y_test == predicts).numpy().astype(np.float32).mean()))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="what-is-generative-modeling">What Is Generative Modeling? </h2>

<p>Generative modeling can be broadly defined as follows:</p>

<p>Generative modeling is a branch of machine learning that involves
training a model to produce new data that is similar to a given
dataset.
</p>

<p>What does this mean in practice? Suppose we have a dataset containing
photos of horses. We can train a generative model on this dataset to
capture the rules that govern the complex relationships between pixels
in images of horses. Then we can sample from this model to create
novel, realistic images of horses that did not exist in the original
dataset. 
</p>
</section>

<section>
<h2 id="example-of-generative-modeling-taken-from-generative-deeep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html">Example of generative modeling, <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_blank">taken from Generative Deeep Learning by David Foster</a>  </h2>

<br/><br/>
<center>
<p><img src="figures/generativelearning.png" width="900" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="generative-modeling">Generative Modeling </h2>

<p>In order to build a generative model, we require a dataset consisting
of many examples of the entity we are trying to generate. This is
known as the training data, and one such data point is called an
observation.
</p>

<p>Each observation consists of many features. For an image generation
problem, the features are usually the individual pixel values; for a
text generation problem, the features could be individual words or
groups of letters. It is our goal to build a model that can generate
new sets of features that look as if they have been created using the
same rules as the original data. Conceptually, for image generation
this is an incredibly difficult task, considering the vast number of
ways that individual pixel values can be assigned and the relatively
tiny number of such arrangements that constitute an image of the
entity we are trying to generate.
</p>
</section>

<section>
<h2 id="generative-versus-discriminative-modeling">Generative Versus Discriminative Modeling </h2>

<p>In order to truly understand what generative modeling aims to achieve
and why this is important, it is useful to compare it to its
counterpart, discriminative modeling. If you have studied machine
learning, most problems you will have faced will have most likely been
discriminative in nature. 
</p>
</section>

<section>
<h2 id="example-of-discriminative-modeling-taken-from-generative-deeep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html">Example of discriminative modeling, <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_blank">taken from Generative Deeep Learning by David Foster</a>  </h2>

<br/><br/>
<center>
<p><img src="figures/standarddeeplearning.png" width="900" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="discriminative-modeling">Discriminative Modeling </h2>

<p>When performing discriminative modeling, each observation in the
training data has a label. For a binary classification problem such as
our data could be labeled as ones and zeros. Our model then learns how to
discriminate between these two groups and outputs the probability that
a new observation has label 1 or 0
</p>

<p>In contrast, generative modeling doesn&#8217;t require the dataset to be
labeled because it concerns itself with generating entirely new
data (for example an image), rather than trying to predict a label for say  a given image.
</p>
</section>

<section>
<h2 id="taxonomy-of-generative-deep-learning-taken-from-generative-deep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html">Taxonomy of generative deep learning, <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_blank">taken from Generative Deep Learning by David Foster</a>  </h2>

<br/><br/>
<center>
<p><img src="figures/generativemodels.png" width="900" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="statistics-and-bayes-theorem">Statistics and Bayes' theorem </h2>

<p>A central theorem in statistics is Bayes' theorem. This theorem plays a similar role as the good old Pythagoras' theorem in geometry.
Bayes' theorem is extremely simple to derive. But to do so we need some basic axioms from statistics.
</p>

<p>Assume we have two domains of events \( X=[x_0,x_1,\dots,x_{n-1}] \) and \( Y=[y_0,y_1,\dots,y_{n-1}] \).</p>

<p>We define also the likelihood for \( X \) and \( Y \) as \( p(X) \) and \( p(Y) \) respectively.
The likelihood of a specific event \( x_i \) (or \( y_i \)) is then written as \( p(X=x_i) \) or just \( p(x_i)=p_i \). 
</p>

<div class="alert alert-block alert-block alert-text-normal">
<b>Union of events is given by</b>
<p>
<p>&nbsp;<br>
$$
p(X \cup Y)= p(X)+p(Y)-p(X \cap Y).
$$
<p>&nbsp;<br>
</div>


<div class="alert alert-block alert-block alert-text-normal">
<b>The product rule (aka joint probability) is given by</b>
<p>
<p>&nbsp;<br>
$$
p(X \cup Y)= p(X,Y)= p(X\vert Y)p(Y)=p(Y\vert X)p(X),
$$
<p>&nbsp;<br>

<p>where we read \( p(X\vert Y) \) as the likelihood of obtaining \( X \) given \( Y \).</p>
</div>

<p>If we have independent events then \( p(X,Y)=p(X)p(Y) \).</p>
</section>

<section>
<h2 id="marginal-probability">Marginal Probability </h2>

<p>The marginal probability is defined in terms of only one of the set of variables \( X,Y \). For a discrete probability we have</p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>&nbsp;<br>
$$
p(X)=\sum_{i=0}^{n-1}p(X,Y=y_i)=\sum_{i=0}^{n-1}p(X\vert Y=y_i)p(Y=y_i)=\sum_{i=0}^{n-1}p(X\vert y_i)p(y_i).
$$
<p>&nbsp;<br>
</div>
</section>

<section>
<h2 id="conditional-probability">Conditional  Probability </h2>

<p>The conditional  probability, if \( p(Y) > 0 \), is </p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>&nbsp;<br>
$$
p(X\vert Y)= \frac{p(X,Y)}{p(Y)}=\frac{p(X,Y)}{\sum_{i=0}^{n-1}p(Y\vert X=x_i)p(x_i)}.
$$
<p>&nbsp;<br>
</div>
</section>

<section>
<h2 id="bayes-theorem">Bayes' Theorem </h2>

<p>If we combine the conditional probability with the marginal probability and the standard product rule, we have</p>
<p>&nbsp;<br>
$$
p(X\vert Y)= \frac{p(X,Y)}{p(Y)},
$$
<p>&nbsp;<br>

<p>which we can rewrite as</p>

<p>&nbsp;<br>
$$
p(X\vert Y)= \frac{p(X,Y)}{\sum_{i=0}^{n-1}p(Y\vert X=x_i)p(x_i)}=\frac{p(Y\vert X)p(X)}{\sum_{i=0}^{n-1}p(Y\vert X=x_i)p(x_i)},
$$
<p>&nbsp;<br>

<p>which is Bayes' theorem. It allows us to evaluate the uncertainty in in \( X \) after we have observed \( Y \). We can easily interchange \( X \) with \( Y \).  </p>
</section>

<section>
<h2 id="interpretations-of-bayes-theorem">Interpretations of Bayes' Theorem </h2>

<p>The quantity \( p(Y\vert X) \) on the right-hand side of the theorem is
evaluated for the observed data \( Y \) and can be viewed as a function of
the parameter space represented by \( X \). This function is not
necesseraly normalized and is normally called the likelihood function.
</p>

<p>The function \( p(X) \) on the right hand side is called the prior while the function on the left hand side is the called the posterior probability. The denominator on the right hand side serves as a normalization factor for the posterior distribution.</p>

<p>Let us try to illustrate Bayes' theorem through an example.</p>
</section>

<section>
<h2 id="example-of-usage-of-bayes-theorem">Example of Usage of Bayes' theorem </h2>

<p>Let us suppose that you are undergoing a series of mammography scans in
order to rule out possible breast cancer cases.  We define the
sensitivity for a positive event by the variable \( X \). It takes binary
values with \( X=1 \) representing a positive event and \( X=0 \) being a
negative event. We reserve \( Y \) as a classification parameter for
either a negative or a positive breast cancer confirmation. (Short note on wordings: positive here means having breast cancer, although none of us would consider this being a  positive thing).
</p>

<p>We let \( Y=1 \) represent the the case of having breast cancer and \( Y=0 \) as not.</p>

<p>Let us assume that if you have breast cancer, the test will be positive with a probability of \( 0.8 \), that is we have</p>

<p>&nbsp;<br>
$$
p(X=1\vert Y=1) =0.8.
$$
<p>&nbsp;<br>

<p>This obviously sounds  scary since many would conclude that if the test is positive, there is a likelihood of \( 80\% \) for having cancer.
It is however not correct, as the following Bayesian analysis shows.
</p>
</section>

<section>
<h2 id="doing-it-correctly">Doing it correctly </h2>

<p>If we look at various national surveys on breast cancer, the general likelihood of developing breast cancer is a very small number.
Let us assume that the prior probability in the population as a whole is
</p>

<p>&nbsp;<br>
$$
p(Y=1) =0.004.
$$
<p>&nbsp;<br>

<p>We need also to account for the fact that the test may produce a false positive result (false alarm). Let us here assume that we have</p>
<p>&nbsp;<br>
$$
p(X=1\vert Y=0) =0.1.
$$
<p>&nbsp;<br>

<p>Using Bayes' theorem we can then find the posterior probability that the person has breast cancer in case of a positive test, that is we can compute</p>

<p>&nbsp;<br>
$$
p(Y=1\vert X=1)=\frac{p(X=1\vert Y=1)p(Y=1)}{p(X=1\vert Y=1)p(Y=1)+p(X=1\vert Y=0)p(Y=0)}=\frac{0.8\times 0.004}{0.8\times 0.004+0.1\times 0.996}=0.031.
$$
<p>&nbsp;<br>

<p>That is, in case of a positive test, there is only a \( 3\% \) chance of having breast cancer!</p>
</section>

<section>
<h2 id="maximum-likelihood-estimation-mle">Maximum Likelihood Estimation (MLE) </h2>

<p>We assume now that the various variables are stochastically distributed and  
<b>Independent and Identically Distrubuted</b> (iid).
</p>

<p>In statistics, maximum likelihood estimation (MLE) is a method of
estimating the parameters of an assumed probability distribution,
given some observed data. This is achieved by maximizing a likelihood
function so that, under the assumed statistical model, the observed
data is the most probable. The probability is then written in terms of the products of the individual probabilities.
</p>

<p>However, computing the derivatives of a
product function is cumbersome and can easily lead to overflow and/or
underflowproblems, with potentials for loss of numerical precision.
</p>

<p>In practice, it is more convenient to maximize the logarithm of the
PDF because it is a monotonically increasing function of the argument.
Alternatively, and this will be our option, we will minimize the
negative of the logarithm since this is a monotonically decreasing
function.
</p>

<p>Note also that maximization/minimization of the logarithm of the PDF
is equivalent to the maximization/minimization of the function itself.
</p>
</section>

<section>
<h2 id="essential-elements-of-generative-models">Essential elements of generative models </h2>

<p>The aim of generative methods is to train a probability distribution \( p \). The methods we will focus on are:</p>
<ol>
<p><li> Energy based models, with the family of Boltzmann distributions as a typical example</li>
<p><li> Variational autoencoders, based on our discussions on autoencoders</li>
<p><li> Generative adversarial networks (GANs) and</li>
<p><li> Diffusion models</li>
</ol>
</section>

<section>
<h2 id="energy-models">Energy models </h2>

<p>We define a domain \( \boldsymbol{X} \) of stochastic variables \( \boldsymbol{X}= \{x_0,x_1, \dots , x_{n-1}\} \) with a pertinent probability distribution</p>
<p>&nbsp;<br>
$$
p(\boldsymbol{X})=\prod_{x_i\in \boldsymbol{X}}p(x_i),
$$
<p>&nbsp;<br>

<p>where we have assumed that the random varaibles \( x_i \) are all independent and identically distributed (iid).</p>

<p>We will now assume that we can defined this function in terms of optimization parameters \( \boldsymbol{\Theta} \), which could be the biases and weights of deep network, and a set of hidden variables we also assume to be random variables which also are iid. The domain of these variables is
\( \boldsymbol{H}= \{h_0,h_1, \dots , h_{m-1}\} \).
</p>
</section>

<section>
<h2 id="probability-model">Probability model </h2>

<p>We define a probability</p>
<p>&nbsp;<br>
$$
p(x_i,h_j;\boldsymbol{\Theta}) = \frac{f(x_i,h_j;\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})},
$$
<p>&nbsp;<br>

<p>where \( f(x_i,h_j;\boldsymbol{\Theta}) \) is a function which we assume is larger or
equal than zero and obeys all properties required for a probability
distribution and \( Z(\boldsymbol{\Theta}) \) is a normalization constant. Inspired by
statistical mechanics, we call it often for the partition function.
It is defined as (assuming that we have discrete probability distributions)
</p>
<p>&nbsp;<br>
$$
Z(\boldsymbol{\Theta})=\sum_{x_i\in \boldsymbol{X}}\sum_{h_j\in \boldsymbol{H}} f(x_i,h_j;\boldsymbol{\Theta}).
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="marginal-and-conditional-probabilities">Marginal and conditional probabilities </h2>

<p>We can in turn define the marginal probabilities</p>
<p>&nbsp;<br>
$$
p(x_i;\boldsymbol{\Theta}) = \frac{\sum_{h_j\in \boldsymbol{H}}f(x_i,h_j;\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})},
$$
<p>&nbsp;<br>

<p>and </p>
<p>&nbsp;<br>
$$
p(h_i;\boldsymbol{\Theta}) = \frac{\sum_{x_i\in \boldsymbol{X}}f(x_i,h_j;\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})}.
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="change-of-notation">Change of notation </h2>

<p><b>Note the change to a vector notation</b>. A variable like \( \boldsymbol{x} \)
represents now a specific <b>configuration</b>. We can generate an infinity
of such configurations. The final partition function is then the sum
over all such possible configurations, that is
</p>

<p>&nbsp;<br>
$$
Z(\boldsymbol{\Theta})=\sum_{x_i\in \boldsymbol{X}}\sum_{h_j\in \boldsymbol{H}} f(x_i,h_j;\boldsymbol{\Theta}),
$$
<p>&nbsp;<br>

<p>changes to</p>
<p>&nbsp;<br>
$$
Z(\boldsymbol{\Theta})=\sum_{\boldsymbol{x}}\sum_{\boldsymbol{h}} f(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}).
$$
<p>&nbsp;<br>

<p>If we have a binary set of variable \( x_i \) and \( h_j \) and \( M \) values of \( x_i \) and \( N \) values of \( h_j \) we have in total \( 2^M \) and \( 2^N \) possible \( \boldsymbol{x} \) and \( \boldsymbol{h} \) configurations, respectively.</p>

<p>We see that even for the modest binary case, we can easily approach a
number of configuration which is not possible to deal with.
</p>
</section>

<section>
<h2 id="optimization-problem">Optimization problem </h2>

<p>At the end, we are not interested in the probabilities of the hidden variables. The probability we thus want to optimize is </p>
<p>&nbsp;<br>
$$
p(\boldsymbol{X};\boldsymbol{\Theta})=\prod_{x_i\in \boldsymbol{X}}p(x_i;\boldsymbol{\Theta})=\prod_{x_i\in \boldsymbol{X}}\left(\frac{\sum_{h_j\in \boldsymbol{H}}f(x_i,h_j;\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})}\right),
$$
<p>&nbsp;<br>

<p>which we rewrite as</p>
<p>&nbsp;<br>
$$
p(\boldsymbol{X};\boldsymbol{\Theta})=\frac{1}{Z(\boldsymbol{\Theta})}\prod_{x_i\in \boldsymbol{X}}\left(\sum_{h_j\in \boldsymbol{H}}f(x_i,h_j;\boldsymbol{\Theta})\right).
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="further-simplifications">Further simplifications </h2>

<p>We simplify further by rewriting it as</p>
<p>&nbsp;<br>
$$
p(\boldsymbol{X};\boldsymbol{\Theta})=\frac{1}{Z(\boldsymbol{\Theta})}\prod_{x_i\in \boldsymbol{X}}f(x_i;\boldsymbol{\Theta}),
$$
<p>&nbsp;<br>

<p>where we used \( p(x_i;\boldsymbol{\Theta}) = \sum_{h_j\in \boldsymbol{H}}f(x_i,h_j;\boldsymbol{\Theta}) \).
The optimization problem is then
</p>
<p>&nbsp;<br>
$$
{\displaystyle \mathrm{arg} \hspace{0.1cm}\max_{\boldsymbol{\boldsymbol{\Theta}}\in {\mathbb{R}}^{p}}} \hspace{0.1cm}p(\boldsymbol{X};\boldsymbol{\Theta}).
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="optimizing-the-logarithm-instead">Optimizing the logarithm instead </h2>

<p>Computing the derivatives with respect to the parameters \( \boldsymbol{\Theta} \) is
easier (and equivalent) with taking the logarithm of the
probability. We will thus optimize
</p>
<p>&nbsp;<br>
$$
{\displaystyle \mathrm{arg} \hspace{0.1cm}\max_{\boldsymbol{\boldsymbol{\Theta}}\in {\mathbb{R}}^{p}}} \hspace{0.1cm}\log{p(\boldsymbol{X};\boldsymbol{\Theta})},
$$
<p>&nbsp;<br>

<p>which leads to</p>
<p>&nbsp;<br>
$$
\nabla_{\boldsymbol{\Theta}}\log{p(\boldsymbol{X};\boldsymbol{\Theta})}=0.
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="expression-for-the-gradients">Expression for the gradients </h2>
<p>This leads to the following equation</p>
<p>&nbsp;<br>
$$
\nabla_{\boldsymbol{\Theta}}\log{p(\boldsymbol{X};\boldsymbol{\Theta})}=\nabla_{\boldsymbol{\Theta}}\left(\sum_{x_i\in \boldsymbol{X}}\log{f(x_i;\boldsymbol{\Theta})}\right)-\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=0.
$$
<p>&nbsp;<br>

<p>The first term is called the positive phase and we assume that we have a model for the function \( f \) from which we can sample values. Below we will develop an explicit model for this.
The second term is called the negative phase and is the one which leads to more difficulties.
</p>
</section>

<section>
<h2 id="the-derivative-of-the-partition-function">The derivative of the partition function </h2>

<p>The partition function, defined above as</p>
<p>&nbsp;<br>
$$
Z(\boldsymbol{\Theta})=\sum_{x_i\in \boldsymbol{X}}\sum_{h_j\in \boldsymbol{H}} f(x_i,h_j;\boldsymbol{\Theta}),
$$
<p>&nbsp;<br>

<p>is in general the most problematic term. In principle both \( x \) and \( h \) can span large degrees of freedom, if not even infinitely many ones, and computing the partition function itself is often not desirable or even feasible. The above derivative of the partition function can however be written in terms of an expectation value which is in turn evaluated  using Monte Carlo sampling and the theory of Markov chains, popularly shortened to MCMC (or just MC$^2$).</p>
</section>

<section>
<h2 id="explicit-expression-for-the-derivative">Explicit expression for the derivative </h2>
<p>We can rewrite</p>
<p>&nbsp;<br>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\frac{\nabla_{\boldsymbol{\Theta}}Z(\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})},
$$
<p>&nbsp;<br>

<p>which reads in more detail</p>
<p>&nbsp;<br>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\frac{\nabla_{\boldsymbol{\Theta}} \sum_{x_i\in \boldsymbol{X}}f(x_i;\boldsymbol{\Theta})   }{Z(\boldsymbol{\Theta})}.
$$
<p>&nbsp;<br>

<p>We can rewrite the function \( f \) (we have assumed that is larger or
equal than zero) as \( f=\exp{\log{f}} \). We can then reqrite the last
equation as
</p>

<p>&nbsp;<br>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\frac{ \sum_{x_i\in \boldsymbol{X}} \nabla_{\boldsymbol{\Theta}}\exp{\log{f(x_i;\boldsymbol{\Theta})}}   }{Z(\boldsymbol{\Theta})}.
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="final-expression">Final expression </h2>

<p>Taking the derivative gives us</p>
<p>&nbsp;<br>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\frac{ \sum_{x_i\in \boldsymbol{X}}f(x_i;\boldsymbol{\Theta}) \nabla_{\boldsymbol{\Theta}}\log{f(x_i;\boldsymbol{\Theta})}   }{Z(\boldsymbol{\Theta})}, 
$$
<p>&nbsp;<br>

<p>which is the expectation value of \( \log{f} \)</p>
<p>&nbsp;<br>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\sum_{x_i\in \boldsymbol{X}}p(x_i;\boldsymbol{\Theta}) \nabla_{\boldsymbol{\Theta}}\log{f(x_i;\boldsymbol{\Theta})},
$$
<p>&nbsp;<br>

<p>that is</p>
<p>&nbsp;<br>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\mathbb{E}(\log{f(x_i;\boldsymbol{\Theta})}).
$$
<p>&nbsp;<br>

<p>This quantity is evaluated using Monte Carlo sampling, with Gibbs
sampling as the standard sampling rule.  Before we discuss the
explicit algorithms, we need to remind ourselves about Markov chains
and sampling rules like the Metropolis-Hastings algorithm and Gibbs
sampling.
</p>
</section>

<section>
<h2 id="introducing-the-energy-model">Introducing the energy model </h2>

<p>As we will see below, a typical Boltzmann machines employs a probability distribution</p>
<p>&nbsp;<br>
$$
p(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}) = \frac{f(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})},
$$
<p>&nbsp;<br>

<p>where \( f(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}) \) is given by a so-called energy model. If we assume that the random variables \( x_i \) and \( h_j \) take binary values only, for example \( x_i,h_j=\{0,1\} \), we have a so-called binary-binary model where</p>
<p>&nbsp;<br>
$$
f(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta})=-E(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta}) = \sum_{x_i\in \boldsymbol{X}} x_i a_i+\sum_{h_j\in \boldsymbol{H}} b_j h_j + \sum_{x_i\in \boldsymbol{X},h_j\in\boldsymbol{H}} x_i w_{ij} h_j,
$$
<p>&nbsp;<br>

<p>where the set of parameters are given by the biases and weights \( \boldsymbol{\Theta}=\{\boldsymbol{a},\boldsymbol{b},\boldsymbol{W}\} \).
<b>Note the vector notation</b> instead of \( x_i \) and \( h_j \) for \( f \). The vectors \( \boldsymbol{x} \) and \( \boldsymbol{h} \) represent a specific instance of stochastic variables \( x_i \) and \( h_j \). These arrangements of \( \boldsymbol{x} \) and \( \boldsymbol{h} \) lead to a specific energy configuration.
</p>
</section>

<section>
<h2 id="more-compact-notation">More compact notation </h2>

<p>With the above definition we can write the probability as</p>
<p>&nbsp;<br>
$$
p(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}) = \frac{\exp{(\boldsymbol{a}^T\boldsymbol{x}+\boldsymbol{b}^T\boldsymbol{h}+\boldsymbol{x}^T\boldsymbol{W}\boldsymbol{h})}}{Z(\boldsymbol{\Theta})},
$$
<p>&nbsp;<br>

<p>where the biases \( \boldsymbol{a} \) and \( \boldsymbol{h} \) and the weights defined by the matrix \( \boldsymbol{W} \) are the parameters we need to optimize.</p>
</section>

<section>
<h2 id="anticipating-results-to-be-derived">Anticipating results to be derived </h2>

<p>Since the binary-binary energy model is linear in the parameters \( a_i \), \( b_j \) and
\( w_{ij} \), it is easy to see that the derivatives with respect to the
various optimization parameters yield expressions used in the
evaluation of gradients like
</p>
<p>&nbsp;<br>
$$
\frac{\partial E(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta})}{\partial w_{ij}}=-x_ih_j,
$$
<p>&nbsp;<br>

<p>and</p>
<p>&nbsp;<br>
$$
\frac{\partial E(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta})}{\partial a_i}=-x_i,
$$
<p>&nbsp;<br>

<p>and</p>
<p>&nbsp;<br>
$$
\frac{\partial E(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta})}{\partial b_j}=-h_j.
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="reminder-on-markov-chain-monte-carlo">Reminder on Markov Chain Monte Carlo </h2>

<ul>
<p><li> We want to study a physical system which evolves towards equilibrium, from given  initial conditions.</li>
<p><li> We start with a PDF \( w(x_0,t_0) \)  and we want to understand how the system evolves with time.</li>
<p><li> We want to reach a situation where after a given number of time steps we obtain a steady state. This means that the system reaches its most likely state (equilibrium situation)</li>
<p><li> Our PDF is normally a multidimensional object whose normalization constant is impossible to find.</li>
<p><li> Analytical calculations from \( w(x,t) \) are not possible.</li>
<p><li> To sample directly from from \( w(x,t) \) is not possible/difficult.</li>
<p><li> The transition probability \( W \) is also not  known.</li>
<p><li> How can we establish that we have reached a steady state?   Sounds impossible!</li>
</ul>
<p>
<b>Use Markov chain Monte Carlo</b>
</section>

<section>
<h2 id="brownian-motion-and-markov-processes">Brownian motion and Markov processes </h2>
<p>A Markov process is a random walk with a selected probability for making a
move. The new move is independent of the previous history of the system.
</p>

<p>The Markov process is used repeatedly in Monte Carlo simulations in order to generate
new random states.
</p>

<p>The reason for choosing a Markov process is that when it is run for a
long enough time starting with a random state, we will eventually reach the most likely state of the system.
</p>

<p>In thermodynamics, this means that after a certain number of Markov processes
we reach an equilibrium distribution.
</p>

<p>This mimicks the way a real system reaches
its most likely state at a given temperature of the surroundings.
</p>
</section>

<section>
<h2 id="brownian-motion-and-markov-processes-ergodicity-and-detailed-balance">Brownian motion and Markov processes, Ergodicity and Detailed balance </h2>

<p>To reach this distribution, the Markov process needs to obey two important conditions, that of
<b>ergodicity</b> and <b>detailed balance</b>. These conditions impose then constraints on our algorithms
for accepting or rejecting new random states.
</p>

<p>The Metropolis algorithm discussed here
abides to both these constraints.
</p>

<p>The Metropolis algorithm is widely used in Monte Carlo
simulations and the understanding of it rests within
the interpretation of random walks and Markov processes.
</p>

<p>For a proof the ergodic theorem see <a href="https://www.pnas.org/doi/10.1073/pnas.17.2.656" target="_blank"><tt>https://www.pnas.org/doi/10.1073/pnas.17.2.656</tt></a>.</p>
</section>

<section>
<h2 id="brownian-motion-and-markov-processes-jargon">Brownian motion and Markov processes, jargon </h2>

<p>In a random walk one defines a mathematical entity called a <b>walker</b>, 
whose  attributes
completely define the state of the system in question. 
</p>

<p>The state of the system  can refer to any physical quantities,
from the vibrational state of a molecule specified by a set of quantum numbers, 
to the brands of coffee in your favourite supermarket.
</p>

<p>The walker moves in an appropriate state space by a combination of 
deterministic and random displacements from its previous
position.
</p>

<p>This sequence of steps forms a <b>chain</b>.</p>
</section>

<section>
<h2 id="brownian-motion-and-markov-processes-sequence-of-ingredients">Brownian motion and Markov processes, sequence of ingredients </h2>

<ul>
<p><li> We want to study a physical system which evolves towards equilibrium, from given  initial conditions.</li>
<p><li> Markov chains are intimately linked with the physical process of diffusion.</li> 
<p><li> From a Markov chain we can then derive the conditions for detailed balance and ergodicity. These are the conditions needed for obtaining a steady state.</li>
<p><li> The widely used algorithm for doing this is the so-called Metropolis algorithm, in its refined form the Metropolis-Hastings algorithm.</li>
</ul>
</section>

<section>
<h2 id="markov-processes">Markov processes </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>A Markov process allows in principle for a microscopic description of Brownian motion.
As with the random walk studied in the previous section, we consider a particle 
which moves along the  \( x \)-axis in the form of a series of jumps with step length 
\( \Delta x = l \). Time and space are discretized and the subsequent moves are
statistically independent, i.e., the new move depends only on the previous step
and not on the results from earlier trials. 
We start at a position \( x=jl=j\Delta x \) and move to 
a new position \( x =i\Delta x \) during a step \( \Delta t=\epsilon \), where 
\( i\ge  0 \) and \( j\ge 0 \) are integers. 
The original probability distribution function (PDF) of the particles is given by  
\( p_i(t=0) \) where \( i \) refers to a specific position on the grid in 
</p>
</div>

<p>The function \( p_i(t=0) \) is now the discretized version of \( p(x,t) \).
We can regard the discretized PDF as a vector.
</p>
</section>

<section>
<h2 id="markov-processes">Markov processes </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>For the Markov process we have a transition probability from a position
\( x=jl \) to a position \( x=il \) given by
</p>
<p>&nbsp;<br>
$$
\begin{equation*}
   W_{ij}(\epsilon)=W(il-jl,\epsilon)=\left\{\begin{array}{cc}\frac{1}{2} & |i-j| = 1\\
             0 & \mathrm{else} \end{array} \right. ,
\end{equation*}
$$
<p>&nbsp;<br>

<p>where \( W_{ij} \) is normally called 
the transition probability and we can represent it, see below,
as a matrix. 
<b>Here we have specialized to a case where the transition probability is known</b>.
</p>

<p>Our new PDF \( p_i(t=\epsilon) \) is now related to the PDF at
\( t=0 \) through the relation
</p>

<p>&nbsp;<br>
$$
\begin{equation*} 
   p_i(t=\epsilon) =\sum_{j} W(j\rightarrow i)p_j(t=0).
\end{equation*}
$$
<p>&nbsp;<br>

<p>This equation represents the discretized time-development of an original 
PDF with equal probability of jumping left or right.
</p>
</div>
</section>

<section>
<h2 id="markov-processes-the-probabilities">Markov processes, the probabilities </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>Since both \( \boldsymbol{W} \) and \( \boldsymbol{p} \) represent probabilities, they have to be normalized, i.e., we require
that at each time step we have
</p>

<p>&nbsp;<br>
$$
\begin{equation*} 
   \sum_i p_i(t) = 1, 
\end{equation*}
$$
<p>&nbsp;<br>

<p>and</p>

<p>&nbsp;<br>
$$
\begin{equation*} 
   \sum_j W(j\rightarrow i) = 1,
\end{equation*}
$$
<p>&nbsp;<br>

<p>which applies for all \( j \)-values.
The further constraints are
\( 0 \le W_{ij} \le 1 \)  and  \( 0 \le p_{j} \le 1 \).
Note that the probability for remaining at the same place is in general 
not necessarily equal zero. 
</p>
</div>
</section>

<section>
<h2 id="markov-processes">Markov processes </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The time development of our initial PDF can now be represented through the action of
the transition probability matrix applied \( n \) times. At a 
time  \( t_n=n\epsilon \) our initial distribution has developed into
</p>

<p>&nbsp;<br>
$$
\begin{equation*}
   p_i(t_n) = \sum_jW_{ij}(t_n)p_j(0),
\end{equation*}
$$
<p>&nbsp;<br>

<p>and defining</p>

<p>&nbsp;<br>
$$
\begin{equation*}
   W(il-jl,n\epsilon)=(W^n(\epsilon))_{ij}
\end{equation*}
$$
<p>&nbsp;<br>

<p>we obtain</p>

<p>&nbsp;<br>
$$
\begin{equation*}
   p_i(n\epsilon) = \sum_j(W^n(\epsilon))_{ij}p_j(0),
\end{equation*}
$$
<p>&nbsp;<br>

<p>or in matrix-vector form</p>
<p>&nbsp;<br>
$$
\begin{equation} \tag{1}
   \boldsymbol{p}(n\epsilon) = \boldsymbol{W}^n(\epsilon)\boldsymbol{p}(0).
\end{equation}
$$
<p>&nbsp;<br>
</div>
</section>

<section>
<h2 id="what-do-the-results-mean">What do the results mean? </h2>

<p>We have after \( t \)-steps</p>

<p>&nbsp;<br>
$$
\begin{equation*}
   \boldsymbol{p}(t) = \boldsymbol{W}^t\boldsymbol{p}(0),
\end{equation*}
$$
<p>&nbsp;<br>

<p>with \( \boldsymbol{p}(0) \) the distribution at \( t=0 \) and \( \boldsymbol{W} \) representing the 
transition probability matrix. 
</p>
</section>

<section>
<h2 id="understanding-the-basics">Understanding the basics </h2>

<p>We can always expand \( \boldsymbol{w}(0) \) in terms of the right eigenvectors 
\( \boldsymbol{v} \) of \( \boldsymbol{W} \) as
</p>

<p>&nbsp;<br>
$$
\begin{equation*}
    \boldsymbol{p}(0)  = \sum_i\alpha_i\boldsymbol{v}_i,
\end{equation*}
$$
<p>&nbsp;<br>

<p>resulting in</p>

<p>&nbsp;<br>
$$
\begin{equation*}
\boldsymbol{p}(t) = \boldsymbol{W}^t\boldsymbol{p}(0)=\boldsymbol{W}^t\sum_i\alpha_i\boldsymbol{v}_i=
\sum_i\lambda_i^t\alpha_i\boldsymbol{v}_i,
\end{equation*}
$$
<p>&nbsp;<br>

<p>with \( \lambda_i \) the \( i^{\mathrm{th}} \) eigenvalue corresponding to  
the eigenvector \( \boldsymbol{v}_i \). 
</p>

<p>If we assume that \( \lambda_0 \) is the largest eigenvector we see that in the limit \( t\rightarrow \infty \),
\( \boldsymbol{p}(t) \) becomes proportional to the corresponding eigenvector 
\( \boldsymbol{v}_0 \). This is our steady state or final distribution. 
</p>
</section>

<section>
<h2 id="basics-of-the-metropolis-algorithm">Basics of the Metropolis Algorithm </h2>

<p>The Metropolis
algorithm is a method to sample a normalized probability
distribution by a stochastic process. We define \( p_i^{(n)} \) to
be the probability for finding the system in the state \( i \) at step \( n \).
</p>

<p>In the simulations, our assumption is that we have a model for \( p_i^{(n)} \), but we do not know \( W \).
We will hence model \( W \) in terms of a likelihood for making transition \( T \) and a likelihood for accepting a transition.
That is
</p>
<p>&nbsp;<br>
$$
W_{i\rightarrow j}=A_{i\rightarrow j}T_{i\rightarrow j}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="the-basic-of-the-metropolis-algorithm">The basic of the Metropolis Algorithm </h2>

<ul>
<p><li> Sample a possible new state \( j \) with some probability \( T_{i\rightarrow j} \).</li>
<p><li> Accept the new state \( j \) with probability \( A_{i \rightarrow j} \) and use it as the next sample.</li>
<p><li> With probability \( 1-A_{i\rightarrow j} \) the move is rejected and the original state \( i \) is used again as a sample.</li>
</ul>
<p>
<p>We wish to derive the required properties of \( T \) and \( A \) such that
\( p_i^{(n\rightarrow \infty)} \rightarrow p_i \) so that starting
from any distribution, the method converges to the correct distribution.
Note that the description here is for a discrete probability distribution.
Replacing probabilities \( p_i \) with expressions like \( p(x_i)dx_i \) will
take all of these over to the corresponding continuum expressions.
</p>
</section>

<section>
<h2 id="more-on-the-metropolis">More on the Metropolis </h2>

<p>The dynamical equation for \( p_i^{(n)} \) can be written directly from
the description above. The probability of being in the state \( i \) at step \( n \)
is given by the probability of being in any state \( j \) at the previous step,
and making an accepted transition to \( i \) added to the probability of
being in the state \( i \), making a transition to any state \( j \) and
rejecting the move:
</p>
<p>&nbsp;<br>
$$
\begin{equation}
\tag{2}
p^{(n)}_i = \sum_j \left [
p^{(n-1)}_jT_{j\rightarrow i} A_{j\rightarrow i} 
+p^{(n-1)}_iT_{i\rightarrow j}\left ( 1- A_{i\rightarrow j} \right)
\right ] \,.
\end{equation}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="metropolis-algorithm-setting-it-up">Metropolis algorithm, setting it up </h2>
<p>Since the probability of making some transition must be 1,
\( \sum_j T_{i\rightarrow j} = 1 \), and Eq. <a href="#mjx-eqn-2">(2)</a> becomes
</p>

<p>&nbsp;<br>
$$
\begin{equation}
p^{(n)}_i = p^{(n-1)}_i +
 \sum_j \left [
p^{(n-1)}_jT_{j\rightarrow i} A_{j\rightarrow i} 
-p^{(n-1)}_iT_{i\rightarrow j}A_{i\rightarrow j}
\right ] \,.
\tag{3}
\end{equation}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="metropolis-continues">Metropolis continues </h2>

<p>For large \( n \) we require that \( p^{(n\rightarrow \infty)}_i = p_i \),
the desired probability distribution. Taking this limit, gives the
balance requirement
</p>

<p>&nbsp;<br>
$$
\begin{equation}
\sum_j \left [p_jT_{j\rightarrow i} A_{j\rightarrow i}-p_iT_{i\rightarrow j}A_{i\rightarrow j}
\right ] = 0,
\tag{4}
\end{equation}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="detailed-balance">Detailed Balance </h2>

<p>The balance requirement is very weak. Typically the much stronger detailed
balance requirement is enforced, that is rather than the sum being
set to zero, we set each term separately to zero and use this
to determine the acceptance probabilities. Rearranging, the result is
</p>

<p>&nbsp;<br>
$$
\begin{equation}
\frac{ A_{j\rightarrow i}}{A_{i\rightarrow j}}
= \frac{p_iT_{i\rightarrow j}}{ p_jT_{j\rightarrow i}} \,.
\tag{5}
\end{equation}
$$
<p>&nbsp;<br>

<p>This is the <a href="https://cims.nyu.edu/~holmes/teaching/asa19/handout_Lecture3_2019.pdf" target="_blank">detailed balance requirement</a></p>
</section>

<section>
<h2 id="more-on-detailed-balance">More on Detailed Balance </h2>

<p>The Metropolis choice is to maximize the \( A \) values, that is</p>

<p>&nbsp;<br>
$$
\begin{equation}
A_{j \rightarrow i} = \min \left ( 1,
\frac{p_iT_{i\rightarrow j}}{ p_jT_{j\rightarrow i}}\right ).
\tag{6}
\end{equation}
$$
<p>&nbsp;<br>

<p>Other choices are possible, but they all correspond to multiplying
\( A_{i\rightarrow j} \) and \( A_{j\rightarrow i} \) by the same constant
smaller than unity. The penalty function method uses just such
a factor to compensate for \( p_i \) that are evaluated stochastically
and are therefore noisy.
</p>

<p>Having chosen the acceptance probabilities, we have guaranteed that
if the  \( p_i^{(n)} \) has equilibrated, that is if it is equal to \( p_i \),
it will remain equilibrated.
</p>
</section>

<section>
<h2 id="gibbs-sampling">Gibbs sampling </h2>

<p>An efficient way if performing the sampling is through the use of
Gibbs sampling. The latter uses the conditional probability instead of
the full probability as done in the Metropolis algorithm.
</p>

<p>Gibbs sampling is useful for sampling from high-dimensional
distributions where single-variable conditional distributions are
known.
</p>

<p>For example, say it is too expensive to sample from \( p(x_0, x_1, x_2,
..., x_d) \). With Gibbs sampling, we initialize all variables to
arbitrary values. Then while taking each sample, we also iterate
through the dimensions and replace its value with a sample from the
univariate conditional distribution. For example we can update \( x_1 \)
using \( p(x_1 \mid x_0, x_2, ..., x_d) \), which is easy to sample over
because it is  only one dimension.
</p>
</section>

<section>
<h2 id="understanding-gibbs-samoling">Understanding Gibbs samoling </h2>

<p>This part is best seen with the jupyter-notebook.
These notes have been adapted from <a href="https://www.inf.ed.ac.uk/teaching/courses/mlpr/2017/" target="_blank"><tt>https://www.inf.ed.ac.uk/teaching/courses/mlpr/2017/</tt></a>
</p>

<p>To illustrate Gibbs
sampling we will sample several points and compare them with those
generated from a known distribution, in our case the well-known
two-dimensional Gaussian defined as
</p>

<p>&nbsp;<br>
$$
p(a, b) = \mathcal N\left(\left[\begin{array}{c} a \\ b \end{array}\right]; \left[\begin{array}{c}\mu_a \\ \mu_b\end{array}\right], \left[\begin{array}{cc}\sigma_a & cov(a, b) \\ cov(a, b) & \sigma_b\end{array}\right]\right) = \mathcal N\left(\left[\begin{array}{c}a \\ b\end{array}\right]; \left[\begin{array}{c}0 \\ 0\end{array}\right], \left[\begin{array}{cc}1 & 0.5 \\ 0.5 & 1\end{array}\right]\right).
$$
<p>&nbsp;<br>



<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #228B22"># two dimensions</span>
D = <span style="color: #B452CD">2</span>

<span style="color: #228B22"># set up the means (standard normal distribution</span>
a_mu = <span style="color: #B452CD">0</span>
b_mu = <span style="color: #B452CD">0</span>
<span style="color: #228B22"># and the variances and covariances</span>
a_sigma = <span style="color: #B452CD">1</span>
b_sigma = <span style="color: #B452CD">1</span>
a_b_cov = <span style="color: #B452CD">0.5</span>

joint_cov = np.vstack(((a_sigma, a_b_cov), (a_b_cov, b_sigma)))
joint_mu = np.vstack((a_mu, b_mu))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Here we have used \( \epsilon \sim \mathcal N(0, 1) \) which allows us to sample from \( \mathcal{N}(\mu, \sigma^2) \) by using \( \sigma\epsilon + \mu \).
In the case of multivariate Gaussians, we use the Cholesky decomposition of the covariance matrix
and then use it and the mean to adjust numbers generated using <code>np.random.randn</code>.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">N = <span style="color: #B452CD">10000</span>
L = np.linalg.cholesky(joint_cov)
samples_from_true_distribution =  L @ np.random.randn(D, N) + joint_mu
plt.plot(*samples_from_true_distribution, <span style="color: #CD5555">&#39;.&#39;</span>, alpha=<span style="color: #B452CD">0.1</span>)
plt.axis([-<span style="color: #B452CD">4</span>, <span style="color: #B452CD">4</span>, -<span style="color: #B452CD">4</span>, <span style="color: #B452CD">4</span>])
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="conditional-probabilities">Conditional probabilities </h2>

<p>Gibbs sampling requires conditional distributions for each variable. </p>

<p>In the case of Gaussians, there is  a closed-form for the conditional. With a <a href="http://www.inf.ed.ac.uk/teaching/courses/mlpr/2017/notes/w7c_gaussian_processes.html" target="_blank">multivariate Gaussian</a> we have</p>
<p>&nbsp;<br>
$$
p(\textbf{f}, \textbf{g}) = 
\mathcal N\left(
\left[\begin{array}{c} \textbf{f} \\ \textbf{g} \end{array}\right];
\left[\begin{array}{c}\textbf{a} \\ \textbf{b}\end{array}\right], 
\left[\begin{array}{cc}A & C^{\top} \\ C & B\end{array}\right]
\right),
$$
<p>&nbsp;<br>

<p>with the conditional probability</p>
<p>&nbsp;<br>
$$
p(\textbf{f} \mid \textbf{g}) = \mathcal N(\textbf{f}; \textbf{a} + CB^{-1}(\textbf{g} - \textbf{b}), A - CB^{-1}C^{\top}).
$$
<p>&nbsp;<br>



<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">get_conditional_dist</span>(joint_mu, joint_cov, var_index):
    <span style="color: #CD5555">&#39;&#39;&#39;Returns the conditional distribution given the joint distribution and which variable</span>
<span style="color: #CD5555">    the conditional probability should use.</span>
<span style="color: #CD5555">    Right now this only works for 2-variable joint distributions.</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">      joint_mu: joint distribution&#39;s mu</span>
<span style="color: #CD5555">      joint_cov: joint distribution&#39;s covariance</span>
<span style="color: #CD5555">      var_index: index of the variable in the joint distribution. Everything else will be </span>
<span style="color: #CD5555">        conditioned on. For example, if the joint distribution p(a, b, c) has mu [mu_a, mu_b, mu_c],</span>
<span style="color: #CD5555">        to get p(c | a, b), use var_index = 2.</span>
<span style="color: #CD5555">      </span>
<span style="color: #CD5555">    returns:</span>
<span style="color: #CD5555">      a function that can sample from the univariate conditional distribution</span>
<span style="color: #CD5555">    &#39;&#39;&#39;</span>
    <span style="color: #8B008B; font-weight: bold">assert</span> joint_mu.shape[<span style="color: #B452CD">0</span>] == <span style="color: #B452CD">2</span>, <span style="color: #CD5555">&#39;Sorry, this function only works for 2-dimensional joint distributions right now&#39;</span>
    a = joint_mu[var_index]
    b = joint_mu[~var_index]
    
    A = joint_cov[var_index, var_index]
    B = joint_cov[~var_index, ~var_index]
    C = joint_cov[var_index, ~var_index]
    
    <span style="color: #228B22"># we&#39;re dealing with one dimension so</span>
    B_inv = <span style="color: #B452CD">1</span>/B
    
    <span style="color: #228B22"># Return a function that can sample given a value of g</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">dist</span>(g):
        <span style="color: #228B22"># a + C*B^{-1}(g - b)</span>
        mu = a + C * B_inv * (g - b)
        <span style="color: #228B22"># A - C * B^{-1} * C^T</span>
        cov = A - B_inv * C * C
        <span style="color: #8B008B; font-weight: bold">return</span> np.sqrt(cov) * np.random.randn(<span style="color: #B452CD">1</span>) + mu
    
    <span style="color: #8B008B; font-weight: bold">return</span> dist
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>With this we can set up the conditionals for this problem</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># Set up the conditional probability distribution for each dimension</span>
<span style="color: #228B22"># For example, I can sample p(a | b) using sample_for_dim[0].</span>

univariate_conditionals = [
    get_conditional_dist(joint_mu, joint_cov, d)
    <span style="color: #8B008B; font-weight: bold">for</span> d <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(D)
]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The \( gibbs\_sample \) function here only needs the univariate conditionals and how many samples to take.</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">gibbs_sample</span>(univariate_conditionals, sample_count):
    <span style="color: #CD5555">&#39;&#39;&#39;Does Gibbs sampling given the distribution&#39;s univariate conditionals.</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    Returns a D x N matrix</span>
<span style="color: #CD5555">    &#39;&#39;&#39;</span>
    D = <span style="color: #658b00">len</span>(univariate_conditionals)
    <span style="color: #8B008B; font-weight: bold">assert</span> D == <span style="color: #B452CD">2</span>, <span style="color: #CD5555">&quot;Sorry, this only supports 2 dimensions right now&quot;</span>
    
    <span style="color: #228B22"># initializes an empty matrix for the samples</span>
    samples = np.zeros((D, sample_count))

    <span style="color: #228B22"># initialize the first sample to some arbitrary value</span>
    samples[:, <span style="color: #B452CD">0</span>] = [<span style="color: #B452CD">3</span>, -<span style="color: #B452CD">3</span>]
    
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, sample_count):
        <span style="color: #228B22"># first set this sample equal to the previous sample</span>
        samples[:, i] = samples[:, i - <span style="color: #B452CD">1</span>]
        
        <span style="color: #228B22"># now update the dimension whose turn it is using the conditional distribution</span>
        <span style="color: #228B22"># pass in all dimension from the previous sample except this dimension</span>
        d = i % D
        samples[d, i] = univariate_conditionals[d](samples[~d, i - <span style="color: #B452CD">1</span>])
                 
    <span style="color: #8B008B; font-weight: bold">return</span> samples
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>One thing to keep in mind about Gibbs sampling is that it only updates
one dimension at a time. This means that samples from around the same
time are correlated with each other. We have drawn the line connecting
sequential samples to show this.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">samples = gibbs_sample(univariate_conditionals, sample_count=<span style="color: #B452CD">100</span>)
fig, ax = plt.subplots()

ax.plot(*samples_from_true_distribution, <span style="color: #CD5555">&#39;.&#39;</span>, alpha=<span style="color: #B452CD">0.1</span>)
ax.plot(*samples, <span style="color: #CD5555">&#39;k&#39;</span>)
ax.plot(*samples, <span style="color: #CD5555">&#39;.r&#39;</span>)
ax.axis(<span style="color: #CD5555">&#39;square&#39;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Finally we sample a bunch of points and see how they compare to those
from the original distribution. It looks the same! What's cool is that
the one using Gibbs sampling only used samples from the univariate
conditionals!
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">samples = gibbs_sample(univariate_conditionals, sample_count=N)
fig, axs = plt.subplots(<span style="color: #B452CD">1</span>, <span style="color: #B452CD">3</span>, figsize=(<span style="color: #B452CD">12</span>, <span style="color: #B452CD">4</span>), sharex=<span style="color: #8B008B; font-weight: bold">True</span>, sharey=<span style="color: #8B008B; font-weight: bold">True</span>)
<span style="color: #228B22"># set all the axes</span>
axs[<span style="color: #B452CD">0</span>].axis([-<span style="color: #B452CD">4</span>, <span style="color: #B452CD">4</span>, -<span style="color: #B452CD">4</span>, <span style="color: #B452CD">4</span>])
axs[<span style="color: #B452CD">0</span>].plot(*samples_from_true_distribution, <span style="color: #CD5555">&#39;.&#39;</span>, alpha=<span style="color: #B452CD">0.1</span>)
axs[<span style="color: #B452CD">0</span>].set_title(<span style="color: #CD5555">&#39;original p(a, b)&#39;</span>)
axs[<span style="color: #B452CD">1</span>].plot(*samples, <span style="color: #CD5555">&#39;k&#39;</span>, alpha=<span style="color: #B452CD">0.8</span>)
axs[<span style="color: #B452CD">1</span>].set_title(<span style="color: #CD5555">&#39;gibbs sampling path&#39;</span>)
axs[<span style="color: #B452CD">2</span>].plot(*samples, <span style="color: #CD5555">&#39;.g&#39;</span>, alpha=<span style="color: #B452CD">0.1</span>)
axs[<span style="color: #B452CD">2</span>].set_title(<span style="color: #CD5555">&#39;gibbs samples&#39;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>



</div> <!-- class="slides" -->
</div> <!-- class="reveal" -->

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

  // Display navigation controls in the bottom right corner
  controls: true,

  // Display progress bar (below the horiz. slider)
  progress: true,

  // Display the page number of the current slide
  slideNumber: true,

  // Push each slide change to the browser history
  history: false,

  // Enable keyboard shortcuts for navigation
  keyboard: true,

  // Enable the slide overview mode
  overview: true,

  // Vertical centering of slides
  //center: true,
  center: false,

  // Enables touch navigation on devices with touch input
  touch: true,

  // Loop the presentation
  loop: false,

  // Change the presentation direction to be RTL
  rtl: false,

  // Turns fragments on and off globally
  fragments: true,

  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,

  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,

  // Stop auto-sliding after user input
  autoSlideStoppable: true,

  // Enable slide navigation via mouse wheel
  mouseWheel: false,

  // Hides the address bar on mobile devices
  hideAddressBar: true,

  // Opens links in an iframe preview overlay
  previewLinks: false,

  // Transition style
  transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

  // Transition speed
  transitionSpeed: 'default', // default/fast/slow

  // Transition style for full page slide backgrounds
  backgroundTransition: 'default', // default/none/slide/concave/convex/zoom

  // Number of slides away from the current that are visible
  viewDistance: 3,

  // Parallax background image
    //parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

  // Parallax background size
  //parallaxBackgroundSize: '' // CSS syntax, e.g. "2100px 900px"

  theme: Reveal.getQueryHash().theme, // available themes are in reveal.js/css/theme
    transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/none

});

Reveal.initialize({
  dependencies: [
      // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },

      // Interpret Markdown in <section> elements
      { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

      // Syntax highlight for <code> elements
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

      // Zoom in and out with Alt+click
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

      // Speaker notes
      { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

      // Remote control your reveal.js presentation using a touch device
      //{ src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } },

      // MathJax
      //{ src: 'reveal.js/plugin/math/math.js', async: true }
  ]
});

Reveal.initialize({

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 1170,  // original: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.0

});
</script>

<!-- begin footer logo
<div style="position: absolute; bottom: 0px; left: 0; margin-left: 0px">
<img src="somelogo.png">
</div>
   end footer logo -->




</body>
</html>
