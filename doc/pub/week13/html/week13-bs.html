<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html week13.do.txt --html_style=bootstrap --pygments_html_style=default --html_admon=bootstrap_panel --html_output=week13-bs --no_mako
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Advanced machine learning and data analysis for the physical sciences">
<title>Advanced machine learning and data analysis for the physical sciences</title>
<!-- Bootstrap style: bootstrap -->
<!-- doconce format html week13.do.txt --html_style=bootstrap --pygments_html_style=default --html_admon=bootstrap_panel --html_output=week13-bs --no_mako -->
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->
<style type="text/css">
/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:50px;      /* fixed header height for style bootstrap */
  margin:-50px 0 0; /* negative fixed header height */
}
</style>
</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Plans for the week April 15-19, 2024',
               2,
               None,
               'plans-for-the-week-april-15-19-2024'),
              ('Readings', 2, None, 'readings'),
              ('Reminder from last week and layout of lecture this week',
               2,
               None,
               'reminder-from-last-week-and-layout-of-lecture-this-week'),
              ('Code for RBMs using PyTorch',
               2,
               None,
               'code-for-rbms-using-pytorch'),
              ('RBM using TensorFlow and Keras',
               2,
               None,
               'rbm-using-tensorflow-and-keras'),
              ('Energy-based models and Langevin sampling',
               2,
               None,
               'energy-based-models-and-langevin-sampling'),
              ('Langevin sampling', 2, None, 'langevin-sampling'),
              ('Theory of Variational Autoencoders',
               2,
               None,
               'theory-of-variational-autoencoders'),
              ('The Autoencoder again', 2, None, 'the-autoencoder-again'),
              ('Schematic image of an Autoencoder',
               2,
               None,
               'schematic-image-of-an-autoencoder'),
              ('Mathematics of Variational Autoencoders',
               2,
               None,
               'mathematics-of-variational-autoencoders'),
              ('Using the conditional probability',
               2,
               None,
               'using-the-conditional-probability'),
              ('VAEs versus autoencoders', 2, None, 'vaes-versus-autoencoders'),
              ('Gradient descent', 2, None, 'gradient-descent'),
              ('Are VAEs just modified autoencoders?',
               2,
               None,
               'are-vaes-just-modified-autoencoders'),
              ('Training VAEs', 2, None, 'training-vaes'),
              ('Kullback-Leibler relative entropy (notation to be updated)',
               2,
               None,
               'kullback-leibler-relative-entropy-notation-to-be-updated'),
              ('Kullback-Leibler divergence',
               2,
               None,
               'kullback-leibler-divergence'),
              ('Maximizing log-likelihood',
               2,
               None,
               'maximizing-log-likelihood'),
              ('More on the partition function',
               2,
               None,
               'more-on-the-partition-function'),
              ('Setting up for gradient descent calculations',
               2,
               None,
               'setting-up-for-gradient-descent-calculations'),
              ('Difference of moments', 2, None, 'difference-of-moments'),
              ('More observations', 2, None, 'more-observations'),
              ('Adding hyperparameters', 2, None, 'adding-hyperparameters'),
              ('Using the KL divergence', 2, None, 'using-the-kl-divergence'),
              ('Kullback-Leibler again', 2, None, 'kullback-leibler-again'),
              ('And applying Bayes rule', 2, None, 'and-applying-bayes-rule'),
              ('Rearraning', 2, None, 'rearraning'),
              ('Inferring the probability',
               2,
               None,
               'inferring-the-probability'),
              ('Central equation of VAEs', 2, None, 'central-equation-of-vaes'),
              ('Setting up SGD', 2, None, 'setting-up-sgd'),
              ('More on the SGD', 2, None, 'more-on-the-sgd'),
              ('Simplification', 2, None, 'simplification'),
              ('Terms to compute', 2, None, 'terms-to-compute'),
              ('Computing the gradients', 2, None, 'computing-the-gradients'),
              ('Code examples using Keras',
               2,
               None,
               'code-examples-using-keras'),
              ('Code in PyTorch for VAEs', 2, None, 'code-in-pytorch-for-vaes'),
              ('What is a GAN?', 2, None, 'what-is-a-gan'),
              ('What is a generator network?',
               2,
               None,
               'what-is-a-generator-network'),
              ('And what is a discriminator network?',
               2,
               None,
               'and-what-is-a-discriminator-network'),
              ('Appplications of GANs', 2, None, 'appplications-of-gans'),
              ('Generative Adversarial Networks',
               2,
               None,
               'generative-adversarial-networks'),
              ('Discriminator', 2, None, 'discriminator'),
              ('Zero-sum game', 2, None, 'zero-sum-game'),
              ('Maximizing reward', 2, None, 'maximizing-reward'),
              ('Progression in training', 2, None, 'progression-in-training'),
              ('Deafault choice', 2, None, 'deafault-choice'),
              ('Design of GANs', 2, None, 'design-of-gans'),
              ('More references', 2, None, 'more-references'),
              ('Writing Our First Generative Adversarial Network',
               2,
               None,
               'writing-our-first-generative-adversarial-network'),
              ('Exploring the Latent Space',
               2,
               None,
               'exploring-the-latent-space')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="week13-bs.html">Advanced machine learning and data analysis for the physical sciences</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#plans-for-the-week-april-15-19-2024" style="font-size: 80%;">Plans for the week April 15-19, 2024</a></li>
     <!-- navigation toc: --> <li><a href="#readings" style="font-size: 80%;">Readings</a></li>
     <!-- navigation toc: --> <li><a href="#reminder-from-last-week-and-layout-of-lecture-this-week" style="font-size: 80%;">Reminder from last week and layout of lecture this week</a></li>
     <!-- navigation toc: --> <li><a href="#code-for-rbms-using-pytorch" style="font-size: 80%;">Code for RBMs using PyTorch</a></li>
     <!-- navigation toc: --> <li><a href="#rbm-using-tensorflow-and-keras" style="font-size: 80%;">RBM using TensorFlow and Keras</a></li>
     <!-- navigation toc: --> <li><a href="#energy-based-models-and-langevin-sampling" style="font-size: 80%;">Energy-based models and Langevin sampling</a></li>
     <!-- navigation toc: --> <li><a href="#langevin-sampling" style="font-size: 80%;">Langevin sampling</a></li>
     <!-- navigation toc: --> <li><a href="#theory-of-variational-autoencoders" style="font-size: 80%;">Theory of Variational Autoencoders</a></li>
     <!-- navigation toc: --> <li><a href="#the-autoencoder-again" style="font-size: 80%;">The Autoencoder again</a></li>
     <!-- navigation toc: --> <li><a href="#schematic-image-of-an-autoencoder" style="font-size: 80%;">Schematic image of an Autoencoder</a></li>
     <!-- navigation toc: --> <li><a href="#mathematics-of-variational-autoencoders" style="font-size: 80%;">Mathematics of Variational Autoencoders</a></li>
     <!-- navigation toc: --> <li><a href="#using-the-conditional-probability" style="font-size: 80%;">Using the conditional probability</a></li>
     <!-- navigation toc: --> <li><a href="#vaes-versus-autoencoders" style="font-size: 80%;">VAEs versus autoencoders</a></li>
     <!-- navigation toc: --> <li><a href="#gradient-descent" style="font-size: 80%;">Gradient descent</a></li>
     <!-- navigation toc: --> <li><a href="#are-vaes-just-modified-autoencoders" style="font-size: 80%;">Are VAEs just modified autoencoders?</a></li>
     <!-- navigation toc: --> <li><a href="#training-vaes" style="font-size: 80%;">Training VAEs</a></li>
     <!-- navigation toc: --> <li><a href="#kullback-leibler-relative-entropy-notation-to-be-updated" style="font-size: 80%;">Kullback-Leibler relative entropy (notation to be updated)</a></li>
     <!-- navigation toc: --> <li><a href="#kullback-leibler-divergence" style="font-size: 80%;">Kullback-Leibler divergence</a></li>
     <!-- navigation toc: --> <li><a href="#maximizing-log-likelihood" style="font-size: 80%;">Maximizing log-likelihood</a></li>
     <!-- navigation toc: --> <li><a href="#more-on-the-partition-function" style="font-size: 80%;">More on the partition function</a></li>
     <!-- navigation toc: --> <li><a href="#setting-up-for-gradient-descent-calculations" style="font-size: 80%;">Setting up for gradient descent calculations</a></li>
     <!-- navigation toc: --> <li><a href="#difference-of-moments" style="font-size: 80%;">Difference of moments</a></li>
     <!-- navigation toc: --> <li><a href="#more-observations" style="font-size: 80%;">More observations</a></li>
     <!-- navigation toc: --> <li><a href="#adding-hyperparameters" style="font-size: 80%;">Adding hyperparameters</a></li>
     <!-- navigation toc: --> <li><a href="#using-the-kl-divergence" style="font-size: 80%;">Using the KL divergence</a></li>
     <!-- navigation toc: --> <li><a href="#kullback-leibler-again" style="font-size: 80%;">Kullback-Leibler again</a></li>
     <!-- navigation toc: --> <li><a href="#and-applying-bayes-rule" style="font-size: 80%;">And applying Bayes rule</a></li>
     <!-- navigation toc: --> <li><a href="#rearraning" style="font-size: 80%;">Rearraning</a></li>
     <!-- navigation toc: --> <li><a href="#inferring-the-probability" style="font-size: 80%;">Inferring the probability</a></li>
     <!-- navigation toc: --> <li><a href="#central-equation-of-vaes" style="font-size: 80%;">Central equation of VAEs</a></li>
     <!-- navigation toc: --> <li><a href="#setting-up-sgd" style="font-size: 80%;">Setting up SGD</a></li>
     <!-- navigation toc: --> <li><a href="#more-on-the-sgd" style="font-size: 80%;">More on the SGD</a></li>
     <!-- navigation toc: --> <li><a href="#simplification" style="font-size: 80%;">Simplification</a></li>
     <!-- navigation toc: --> <li><a href="#terms-to-compute" style="font-size: 80%;">Terms to compute</a></li>
     <!-- navigation toc: --> <li><a href="#computing-the-gradients" style="font-size: 80%;">Computing the gradients</a></li>
     <!-- navigation toc: --> <li><a href="#code-examples-using-keras" style="font-size: 80%;">Code examples using Keras</a></li>
     <!-- navigation toc: --> <li><a href="#code-in-pytorch-for-vaes" style="font-size: 80%;">Code in PyTorch for VAEs</a></li>
     <!-- navigation toc: --> <li><a href="#what-is-a-gan" style="font-size: 80%;">What is a GAN?</a></li>
     <!-- navigation toc: --> <li><a href="#what-is-a-generator-network" style="font-size: 80%;">What is a generator network?</a></li>
     <!-- navigation toc: --> <li><a href="#and-what-is-a-discriminator-network" style="font-size: 80%;">And what is a discriminator network?</a></li>
     <!-- navigation toc: --> <li><a href="#appplications-of-gans" style="font-size: 80%;">Appplications of GANs</a></li>
     <!-- navigation toc: --> <li><a href="#generative-adversarial-networks" style="font-size: 80%;">Generative Adversarial Networks</a></li>
     <!-- navigation toc: --> <li><a href="#discriminator" style="font-size: 80%;">Discriminator</a></li>
     <!-- navigation toc: --> <li><a href="#zero-sum-game" style="font-size: 80%;">Zero-sum game</a></li>
     <!-- navigation toc: --> <li><a href="#maximizing-reward" style="font-size: 80%;">Maximizing reward</a></li>
     <!-- navigation toc: --> <li><a href="#progression-in-training" style="font-size: 80%;">Progression in training</a></li>
     <!-- navigation toc: --> <li><a href="#deafault-choice" style="font-size: 80%;">Deafault choice</a></li>
     <!-- navigation toc: --> <li><a href="#design-of-gans" style="font-size: 80%;">Design of GANs</a></li>
     <!-- navigation toc: --> <li><a href="#more-references" style="font-size: 80%;">More references</a></li>
     <!-- navigation toc: --> <li><a href="#writing-our-first-generative-adversarial-network" style="font-size: 80%;">Writing Our First Generative Adversarial Network</a></li>
     <!-- navigation toc: --> <li><a href="#exploring-the-latent-space" style="font-size: 80%;">Exploring the Latent Space</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->
<div class="container">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->
<!-- ------------------- main content ---------------------- -->
<div class="jumbotron">
<center>
<h1>Advanced machine learning and data analysis for the physical sciences</h1>
</center>  <!-- document title -->

<!-- author(s): Morten Hjorth-Jensen -->
<center>
<b>Morten Hjorth-Jensen</b> [1, 2]
</center>
<!-- institution(s) -->
<center>
[1] <b>Department of Physics and Center for Computing in Science Education, University of Oslo, Norway</b>
</center>
<center>
[2] <b>Department of Physics and Astronomy and Facility for Rare Isotope Beams, Michigan State University, East Lansing, Michigan, USA</b>
</center>
<br>
<center>
<h4>April 16, 2024</h4>
</center> <!-- date -->
<br>

<!-- potential-jumbotron-button -->
</div> <!-- end jumbotron -->

<!-- !split -->
<h2 id="plans-for-the-week-april-15-19-2024" class="anchor">Plans for the week April 15-19, 2024  </h2>

<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<ol>
<li> Finalizing discussion of Boltzmann machines, implementations using TensorFlow and Pytorch</li>
<li> Discussion of other energy-based models and Langevin sampling</li>
<li> Variational Autoencoders (VAE)</li>
<li> Generative Adversarial Networks (GANs)
<!-- o <a href="https://youtu.be/0VBmdP_iCzA" target="_self">Video of lecture</a> -->
<!-- o <a href="https://github.com/CompPhysics/AdvancedMachineLearning/blob/main/doc/HandwrittenNotes/NotesApr262023.pdf" target="_self">Whiteboard notes</a> --></li>
</ol>
</div>
</div>


<!-- !split -->
<h2 id="readings" class="anchor">Readings </h2>
<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<ol>
<li> Reading recommendation: Goodfellow et al, for VAEs and GANs see sections 20.10-20.11</li>
<li> To create Boltzmann machine using Keras, see Babcock and Bali chapter 4, see <a href="https://github.com/PacktPublishing/Hands-On-Generative-AI-with-Python-and-TensorFlow-2/blob/master/Chapter_4/models/rbm.py" target="_self"><tt>https://github.com/PacktPublishing/Hands-On-Generative-AI-with-Python-and-TensorFlow-2/blob/master/Chapter_4/models/rbm.py</tt></a></li>
<li> See Foster, chapter 7 on energy-based models at <a href="https://github.com/davidADSP/Generative_Deep_Learning_2nd_Edition/tree/main/notebooks/07_ebm/01_ebm" target="_self"><tt>https://github.com/davidADSP/Generative_Deep_Learning_2nd_Edition/tree/main/notebooks/07_ebm/01_ebm</tt></a></li>
</ol>
</div>
</div>


<!-- todo: add about Langevin sampling, see <a href="https://www.lyndonduong.com/sgmcmc/" target="_self"><tt>https://www.lyndonduong.com/sgmcmc/</tt></a> -->
<!-- add material about VAEs -->
<!-- add code on RBMs -->
<!-- code for VAEs applied to MNIST and CIFAR perhaps -->

<!-- !split -->
<h2 id="reminder-from-last-week-and-layout-of-lecture-this-week" class="anchor">Reminder from last week and layout of lecture this week </h2>

<ol>
<li> We will present first a short reminder from last week, see for example the jupyter-notebook at <a href="https://github.com/CompPhysics/AdvancedMachineLearning/blob/main/doc/pub/week12/ipynb/week12.ipynb" target="_self"><tt>https://github.com/CompPhysics/AdvancedMachineLearning/blob/main/doc/pub/week12/ipynb/week12.ipynb</tt></a></li>
<li> We will then discuss codes as well as other energy-based models and Langevin sampling instead of Gibbs or Metropolis sampling.</li>
<li> Thereafter we start our discussions of Variational autoencoders and Generalized adversarial networks</li>
</ol>
<!-- !split -->
<h2 id="code-for-rbms-using-pytorch" class="anchor">Code for RBMs using PyTorch </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torch</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torch.utils.data</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torch.nn</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">nn</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torch.nn.functional</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">F</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torch.optim</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">optim</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">torch.autograd</span> <span style="color: #008000; font-weight: bold">import</span> Variable
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">torchvision</span> <span style="color: #008000; font-weight: bold">import</span> datasets, transforms
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">torchvision.utils</span> <span style="color: #008000; font-weight: bold">import</span> make_grid , save_image
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>


batch_size <span style="color: #666666">=</span> <span style="color: #666666">64</span>
train_loader <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>utils<span style="color: #666666">.</span>data<span style="color: #666666">.</span>DataLoader(
datasets<span style="color: #666666">.</span>MNIST(<span style="color: #BA2121">&#39;./data&#39;</span>,
    train<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>,
    download <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>,
    transform <span style="color: #666666">=</span> transforms<span style="color: #666666">.</span>Compose(
        [transforms<span style="color: #666666">.</span>ToTensor()])
     ),
     batch_size<span style="color: #666666">=</span>batch_size
)

test_loader <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>utils<span style="color: #666666">.</span>data<span style="color: #666666">.</span>DataLoader(
datasets<span style="color: #666666">.</span>MNIST(<span style="color: #BA2121">&#39;./data&#39;</span>,
    train<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>,
    transform<span style="color: #666666">=</span>transforms<span style="color: #666666">.</span>Compose(
    [transforms<span style="color: #666666">.</span>ToTensor()])
    ),
    batch_size<span style="color: #666666">=</span>batch_size)


<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">RBM</span>(nn<span style="color: #666666">.</span>Module):
   <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>,
               n_vis<span style="color: #666666">=784</span>,
               n_hin<span style="color: #666666">=500</span>,
               k<span style="color: #666666">=5</span>):
        <span style="color: #008000">super</span>(RBM, <span style="color: #008000">self</span>)<span style="color: #666666">.</span><span style="color: #0000FF">__init__</span>()
        <span style="color: #008000">self</span><span style="color: #666666">.</span>W <span style="color: #666666">=</span> nn<span style="color: #666666">.</span>Parameter(torch<span style="color: #666666">.</span>randn(n_hin,n_vis)<span style="color: #666666">*1e-2</span>)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>v_bias <span style="color: #666666">=</span> nn<span style="color: #666666">.</span>Parameter(torch<span style="color: #666666">.</span>zeros(n_vis))
        <span style="color: #008000">self</span><span style="color: #666666">.</span>h_bias <span style="color: #666666">=</span> nn<span style="color: #666666">.</span>Parameter(torch<span style="color: #666666">.</span>zeros(n_hin))
        <span style="color: #008000">self</span><span style="color: #666666">.</span>k <span style="color: #666666">=</span> k
    
   <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sample_from_p</span>(<span style="color: #008000">self</span>,p):
       <span style="color: #008000; font-weight: bold">return</span> F<span style="color: #666666">.</span>relu(torch<span style="color: #666666">.</span>sign(p <span style="color: #666666">-</span> Variable(torch<span style="color: #666666">.</span>rand(p<span style="color: #666666">.</span>size()))))
    
   <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">v_to_h</span>(<span style="color: #008000">self</span>,v):
        p_h <span style="color: #666666">=</span> F<span style="color: #666666">.</span>sigmoid(F<span style="color: #666666">.</span>linear(v,<span style="color: #008000">self</span><span style="color: #666666">.</span>W,<span style="color: #008000">self</span><span style="color: #666666">.</span>h_bias))
        sample_h <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>sample_from_p(p_h)
        <span style="color: #008000; font-weight: bold">return</span> p_h,sample_h
    
   <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">h_to_v</span>(<span style="color: #008000">self</span>,h):
        p_v <span style="color: #666666">=</span> F<span style="color: #666666">.</span>sigmoid(F<span style="color: #666666">.</span>linear(h,<span style="color: #008000">self</span><span style="color: #666666">.</span>W<span style="color: #666666">.</span>t(),<span style="color: #008000">self</span><span style="color: #666666">.</span>v_bias))
        sample_v <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>sample_from_p(p_v)
        <span style="color: #008000; font-weight: bold">return</span> p_v,sample_v
        
   <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">forward</span>(<span style="color: #008000">self</span>,v):
        pre_h1,h1 <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>v_to_h(v)
        
        h_ <span style="color: #666666">=</span> h1
        <span style="color: #008000; font-weight: bold">for</span> _ <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>k):
            pre_v_,v_ <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>h_to_v(h_)
            pre_h_,h_ <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>v_to_h(v_)
        
        <span style="color: #008000; font-weight: bold">return</span> v,v_
    
   <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">free_energy</span>(<span style="color: #008000">self</span>,v):
        vbias_term <span style="color: #666666">=</span> v<span style="color: #666666">.</span>mv(<span style="color: #008000">self</span><span style="color: #666666">.</span>v_bias)
        wx_b <span style="color: #666666">=</span> F<span style="color: #666666">.</span>linear(v,<span style="color: #008000">self</span><span style="color: #666666">.</span>W,<span style="color: #008000">self</span><span style="color: #666666">.</span>h_bias)
        hidden_term <span style="color: #666666">=</span> wx_b<span style="color: #666666">.</span>exp()<span style="color: #666666">.</span>add(<span style="color: #666666">1</span>)<span style="color: #666666">.</span>log()<span style="color: #666666">.</span>sum(<span style="color: #666666">1</span>)
        <span style="color: #008000; font-weight: bold">return</span> (<span style="color: #666666">-</span>hidden_term <span style="color: #666666">-</span> vbias_term)<span style="color: #666666">.</span>mean()




rbm <span style="color: #666666">=</span> RBM(k<span style="color: #666666">=1</span>)
train_op <span style="color: #666666">=</span> optim<span style="color: #666666">.</span>SGD(rbm<span style="color: #666666">.</span>parameters(),<span style="color: #666666">0.1</span>)

<span style="color: #008000; font-weight: bold">for</span> epoch <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">10</span>):
    loss_ <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> _, (data,target) <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(train_loader):
        data <span style="color: #666666">=</span> Variable(data<span style="color: #666666">.</span>view(<span style="color: #666666">-1</span>,<span style="color: #666666">784</span>))
        sample_data <span style="color: #666666">=</span> data<span style="color: #666666">.</span>bernoulli()
        
        v,v1 <span style="color: #666666">=</span> rbm(sample_data)
        loss <span style="color: #666666">=</span> rbm<span style="color: #666666">.</span>free_energy(v) <span style="color: #666666">-</span> rbm<span style="color: #666666">.</span>free_energy(v1)
        loss_<span style="color: #666666">.</span>append(loss<span style="color: #666666">.</span>data)
        train_op<span style="color: #666666">.</span>zero_grad()
        loss<span style="color: #666666">.</span>backward()
        train_op<span style="color: #666666">.</span>step()

    <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;Training loss for </span><span style="color: #BB6688; font-weight: bold">{}</span><span style="color: #BA2121"> epoch: </span><span style="color: #BB6688; font-weight: bold">{}</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>format(epoch, np<span style="color: #666666">.</span>mean(loss_)))


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">show_adn_save</span>(file_name,img):
    npimg <span style="color: #666666">=</span> np<span style="color: #666666">.</span>transpose(img<span style="color: #666666">.</span>numpy(),(<span style="color: #666666">1</span>,<span style="color: #666666">2</span>,<span style="color: #666666">0</span>))
    f <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;./</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">.png&quot;</span> <span style="color: #666666">%</span> file_name
    plt<span style="color: #666666">.</span>imshow(npimg)
    plt<span style="color: #666666">.</span>imsave(f,npimg)

show_adn_save(<span style="color: #BA2121">&quot;real&quot;</span>,make_grid(v<span style="color: #666666">.</span>view(<span style="color: #666666">32</span>,<span style="color: #666666">1</span>,<span style="color: #666666">28</span>,<span style="color: #666666">28</span>)<span style="color: #666666">.</span>data))
show_adn_save(<span style="color: #BA2121">&quot;generate&quot;</span>,make_grid(v1<span style="color: #666666">.</span>view(<span style="color: #666666">32</span>,<span style="color: #666666">1</span>,<span style="color: #666666">28</span>,<span style="color: #666666">28</span>)<span style="color: #666666">.</span>data))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split -->
<h2 id="rbm-using-tensorflow-and-keras" class="anchor">RBM using TensorFlow and Keras </h2>

<ol>
<li> To create Boltzmann machine using Keras, see Babcock and Bali chapter 4, see <a href="https://github.com/PacktPublishing/Hands-On-Generative-AI-with-Python-and-TensorFlow-2/blob/master/Chapter_4/models/rbm.py" target="_self"><tt>https://github.com/PacktPublishing/Hands-On-Generative-AI-with-Python-and-TensorFlow-2/blob/master/Chapter_4/models/rbm.py</tt></a></li>
</ol>
<!-- !split -->
<h2 id="energy-based-models-and-langevin-sampling" class="anchor">Energy-based models and Langevin sampling </h2>

<p>See discussions in Foster, chapter 7 on energy-based models at <a href="https://github.com/davidADSP/Generative_Deep_Learning_2nd_Edition/tree/main/notebooks/07_ebm/01_ebm" target="_self"><tt>https://github.com/davidADSP/Generative_Deep_Learning_2nd_Edition/tree/main/notebooks/07_ebm/01_ebm</tt></a></p>

<p>That notebook is based on a recent article by Du and Mordatch, <b>Implicit generation and modeling with energy-based models</b>, see <a href="https://arxiv.org/pdf/1903.08689.pdf." target="_self"><tt>https://arxiv.org/pdf/1903.08689.pdf.</tt></a></p>

<!-- !split -->
<h2 id="langevin-sampling" class="anchor">Langevin sampling </h2>

<p><b>Note</b>: Notes to be added</p>

<!-- !split -->
<h2 id="theory-of-variational-autoencoders" class="anchor">Theory of Variational Autoencoders </h2>

<p>Let us remind ourself about what an autoencoder is, see the jupyter-notebook at <a href="https://github.com/CompPhysics/AdvancedMachineLearning/blob/main/doc/pub/week10/ipynb/week10.ipynb" target="_self"><tt>https://github.com/CompPhysics/AdvancedMachineLearning/blob/main/doc/pub/week10/ipynb/week10.ipynb</tt></a>.</p>

<!-- !split -->
<h2 id="the-autoencoder-again" class="anchor">The Autoencoder again </h2>

<p>Autoencoders are neural networks where the outputs are its own
inputs. They are split into an <b>encoder part</b>
which maps the input \( \boldsymbol{x} \) via a function \( f(\boldsymbol{x},\boldsymbol{W}) \) (this
is the encoder part) to a <b>so-called code part</b> (or intermediate part)
with the result \( \boldsymbol{h} \)
</p>

$$
\boldsymbol{h} = f(\boldsymbol{x},\boldsymbol{W})),
$$

<p>where \( \boldsymbol{W} \) are the weights to be determined.  The <b>decoder</b> parts maps, via its own parameters (weights given by the matrix \( \boldsymbol{V} \) and its own biases) to 
the final ouput
</p>
$$
\tilde{\boldsymbol{x}} = g(\boldsymbol{h},\boldsymbol{V})).
$$

<p>The goal is to minimize the construction error, often done by optimizing the means squared error.</p>

<!-- !split -->
<h2 id="schematic-image-of-an-autoencoder" class="anchor">Schematic image of an Autoencoder </h2>

<br/><br/>
<center>
<p><img src="figures/ae1.png" width="700" align="bottom"></p>
</center>
<br/><br/>

<!-- !split -->
<h2 id="mathematics-of-variational-autoencoders" class="anchor">Mathematics of Variational Autoencoders </h2>

<p>We have defined earlier a probability (marginal) distribution with hidden variables \( \boldsymbol{h} \) and parameters \( \boldsymbol{\Theta} \) as</p>
$$
p(\boldsymbol{x};\boldsymbol{\Theta}) = \int d\boldsymbol{h}p(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}),
$$

<p>for continuous variables \( \boldsymbol{h} \) and</p>
$$
p(\boldsymbol{x};\boldsymbol{\Theta}) = \sum_{\boldsymbol{h}}p(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}),
$$

<p>for discrete stochastic events \( \boldsymbol{h} \). The variables \( \boldsymbol{h} \) are normally called the <b>latent variables</b> in the theory of autoencoders. We will also call then for that here.</p>

<!-- !split -->
<h2 id="using-the-conditional-probability" class="anchor">Using the conditional probability </h2>

<p>Using the the definition of the conditional probabilities \( p(\boldsymbol{x}\vert\boldsymbol{h};\boldsymbol{\Theta}) \), \( p(\boldsymbol{h}\vert\boldsymbol{x};\boldsymbol{\Theta}) \) and 
and the prior \( p(\boldsymbol{h}) \), we can rewrite the above equation as
</p>
$$
p(\boldsymbol{x};\boldsymbol{\Theta}) = \sum_{\boldsymbol{h}}p(\boldsymbol{x}\vert\boldsymbol{h};\boldsymbol{\Theta})p(\boldsymbol{h},
$$

<p>which allows us to make the dependence of \( \boldsymbol{x} \) on \( \boldsymbol{h} \)
explicit by using the law of total probability. The intuition behind
this approach for finding the marginal probability for \( \boldsymbol{x} \) is to
optimize the above equations with respect to the parameters
\( \boldsymbol{\Theta} \).  This is done normally by maximizing the probability,
the so-called maximum-likelihood approach discussed earlier.
</p>

<!-- !split -->
<h2 id="vaes-versus-autoencoders" class="anchor">VAEs versus autoencoders </h2>

<p>This trained probability is assumed to be able to produce similar
samples as the input.  In VAEs it is then common to compare via for
example the mean-squared error or the cross-entropy the predicted
values with the input values.  Compared with autoencoders, we are now
producing a probability instead of a functions which mimicks the
input.
</p>

<p>In VAEs, the choice of this output distribution is often Gaussian,
meaning that the conditional probability is
</p>
$$
p(\boldsymbol{x}\vert\boldsymbol{h};\boldsymbol{\Theta})=N(\boldsymbol{x}\vert f(\boldsymbol{h};\boldsymbol{\Theta}), \sigma^2\times \boldsymbol{I}),
$$

<p>with mean value given by the function \( f(\boldsymbol{h};\boldsymbol{\Theta}) \) and a
diagonal covariance matrix multiplied by a parameter \( \sigma^2 \) which
is treated as a hyperparameter.
</p>

<!-- !split -->
<h2 id="gradient-descent" class="anchor">Gradient descent </h2>

<p>By having a Gaussian distribution, we can use gradient descent (or any
other optimization technique) to increase \( p(\boldsymbol{x};\boldsymbol{\Theta}) \) by
making \( f(\boldsymbol{h};\boldsymbol{\Theta}) \) approach \( \boldsymbol{x} \) for some \( \boldsymbol{h} \),
gradually making the training data more likely under the generative
model. The important property is simply that the marginal probability
can be computed, and it is continuous in \( \boldsymbol{\Theta} \)..
</p>

<!-- !split -->
<h2 id="are-vaes-just-modified-autoencoders" class="anchor">Are VAEs just modified autoencoders? </h2>

<p>The mathematical basis of VAEs actually has relatively little to do
with classical autoencoders, for example the sparse autoencoders or
denoising autoencoders discussed earlier.
</p>

<p>VAEs approximately maximize the probability equation discussed
above. They are called autoencoders only because the final training
objective that derives from this setup does have an encoder and a
decoder, and resembles a traditional autoencoder. Unlike sparse
autoencoders, there are generally no tuning parameters analogous to
the sparsity penalties. And unlike sparse and denoising autoencoders,
we can sample directly from \( p(\boldsymbol{x}) \) without performing Markov
Chain Monte Carlo.
</p>

<!-- !split -->
<h2 id="training-vaes" class="anchor">Training VAEs </h2>

<p>To solve the integral or sum for \( p(\boldsymbol{x}) \), there are two problems
that VAEs must deal with: how to define the latent variables \( \boldsymbol{h} \),
that is decide what information they represent, and how to deal with
the integral over \( \boldsymbol{h} \).  VAEs give a definite answer to both.
</p>

<!-- !split -->
<h2 id="kullback-leibler-relative-entropy-notation-to-be-updated" class="anchor">Kullback-Leibler relative entropy (notation to be updated) </h2>

<p>When the goal of the training is to approximate a probability
distribution, as it is in generative modeling, another relevant
measure is the <b>Kullback-Leibler divergence</b>, also known as the
relative entropy or Shannon entropy. It is a non-symmetric measure of the
dissimilarity between two probability density functions \( p \) and
\( q \). If \( p \) is the unkown probability which we approximate with \( q \),
we can measure the difference by
</p>
$$
\begin{align*}
	\text{KL}(p||q) = \int_{-\infty}^{\infty} p (\boldsymbol{x}) \log \frac{p(\boldsymbol{x})}{q(\boldsymbol{x})}  d\boldsymbol{x}.
\end{align*}
$$


<!-- !split -->
<h2 id="kullback-leibler-divergence" class="anchor">Kullback-Leibler divergence </h2>

<p>Thus, the Kullback-Leibler divergence between the distribution of the
training data \( f(\boldsymbol{x}) \) and the model distribution \( p(\boldsymbol{x}|
\boldsymbol{\Theta}) \) is
</p>

$$
\begin{align*}
	\text{KL} (f(\boldsymbol{x})|| p(\boldsymbol{x}| \boldsymbol{\Theta})) =& \int_{-\infty}^{\infty}
	f (\boldsymbol{x}) \log \frac{f(\boldsymbol{x})}{p(\boldsymbol{x}| \boldsymbol{\Theta})} d\boldsymbol{x} \\
	=& \int_{-\infty}^{\infty} f(\boldsymbol{x}) \log f(\boldsymbol{x}) d\boldsymbol{x} - \int_{-\infty}^{\infty} f(\boldsymbol{x}) \log
	p(\boldsymbol{x}| \boldsymbol{\Theta}) d\boldsymbol{x} \\
	%=& \mathbb{E}_{f(\boldsymbol{x})} (\log f(\boldsymbol{x})) - \mathbb{E}_{f(\boldsymbol{x})} (\log p(\boldsymbol{x}| \boldsymbol{\Theta}))
	=& \langle \log f(\boldsymbol{x}) \rangle_{f(\boldsymbol{x})} - \langle \log p(\boldsymbol{x}| \boldsymbol{\Theta}) \rangle_{f(\boldsymbol{x})} \\
	=& \langle \log f(\boldsymbol{x}) \rangle_{data} + \langle E(\boldsymbol{x}) \rangle_{data} + \log Z \\
	=& \langle \log f(\boldsymbol{x}) \rangle_{data} + \mathcal{C}_{LL} .
\end{align*}
$$


<!-- !split -->
<h2 id="maximizing-log-likelihood" class="anchor">Maximizing log-likelihood </h2>

<p>The first term is constant with respect to \( \boldsymbol{\Theta} \) since
\( f(\boldsymbol{x}) \) is independent of \( \boldsymbol{\Theta} \). Thus the Kullback-Leibler
Divergence is minimal when the second term is minimal. The second term
is the log-likelihood cost function, hence minimizing the
Kullback-Leibler divergence is equivalent to maximizing the
log-likelihood.
</p>

<p>To further understand generative models it is useful to study the
gradient of the cost function which is needed in order to minimize it
using methods like stochastic gradient descent. 
</p>

<!-- !split -->
<h2 id="more-on-the-partition-function" class="anchor">More on the partition function </h2>

<p>The partition function is the generating function of
expectation values, in particular there are mathematical relationships
between expectation values and the log-partition function. In this
case we have
</p>
$$
\begin{align*}
	\langle \frac{ \partial E(\boldsymbol{x}; \Theta_i) } { \partial \Theta_i} \rangle_{model}
	= \int p(\boldsymbol{x}| \boldsymbol{\Theta}) \frac{ \partial E(\boldsymbol{x}; \Theta_i) } { \partial \Theta_i} d\boldsymbol{x} 
	= -\frac{\partial \log Z(\Theta_i)}{ \partial  \Theta_i} .
\end{align*}
$$

<p>Here \( \langle \cdot \rangle_{model} \) is the expectation value over the model probability distribution \( p(\boldsymbol{x}| \boldsymbol{\Theta}) \).</p>

<!-- !split -->
<h2 id="setting-up-for-gradient-descent-calculations" class="anchor">Setting up for gradient descent calculations </h2>

<p>Using the previous relationship we can express the gradient of the cost function as</p>

$$
\begin{align*}
	\frac{\partial \mathcal{C}_{LL}}{\partial \Theta_i}
	=& \langle \frac{ \partial E(\boldsymbol{x}; \Theta_i) } { \partial \Theta_i} \rangle_{data} + \frac{\partial \log Z(\Theta_i)}{ \partial  \Theta_i} \\
	=& \langle \frac{ \partial E(\boldsymbol{x}; \Theta_i) } { \partial \Theta_i} \rangle_{data} - \langle \frac{ \partial E(\boldsymbol{x}; \Theta_i) } { \partial \Theta_i} \rangle_{model} \\
	%=& \langle O_i(\boldsymbol{x}) \rangle_{data} - \langle O_i(\boldsymbol{x}) \rangle_{model}
\end{align*}
$$


<!-- !split -->
<h2 id="difference-of-moments" class="anchor">Difference of moments </h2>

<p>This expression shows that the gradient of the log-likelihood cost
function is a <b>difference of moments</b>, with one calculated from
the data and one calculated from the model. The data-dependent term is
called the <b>positive phase</b> and the model-dependent term is
called the <b>negative phase</b> of the gradient. We see now that
minimizing the cost function results in lowering the energy of
configurations \( \boldsymbol{x} \) near points in the training data and
increasing the energy of configurations not observed in the training
data. That means we increase the model's probability of configurations
similar to those in the training data.
</p>

<!-- !split -->
<h2 id="more-observations" class="anchor">More observations </h2>

<p>The gradient of the cost function also demonstrates why gradients of
unsupervised, generative models must be computed differently from for
those of for example FNNs. While the data-dependent expectation value
is easily calculated based on the samples \( \boldsymbol{x}_i \) in the training
data, we must sample from the model in order to generate samples from
which to caclulate the model-dependent term. We sample from the model
by using MCMC-based methods. We can not sample from the model directly
because the partition function \( Z \) is generally intractable.
</p>

<!-- !split -->
<h2 id="adding-hyperparameters" class="anchor">Adding hyperparameters </h2>

<p>As in supervised machine learning problems, the goal is also here to
perform well on <b>unseen</b> data, that is to have good
generalization from the training data. The distribution \( f(x) \) we
approximate is not the <b>true</b> distribution we wish to estimate,
it is limited to the training data. Hence, in unsupervised training as
well it is important to prevent overfitting to the training data. Thus
it is common to add regularizers to the cost function in the same
manner as  discussed for say linear regression.
</p>

<!-- !split -->
<h2 id="using-the-kl-divergence" class="anchor">Using the KL divergence </h2>

<p>In practice, for most \( \boldsymbol{h} \), \( p(\boldsymbol{x}\vert \boldsymbol{h}; \boldsymbol{\Theta}) \)
will be nearly zero, and hence contribute almost nothing to our
estimate of \( p(\boldsymbol{x}) \).
</p>

<p>The key idea behind the variational autoencoder is to attempt to
sample values of \( \boldsymbol{h} \) that are likely to have produced \( \boldsymbol{x} \),
and compute \( p(\boldsymbol{x}) \) just from those.
</p>

<p>This means that we need a new function \( Q(\boldsymbol{h}|\boldsymbol{x}) \) which can
take a value of \( \boldsymbol{x} \) and give us a distribution over \( \boldsymbol{h} \)
values that are likely to produce \( \boldsymbol{x} \).  Hopefully the space of
\( \boldsymbol{h} \) values that are likely under \( Q \) will be much smaller than
the space of all \( \boldsymbol{h} \)'s that are likely under the prior
\( p(\boldsymbol{h}) \).  This lets us, for example, compute \( E_{\boldsymbol{h}\sim
Q}p(\boldsymbol{x}\vert \boldsymbol{h}) \) relatively easily. Note that we drop
\( \boldsymbol{\Theta} \) from here and for notational simplicity.
</p>

<!-- !split -->
<h2 id="kullback-leibler-again" class="anchor">Kullback-Leibler again </h2>

<p>However, if \( \boldsymbol{h} \) is sampled from an arbitrary distribution with
PDF \( Q(\boldsymbol{h}) \), which is not \( \mathcal{N}(0,I) \), then how does that
help us optimize \( p(\boldsymbol{x}) \)?  The first thing we need to do is relate
\( E_{\boldsymbol{h}\sim Q}P(\boldsymbol{x}\vert \boldsymbol{h}) \) and \( p(\boldsymbol{x}) \).  We will see where \( Q \) comes from later.
</p>

<p>The relationship between \( E_{\boldsymbol{h}\sim Q}p(\boldsymbol{x}\vert \boldsymbol{h}) \) and \( p(\boldsymbol{x}) \) is one of the cornerstones of variational Bayesian methods.
We begin with the definition of Kullback-Leibler divergence (KL divergence or \( \mathcal{D} \)) between \( p(\boldsymbol{h}\vert \boldsymbol{x}) \) and \( Q(\boldsymbol{h}) \), for some arbitrary \( Q \) (which may or may not depend on \( \boldsymbol{x} \)):
</p>
$$
    \mathcal{D}\left[Q(z)\|P(z|X)\right]=E_{z\sim Q}\left[\log Q(z) - \log P(z|X) \right].
$$


<!-- !split -->
<h2 id="and-applying-bayes-rule" class="anchor">And applying Bayes rule </h2>

<p>We can get both \( p(\boldsymbol{x}) \) and \( p(\boldsymbol{x}\vert \boldsymbol{h}) \) into this equation by applying Bayes rule to \( p(\boldsymbol{h}|\boldsymbol{x}) \)</p>
$$
    \mathcal{D}\left[Q(z)\|P(z|X)\right]=E_{z\sim Q}\left[\log Q(z) - \log P(X|z) - \log P(z) \right] + \log P(X).
$$

<p>Here, \( \log P(X) \) comes out of the expectation because it does not depend on \( z \).
Negating both sides, rearranging, and contracting part of \( E_{z\sim Q} \) into a KL-divergence terms yields:
</p>
$$
\log P(X) - \mathcal{D}\left[Q(z)\|P(z|X)\right]=E_{z\sim Q}\left[\log P(X|z)  \right] - \mathcal{D}\left[Q(z)\|P(z)\right].
$$


<!-- !split -->
<h2 id="rearraning" class="anchor">Rearraning </h2>

<p>Using Bayes rule we obtain</p>
$$
E_{z\sim Q}\left[\log P(Y_i|z,X_i)\right]=E_{z\sim Q}\left[\log P(z|Y_i,X_i) - \log P(z|X_i) + \log P(Y_i|X_i) \right]
$$

<p>Rearranging the terms and subtracting \( E_{z\sim Q}\log Q(z) \) from both sides gives</p>
$$
\begin{array}{c}
\log P(Y_i|X_i) - E_{z\sim Q}\left[\log Q(z)-\log P(z|X_i,Y_i)\right]=\hspace{10em}\\
\hspace{10em}E_{z\sim Q}\left[\log P(Y_i|z,X_i)+\log P(z|X_i)-\log Q(z)\right]
\end{array}
$$

<p>Note that \( X \) is fixed, and \( Q \) can be \textit{any} distribution, not
just a distribution which does a good job mapping \( X \) to the \( z \)'s
that can produce \( X \).
</p>

<!-- !split -->
<h2 id="inferring-the-probability" class="anchor">Inferring the probability </h2>

<p>Since we are interested in inferring \( P(X) \), it makes sense to
construct a \( Q \) which \textit{does} depend on \( X \), and in particular,
one which makes \( \mathcal{D}\left[Q(z)\|P(z|X)\right] \) small
</p>
$$
\log P(X) - \mathcal{D}\left[Q(z|X)\|P(z|X)\right]=E_{z\sim Q}\left[\log P(X|z)  \right] - \mathcal{D}\left[Q(z|X)\|P(z)\right].
$$

<p>Hence, during training, it makes sense to choose a \( Q \) which will make
\( E_{z\sim Q}[\log Q(z)- \) $\log P(z|X_i,Y_i)]$ (a
\( \mathcal{D} \)-divergence) small, such that the right hand side is a
close approximation to \( \log P(Y_i|X_i) \).
</p>

<!-- !split -->
<h2 id="central-equation-of-vaes" class="anchor">Central equation of VAEs </h2>

<p>This equation serves as the core of the variational autoencoder, and
it is worth spending some time thinking about what it means.
</p>

<ol>
<li> The left hand side has the quantity we want to maximize, namely \( \log P(X) \) plus an error term.</li>
<li> The right hand side is something we can optimize via stochastic gradient descent given the right choice of \( Q \).</li>
</ol>
<!-- !split -->
<h2 id="setting-up-sgd" class="anchor">Setting up SGD </h2>
<p>So how can we perform stochastic gradient descent?</p>

<p>First we need to be a bit more specific about the form that \( Q(z|X) \)
will take.  The usual choice is to say that
\( Q(z|X)=\mathcal{N}(z|\mu(X;\vartheta),\Sigma(X;\vartheta)) \), where
\( \mu \) and \( \Sigma \) are arbitrary deterministic functions with
parameters \( \vartheta \) that can be learned from data (we will omit
\( \vartheta \) in later equations).  In practice, \( \mu \) and \( \Sigma \) are
again implemented via neural networks, and \( \Sigma \) is constrained to
be a diagonal matrix.
</p>

<!-- !split -->
<h2 id="more-on-the-sgd" class="anchor">More on the SGD </h2>

<p>The name variational &quot;autoencoder&quot; comes from
the fact that \( \mu \) and \( \Sigma \) are &quot;encoding&quot; \( X \) into the latent
space \( z \).  The advantages of this choice are computational, as they
make it clear how to compute the right hand side.  The last
term---\( \mathcal{D}\left[Q(z|X)\|P(z)\right] \)---is now a KL-divergence
between two multivariate Gaussian distributions, which can be computed
in closed form as:
</p>
$$
\begin{array}{c}
 \mathcal{D}[\mathcal{N}(\mu_0,\Sigma_0) \| \mathcal{N}(\mu_1,\Sigma_1)] = \hspace{20em}\\
  \hspace{5em}\frac{ 1 }{ 2 } \left( \mathrm{tr} \left( \Sigma_1^{-1} \Sigma_0 \right) + \left( \mu_1 - \mu_0\right)^\top \Sigma_1^{-1} ( \mu_1 - \mu_0 ) - k + \log \left( \frac{ \det \Sigma_1 }{ \det \Sigma_0  } \right)  \right)
\end{array}
$$

<p>where \( k \) is the dimensionality of the distribution.</p>

<!-- !split -->
<h2 id="simplification" class="anchor">Simplification </h2>
<p>In our case, this simplifies to:</p>
$$
\begin{array}{c}
 \mathcal{D}[\mathcal{N}(\mu(X),\Sigma(X)) \| \mathcal{N}(0,I)] = \hspace{20em}\\
\hspace{6em}\frac{ 1 }{ 2 } \left( \mathrm{tr} \left( \Sigma(X) \right) + \left( \mu(X)\right)^\top ( \mu(X) ) - k - \log\det\left(  \Sigma(X)  \right)  \right).
\end{array}
$$


<!-- !split -->
<h2 id="terms-to-compute" class="anchor">Terms to compute </h2>

<p>The first term on the right hand side is a bit more tricky.
We could use sampling to estimate \( E_{z\sim Q}\left[\log P(X|z)  \right] \), but getting a good estimate would require passing many samples of \( z \) through \( f \), which would be expensive.
Hence, as is standard in stochastic gradient descent, we take one sample of \( z \) and treat \( \log P(X|z) \) for that \( z \) as an approximation of \( E_{z\sim Q}\left[\log P(X|z)  \right] \).
After all, we are already doing stochastic gradient descent over different values of \( X \) sampled from a dataset \( D \).
The full equation we want to optimize is:
</p>

$$
\begin{array}{c}
    E_{X\sim D}\left[\log P(X) - \mathcal{D}\left[Q(z|X)\|P(z|X)\right]\right]=\hspace{16em}\\
\hspace{10em}E_{X\sim D}\left[E_{z\sim Q}\left[\log P(X|z)  \right] - \mathcal{D}\left[Q(z|X)\|P(z)\right]\right].
\end{array}
$$


<!-- !split -->
<h2 id="computing-the-gradients" class="anchor">Computing the gradients </h2>

<p>If we take the gradient of this equation, the gradient symbol can be moved into the expectations.
Therefore, we can sample a single value of \( X \) and a single value of \( z \) from the distribution \( Q(z|X) \), and compute the gradient of:
</p>
$$
\begin{equation}
 \log P(X|z)-\mathcal{D}\left[Q(z|X)\|P(z)\right].
\label{_auto1}
\end{equation}
$$

<p>We can then average the gradient of this function over arbitrarily many samples of \( X \) and \( z \), and the result converges to the gradient.</p>

<p>There is, however, a significant problem
\( E_{z\sim Q}\left[\log P(X|z)  \right] \) depends not just on the parameters of \( P \), but also on the parameters of \( Q \).
</p>

<p>In order to make VAEs work, it is essential to drive \( Q \) to produce codes for \( X \) that \( P \) can reliably decode.  </p>
$$
 E_{X\sim D}\left[E_{\epsilon\sim\mathcal{N}(0,I)}[\log P(X|z=\mu(X)+\Sigma^{1/2}(X)*\epsilon)]-\mathcal{D}\left[Q(z|X)\|P(z)\right]\right].
$$


<!-- !split -->
<h2 id="code-examples-using-keras" class="anchor">Code examples using Keras </h2>

<p>See <a href="https://keras.io/examples/generative/vae/" target="_self"><tt>https://keras.io/examples/generative/vae/</tt></a></p>

<!-- !split -->
<h2 id="code-in-pytorch-for-vaes" class="anchor">Code in PyTorch for VAEs </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torch</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">torch.autograd</span> <span style="color: #008000; font-weight: bold">import</span> Variable
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torch.nn.functional</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">F</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torchvision</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">torchvision</span> <span style="color: #008000; font-weight: bold">import</span> transforms
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torch.optim</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">optim</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">torch</span> <span style="color: #008000; font-weight: bold">import</span> nn
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">torch</span> <span style="color: #008000; font-weight: bold">import</span> distributions

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Encoder</span>(torch<span style="color: #666666">.</span>nn<span style="color: #666666">.</span>Module):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, D_in, H, latent_size):
        <span style="color: #008000">super</span>(Encoder, <span style="color: #008000">self</span>)<span style="color: #666666">.</span><span style="color: #0000FF">__init__</span>()
        <span style="color: #008000">self</span><span style="color: #666666">.</span>linear1 <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>nn<span style="color: #666666">.</span>Linear(D_in, H)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>linear2 <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>nn<span style="color: #666666">.</span>Linear(H, H)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>enc_mu <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>nn<span style="color: #666666">.</span>Linear(H, latent_size)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>enc_log_sigma <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>nn<span style="color: #666666">.</span>Linear(H, latent_size)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">forward</span>(<span style="color: #008000">self</span>, x):
        x <span style="color: #666666">=</span> F<span style="color: #666666">.</span>relu(<span style="color: #008000">self</span><span style="color: #666666">.</span>linear1(x))
        x <span style="color: #666666">=</span> F<span style="color: #666666">.</span>relu(<span style="color: #008000">self</span><span style="color: #666666">.</span>linear2(x))
        mu <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>enc_mu(x)
        log_sigma <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>enc_log_sigma(x)
        sigma <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>exp(log_sigma)
        <span style="color: #008000; font-weight: bold">return</span> torch<span style="color: #666666">.</span>distributions<span style="color: #666666">.</span>Normal(loc<span style="color: #666666">=</span>mu, scale<span style="color: #666666">=</span>sigma)


<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Decoder</span>(torch<span style="color: #666666">.</span>nn<span style="color: #666666">.</span>Module):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, D_in, H, D_out):
        <span style="color: #008000">super</span>(Decoder, <span style="color: #008000">self</span>)<span style="color: #666666">.</span><span style="color: #0000FF">__init__</span>()
        <span style="color: #008000">self</span><span style="color: #666666">.</span>linear1 <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>nn<span style="color: #666666">.</span>Linear(D_in, H)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>linear2 <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>nn<span style="color: #666666">.</span>Linear(H, D_out)
        

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">forward</span>(<span style="color: #008000">self</span>, x):
        x <span style="color: #666666">=</span> F<span style="color: #666666">.</span>relu(<span style="color: #008000">self</span><span style="color: #666666">.</span>linear1(x))
        mu <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>tanh(<span style="color: #008000">self</span><span style="color: #666666">.</span>linear2(x))
        <span style="color: #008000; font-weight: bold">return</span> torch<span style="color: #666666">.</span>distributions<span style="color: #666666">.</span>Normal(mu, torch<span style="color: #666666">.</span>ones_like(mu))

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">VAE</span>(torch<span style="color: #666666">.</span>nn<span style="color: #666666">.</span>Module):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, encoder, decoder):
        <span style="color: #008000">super</span>(VAE, <span style="color: #008000">self</span>)<span style="color: #666666">.</span><span style="color: #0000FF">__init__</span>()
        <span style="color: #008000">self</span><span style="color: #666666">.</span>encoder <span style="color: #666666">=</span> encoder
        <span style="color: #008000">self</span><span style="color: #666666">.</span>decoder <span style="color: #666666">=</span> decoder

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">forward</span>(<span style="color: #008000">self</span>, state):
        q_z <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>encoder(state)
        z <span style="color: #666666">=</span> q_z<span style="color: #666666">.</span>rsample()
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>decoder(z), q_z


transform <span style="color: #666666">=</span> transforms<span style="color: #666666">.</span>Compose(
    [transforms<span style="color: #666666">.</span>ToTensor(),
     <span style="color: #408080; font-style: italic"># Normalize the images to be -0.5, 0.5</span>
     transforms<span style="color: #666666">.</span>Normalize(<span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>)]
    )
mnist <span style="color: #666666">=</span> torchvision<span style="color: #666666">.</span>datasets<span style="color: #666666">.</span>MNIST(<span style="color: #BA2121">&#39;./&#39;</span>, download<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>, transform<span style="color: #666666">=</span>transform)

input_dim <span style="color: #666666">=</span> <span style="color: #666666">28</span> <span style="color: #666666">*</span> <span style="color: #666666">28</span>
batch_size <span style="color: #666666">=</span> <span style="color: #666666">128</span>
num_epochs <span style="color: #666666">=</span> <span style="color: #666666">100</span>
learning_rate <span style="color: #666666">=</span> <span style="color: #666666">0.001</span>
hidden_size <span style="color: #666666">=</span> <span style="color: #666666">512</span>
latent_size <span style="color: #666666">=</span> <span style="color: #666666">8</span>

<span style="color: #008000; font-weight: bold">if</span> torch<span style="color: #666666">.</span>cuda<span style="color: #666666">.</span>is_available():
    device <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>device(<span style="color: #BA2121">&#39;cuda&#39;</span>)
<span style="color: #008000; font-weight: bold">else</span>:
    device <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>device(<span style="color: #BA2121">&#39;cpu&#39;</span>)

dataloader <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>utils<span style="color: #666666">.</span>data<span style="color: #666666">.</span>DataLoader(
    mnist, batch_size<span style="color: #666666">=</span>batch_size,
    shuffle<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>, 
    pin_memory<span style="color: #666666">=</span>torch<span style="color: #666666">.</span>cuda<span style="color: #666666">.</span>is_available())

<span style="color: #008000">print</span>(<span style="color: #BA2121">&#39;Number of samples: &#39;</span>, <span style="color: #008000">len</span>(mnist))

encoder <span style="color: #666666">=</span> Encoder(input_dim, hidden_size, latent_size)
decoder <span style="color: #666666">=</span> Decoder(latent_size, hidden_size, input_dim)

vae <span style="color: #666666">=</span> VAE(encoder, decoder)<span style="color: #666666">.</span>to(device)

optimizer <span style="color: #666666">=</span> optim<span style="color: #666666">.</span>Adam(vae<span style="color: #666666">.</span>parameters(), lr<span style="color: #666666">=</span>learning_rate)
<span style="color: #008000; font-weight: bold">for</span> epoch <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_epochs):
    <span style="color: #008000; font-weight: bold">for</span> data <span style="color: #AA22FF; font-weight: bold">in</span> dataloader:
        inputs, _ <span style="color: #666666">=</span> data
        inputs <span style="color: #666666">=</span> inputs<span style="color: #666666">.</span>view(<span style="color: #666666">-1</span>, input_dim)<span style="color: #666666">.</span>to(device)
        optimizer<span style="color: #666666">.</span>zero_grad()
        p_x, q_z <span style="color: #666666">=</span> vae(inputs)
        log_likelihood <span style="color: #666666">=</span> p_x<span style="color: #666666">.</span>log_prob(inputs)<span style="color: #666666">.</span>sum(<span style="color: #666666">-1</span>)<span style="color: #666666">.</span>mean()
        kl <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>distributions<span style="color: #666666">.</span>kl_divergence(
            q_z, 
            torch<span style="color: #666666">.</span>distributions<span style="color: #666666">.</span>Normal(<span style="color: #666666">0</span>, <span style="color: #666666">1.</span>)
        )<span style="color: #666666">.</span>sum(<span style="color: #666666">-1</span>)<span style="color: #666666">.</span>mean()
        loss <span style="color: #666666">=</span> <span style="color: #666666">-</span>(log_likelihood <span style="color: #666666">-</span> kl)
        loss<span style="color: #666666">.</span>backward()
        optimizer<span style="color: #666666">.</span>step()
        l <span style="color: #666666">=</span> loss<span style="color: #666666">.</span>item()
    <span style="color: #008000">print</span>(epoch, l, log_likelihood<span style="color: #666666">.</span>item(), kl<span style="color: #666666">.</span>item())
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split -->
<h2 id="what-is-a-gan" class="anchor">What is a GAN? </h2>

<p>A GAN is a deep neural network which consists of two networks, a
so-called generator network and a discriminating network, or just
discriminator. Through several iterations of generation and
discrimination, the idea is that these networks will train each other,
while also trying to outsmart each other.
</p>

<!-- !split -->
<h2 id="what-is-a-generator-network" class="anchor">What is a generator network? </h2>

<p>A generator network is often a deep network which uses existing data
to generate new data (from for example simulations of physical
systems, imagesm video, audio and more) from randomly generated
inputs, the so-called latent space. Training the network allows us to
generate say new data, images etc. As an example a generator network
could for example be a Boltzmann machine as discussed earlier. This
machine is trained to produce for example a quantum mechanical
probability distribution.
</p>

<p>It can a simple neural network with an input layer and an output layer and a given number of hidden layers.</p>

<!-- !split -->
<h2 id="and-what-is-a-discriminator-network" class="anchor">And what is a discriminator network? </h2>

<p>A discriminator tries to distinguish between real data and those generated by the abovementioned generator.</p>

<!-- !split -->
<h2 id="appplications-of-gans" class="anchor">Appplications of GANs </h2>

<p>There are exteremely many applications of GANs</p>
<ol>
<li> Image generation</li>
<li> Text-to-image analysis</li>
<li> Face-aging</li>
<li> Image-to-image translation</li>
<li> Video synthesis</li>
<li> High-resolution image generation</li>
<li> Completing missing parts of images and much more</li>
</ol>
<!-- !split -->
<h2 id="generative-adversarial-networks" class="anchor">Generative Adversarial Networks </h2>

<p><b>Generative Adversarial Networks</b> are a type of unsupervised machine learning
algorithm proposed by Goodfellow et. al, see <a href="https://arxiv.org/pdf/1406.2661.pdf" target="_self"><tt>https://arxiv.org/pdf/1406.2661.pdf</tt></a>
in 2014 (Read the paper first it's only 6 pages). The simplest formulation of
the model is based on a game theoretic approach, <em>zero sum game</em>, where we pit
two neural networks against one another. We define two rival networks, one
generator \( g \), and one discriminator \( d \). The generator directly produces
samples
</p>
$$
    x = g(z; \theta^{(g)}).
$$


<!-- !split -->
<h2 id="discriminator" class="anchor">Discriminator </h2>

<p>The discriminator attempts to distinguish between samples drawn from the
training data and samples drawn from the generator. In other words, it tries to
tell the difference between the fake data produced by \( g \) and the actual data
samples we want to do prediction on. The discriminator outputs a probability
value given by
</p>

$$
    d(x; \theta^{(d)}).
$$

<p>indicating the probability that \( x \) is a real training example rather than a
fake sample the generator has generated.
</p>

<!-- !split -->
<h2 id="zero-sum-game" class="anchor">Zero-sum game </h2>

<p>The simplest way to formulate the
learning process in a generative adversarial network is a zero-sum game, in
which a function
</p>

$$
    v(\theta^{(g)}, \theta^{(d)}),
$$

<p>determines the reward for the discriminator, while the generator gets the
conjugate reward
</p>

$$
    -v(\theta^{(g)}, \theta^{(d)})
$$


<!-- !split -->
<h2 id="maximizing-reward" class="anchor">Maximizing reward </h2>

<p>During learning both of the networks maximize their own reward function, so that
the generator gets better and better at tricking the discriminator, while the
discriminator gets better and better at telling the difference between the fake
and real data. The generator and discriminator alternate on which one trains at
one time (i.e. for one epoch). In other words, we keep the generator constant
and train the discriminator, then we keep the discriminator constant to train
the generator and repeat. It is this back and forth dynamic which lets GANs
tackle otherwise intractable generative problems. As the generator improves with
 training, the discriminator's performance gets worse because it cannot easily
 tell the difference between real and fake. If the generator ends up succeeding
 perfectly, the the discriminator will do no better than random guessing i.e.
 50\%.
</p>

<!-- !split -->
<h2 id="progression-in-training" class="anchor">Progression in training </h2>

<p>This progression in the training poses a problem for the convergence
 criteria for GANs. The discriminator feedback gets less meaningful over time,
 if we continue training after this point then the generator is effectively
 training on junk data which can undo the learning up to that point. Therefore,
 we stop training when the discriminator starts outputting \( 1/2 \) everywhere.
 At convergence we have
</p>

$$
    g^* = \underset{g}{\mathrm{argmin}}\hspace{2pt}
          \underset{d}{\mathrm{max}}v(\theta^{(g)}, \theta^{(d)}),
$$


<!-- !split -->
<h2 id="deafault-choice" class="anchor">Deafault choice </h2>
<p>The default choice for \( v \) is</p>
$$
    v(\theta^{(g)}, \theta^{(d)}) = \mathbb{E}_{x\sim p_\mathrm{data}}\log d(x)
                                  + \mathbb{E}_{x\sim p_\mathrm{model}}
                                  \log (1 - d(x)).
$$


<!-- !split -->
<h2 id="design-of-gans" class="anchor">Design of GANs </h2>
<p>The main motivation for the design of GANs is that the learning process requires
neither approximate inference (variational autoencoders for example) nor
approximation of a partition function. In the case where
</p>
$$
    \underset{d}{\mathrm{max}}v(\theta^{(g)}, \theta^{(d)})
$$

<p>is convex in \( \theta^{(g)} \) then the procedure is guaranteed to converge and is
asymptotically consistent
( <a href="https://arxiv.org/pdf/1804.09139.pdf" target="_self">Seth Lloyd on QuGANs</a>  ). This is in
general not the case and it is possible to get situations where the training
process never converges because the generator and discriminator chase one
another around in the parameter space indefinitely.
</p>

<!-- !split -->
<h2 id="more-references" class="anchor">More references </h2>

<p>A much deeper discussion on
the currently open research problem of GAN convergence is available
from <a href="https://www.deeplearningbook.org/contents/generative_models.html" target="_self"><tt>https://www.deeplearningbook.org/contents/generative_models.html</tt></a>. To
anyone interested in learning more about GANs it is a highly recommended read.
Direct quote: <b>In this best-performing formulation, the generator aims to
increase the log probability that the discriminator makes a mistake, rather than
aiming to decrease the log probability that the discriminator makes the correct
prediction.</b> Another interesting read can be found at <a href="https://arxiv.org/abs/1701.00160" target="_self"><tt>https://arxiv.org/abs/1701.00160</tt></a>.
</p>

<!-- !split -->
<h2 id="writing-our-first-generative-adversarial-network" class="anchor">Writing Our First Generative Adversarial Network </h2>

<p>This part is best seen using the jupyter-notebook.</p>

<p>Let us implement a GAN in tensorflow. We will study
the performance of our GAN on the MNIST dataset. This code is based on and
adapted from the Google tutorial at <a href="https://www.tensorflow.org/tutorials/generative/dcgan" target="_self"><tt>https://www.tensorflow.org/tutorials/generative/dcgan</tt></a>
</p>

<p>First we import our libraries</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">os</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">tensorflow</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">tf</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">tensorflow.keras</span> <span style="color: #008000; font-weight: bold">import</span> layers
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">tensorflow.keras.utils</span> <span style="color: #008000; font-weight: bold">import</span> plot_model
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Next we define our hyperparameters and import our data the usual way</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">BUFFER_SIZE <span style="color: #666666">=</span> <span style="color: #666666">60000</span>
BATCH_SIZE <span style="color: #666666">=</span> <span style="color: #666666">256</span>
EPOCHS <span style="color: #666666">=</span> <span style="color: #666666">30</span>

data <span style="color: #666666">=</span> tf<span style="color: #666666">.</span>keras<span style="color: #666666">.</span>datasets<span style="color: #666666">.</span>mnist<span style="color: #666666">.</span>load_data()
(train_images, train_labels), (test_images, test_labels) <span style="color: #666666">=</span> data
train_images <span style="color: #666666">=</span> np<span style="color: #666666">.</span>reshape(train_images, (train_images<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>],
                                         <span style="color: #666666">28</span>,
                                         <span style="color: #666666">28</span>,
                                         <span style="color: #666666">1</span>))<span style="color: #666666">.</span>astype(<span style="color: #BA2121">&#39;float32&#39;</span>)

<span style="color: #408080; font-style: italic"># we normalize between -1 and 1</span>
train_images <span style="color: #666666">=</span> (train_images <span style="color: #666666">-</span> <span style="color: #666666">127.5</span>) <span style="color: #666666">/</span> <span style="color: #666666">127.5</span>
training_dataset <span style="color: #666666">=</span> tf<span style="color: #666666">.</span>data<span style="color: #666666">.</span>Dataset<span style="color: #666666">.</span>from_tensor_slices(
                      train_images)<span style="color: #666666">.</span>shuffle(BUFFER_SIZE)<span style="color: #666666">.</span>batch(BATCH_SIZE)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Let's have a quick look</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">plt<span style="color: #666666">.</span>imshow(train_images[<span style="color: #666666">0</span>], cmap<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Greys&#39;</span>)
plt<span style="color: #666666">.</span>show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Now we define our two models. This is where the 'magic' happens. There are a
huge amount of possible formulations for both models. A lot of engineering and
trial and error can be done here to try to produce better performing models. For
more advanced GANs this is by far the step where you can 'make or break' a
model.
</p>

<p>We start with the generator. As stated in the introductory text the generator
\( g \) upsamples from a random sample to the shape of what we want to predict. In
our case we are trying to predict MNIST images (\( 28\times 28 \) pixels).
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">generator_model</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    The generator uses upsampling layers tf.keras.layers.Conv2DTranspose() to</span>
<span style="color: #BA2121; font-style: italic">    produce an image from a random seed. We start with a Dense layer taking this</span>
<span style="color: #BA2121; font-style: italic">    random sample as an input and subsequently upsample through multiple</span>
<span style="color: #BA2121; font-style: italic">    convolutional layers.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    <span style="color: #408080; font-style: italic"># we define our model</span>
    model <span style="color: #666666">=</span> tf<span style="color: #666666">.</span>keras<span style="color: #666666">.</span>Sequential()


    <span style="color: #408080; font-style: italic"># adding our input layer. Dense means that every neuron is connected and</span>
    <span style="color: #408080; font-style: italic"># the input shape is the shape of our random noise. The units need to match</span>
    <span style="color: #408080; font-style: italic"># in some sense the upsampling strides to reach our desired output shape.</span>
    <span style="color: #408080; font-style: italic"># we are using 100 random numbers as our seed</span>
    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>Dense(units<span style="color: #666666">=7*7*</span>BATCH_SIZE,
                           use_bias<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>,
                           input_shape<span style="color: #666666">=</span>(<span style="color: #666666">100</span>, )))
    <span style="color: #408080; font-style: italic"># we normalize the output form the Dense layer</span>
    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>BatchNormalization())
    <span style="color: #408080; font-style: italic"># and add an activation function to our &#39;layer&#39;. LeakyReLU avoids vanishing</span>
    <span style="color: #408080; font-style: italic"># gradient problem</span>
    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>LeakyReLU())
    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>Reshape((<span style="color: #666666">7</span>, <span style="color: #666666">7</span>, BATCH_SIZE)))
    <span style="color: #008000; font-weight: bold">assert</span> model<span style="color: #666666">.</span>output_shape <span style="color: #666666">==</span> (<span style="color: #008000; font-weight: bold">None</span>, <span style="color: #666666">7</span>, <span style="color: #666666">7</span>, BATCH_SIZE)
    <span style="color: #408080; font-style: italic"># even though we just added four keras layers we think of everything above</span>
    <span style="color: #408080; font-style: italic"># as &#39;one&#39; layer</span>

    <span style="color: #408080; font-style: italic"># next we add our upscaling convolutional layers</span>
    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>Conv2DTranspose(filters<span style="color: #666666">=128</span>,
                                     kernel_size<span style="color: #666666">=</span>(<span style="color: #666666">5</span>, <span style="color: #666666">5</span>),
                                     strides<span style="color: #666666">=</span>(<span style="color: #666666">1</span>, <span style="color: #666666">1</span>),
                                     padding<span style="color: #666666">=</span><span style="color: #BA2121">&#39;same&#39;</span>,
                                     use_bias<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>))
    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>BatchNormalization())
    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>LeakyReLU())
    <span style="color: #008000; font-weight: bold">assert</span> model<span style="color: #666666">.</span>output_shape <span style="color: #666666">==</span> (<span style="color: #008000; font-weight: bold">None</span>, <span style="color: #666666">7</span>, <span style="color: #666666">7</span>, <span style="color: #666666">128</span>)

    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>Conv2DTranspose(filters<span style="color: #666666">=64</span>,
                                     kernel_size<span style="color: #666666">=</span>(<span style="color: #666666">5</span>, <span style="color: #666666">5</span>),
                                     strides<span style="color: #666666">=</span>(<span style="color: #666666">2</span>, <span style="color: #666666">2</span>),
                                     padding<span style="color: #666666">=</span><span style="color: #BA2121">&#39;same&#39;</span>,
                                     use_bias<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>))
    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>BatchNormalization())
    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>LeakyReLU())
    <span style="color: #008000; font-weight: bold">assert</span> model<span style="color: #666666">.</span>output_shape <span style="color: #666666">==</span> (<span style="color: #008000; font-weight: bold">None</span>, <span style="color: #666666">14</span>, <span style="color: #666666">14</span>, <span style="color: #666666">64</span>)

    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>Conv2DTranspose(filters<span style="color: #666666">=1</span>,
                                     kernel_size<span style="color: #666666">=</span>(<span style="color: #666666">5</span>, <span style="color: #666666">5</span>),
                                     strides<span style="color: #666666">=</span>(<span style="color: #666666">2</span>, <span style="color: #666666">2</span>),
                                     padding<span style="color: #666666">=</span><span style="color: #BA2121">&#39;same&#39;</span>,
                                     use_bias<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>,
                                     activation<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tanh&#39;</span>))
    <span style="color: #008000; font-weight: bold">assert</span> model<span style="color: #666666">.</span>output_shape <span style="color: #666666">==</span> (<span style="color: #008000; font-weight: bold">None</span>, <span style="color: #666666">28</span>, <span style="color: #666666">28</span>, <span style="color: #666666">1</span>)

    <span style="color: #008000; font-weight: bold">return</span> model
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>And there we have our 'simple' generator model. Now we move on to defining our
discriminator model \( d \), which is a convolutional neural network based image
classifier.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">discriminator_model</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    The discriminator is a convolutional neural network based image classifier</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    <span style="color: #408080; font-style: italic"># we define our model</span>
    model <span style="color: #666666">=</span> tf<span style="color: #666666">.</span>keras<span style="color: #666666">.</span>Sequential()
    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>Conv2D(filters<span style="color: #666666">=64</span>,
                            kernel_size<span style="color: #666666">=</span>(<span style="color: #666666">5</span>, <span style="color: #666666">5</span>),
                            strides<span style="color: #666666">=</span>(<span style="color: #666666">2</span>, <span style="color: #666666">2</span>),
                            padding<span style="color: #666666">=</span><span style="color: #BA2121">&#39;same&#39;</span>,
                            input_shape<span style="color: #666666">=</span>[<span style="color: #666666">28</span>, <span style="color: #666666">28</span>, <span style="color: #666666">1</span>]))
    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>LeakyReLU())
    <span style="color: #408080; font-style: italic"># adding a dropout layer as you do in conv-nets</span>
    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>Dropout(<span style="color: #666666">0.3</span>))


    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>Conv2D(filters<span style="color: #666666">=128</span>,
                            kernel_size<span style="color: #666666">=</span>(<span style="color: #666666">5</span>, <span style="color: #666666">5</span>),
                            strides<span style="color: #666666">=</span>(<span style="color: #666666">2</span>, <span style="color: #666666">2</span>),
                            padding<span style="color: #666666">=</span><span style="color: #BA2121">&#39;same&#39;</span>))
    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>LeakyReLU())
    <span style="color: #408080; font-style: italic"># adding a dropout layer as you do in conv-nets</span>
    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>Dropout(<span style="color: #666666">0.3</span>))

    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>Flatten())
    model<span style="color: #666666">.</span>add(layers<span style="color: #666666">.</span>Dense(<span style="color: #666666">1</span>))

    <span style="color: #008000; font-weight: bold">return</span> model
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Let us take a look at our models. <b>Note</b>: double click images for bigger view.</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">generator <span style="color: #666666">=</span> generator_model()
plot_model(generator, show_shapes<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>, rankdir<span style="color: #666666">=</span><span style="color: #BA2121">&#39;LR&#39;</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">discriminator <span style="color: #666666">=</span> discriminator_model()
plot_model(discriminator, show_shapes<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>, rankdir<span style="color: #666666">=</span><span style="color: #BA2121">&#39;LR&#39;</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Next we need a few helper objects we will use in training</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">cross_entropy <span style="color: #666666">=</span> tf<span style="color: #666666">.</span>keras<span style="color: #666666">.</span>losses<span style="color: #666666">.</span>BinaryCrossentropy(from_logits<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
generator_optimizer <span style="color: #666666">=</span> tf<span style="color: #666666">.</span>keras<span style="color: #666666">.</span>optimizers<span style="color: #666666">.</span>Adam(<span style="color: #666666">1e-4</span>)
discriminator_optimizer <span style="color: #666666">=</span> tf<span style="color: #666666">.</span>keras<span style="color: #666666">.</span>optimizers<span style="color: #666666">.</span>Adam(<span style="color: #666666">1e-4</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The first object, \( cross\_entropy \) is our loss function and the two others are
our optimizers. Notice we use the same learning rate for both \( g \) and \( d \). This
is because they need to improve their accuracy at approximately equal speeds to
get convergence (not necessarily exactly equal). Now we define our loss
functions
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">generator_loss</span>(fake_output):
    loss <span style="color: #666666">=</span> cross_entropy(tf<span style="color: #666666">.</span>ones_like(fake_output), fake_output)

    <span style="color: #008000; font-weight: bold">return</span> loss
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">discriminator_loss</span>(real_output, fake_output):
    real_loss <span style="color: #666666">=</span> cross_entropy(tf<span style="color: #666666">.</span>ones_like(real_output), real_output)
    fake_loss <span style="color: #666666">=</span> cross_entropy(tf<span style="color: #666666">.</span>zeros_liks(fake_output), fake_output)
    total_loss <span style="color: #666666">=</span> real_loss <span style="color: #666666">+</span> fake_loss

    <span style="color: #008000; font-weight: bold">return</span> total_loss
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Next we define a kind of seed to help us compare the learning process over
multiple training epochs.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">noise_dimension <span style="color: #666666">=</span> <span style="color: #666666">100</span>
n_examples_to_generate <span style="color: #666666">=</span> <span style="color: #666666">16</span>
seed_images <span style="color: #666666">=</span> tf<span style="color: #666666">.</span>random<span style="color: #666666">.</span>normal([n_examples_to_generate, noise_dimension])
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Now we have everything we need to define our training step, which we will apply
for every step in our training loop. Notice the @tf.function flag signifying
that the function is tensorflow 'compiled'. Removing this flag doubles the
computation time.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #AA22FF">@tf</span><span style="color: #666666">.</span>function
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">train_step</span>(images):
    noise <span style="color: #666666">=</span> tf<span style="color: #666666">.</span>random<span style="color: #666666">.</span>normal([BATCH_SIZE, noise_dimension])

    <span style="color: #008000; font-weight: bold">with</span> tf<span style="color: #666666">.</span>GradientTape() <span style="color: #008000; font-weight: bold">as</span> gen_tape, tf<span style="color: #666666">.</span>GradientTape() <span style="color: #008000; font-weight: bold">as</span> disc_tape:
        generated_images <span style="color: #666666">=</span> generator(noise, training<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)

        real_output <span style="color: #666666">=</span> discriminator(images, training<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
        fake_output <span style="color: #666666">=</span> discriminator(generated_images, training<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)

        gen_loss <span style="color: #666666">=</span> generator_loss(fake_output)
        disc_loss <span style="color: #666666">=</span> discriminator_loss(real_output, fake_output)

    gradients_of_generator <span style="color: #666666">=</span> gen_tape<span style="color: #666666">.</span>gradient(gen_loss,
                                            generator<span style="color: #666666">.</span>trainable_variables)
    gradients_of_discriminator <span style="color: #666666">=</span> disc_tape<span style="color: #666666">.</span>gradient(disc_loss,
                                            discriminator<span style="color: #666666">.</span>trainable_variables)
    generator_optimizer<span style="color: #666666">.</span>apply_gradients(<span style="color: #008000">zip</span>(gradients_of_generator,
                                            generator<span style="color: #666666">.</span>trainable_variables))
    discriminator_optimizer<span style="color: #666666">.</span>apply_gradients(<span style="color: #008000">zip</span>(gradients_of_discriminator,
                                            discriminator<span style="color: #666666">.</span>trainable_variables))

    <span style="color: #008000; font-weight: bold">return</span> gen_loss, disc_loss
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Next we define a helper function to produce an output over our training epochs
to see the predictive progression of our generator model. <b>Note</b>: I am including
this code here, but comment it out in the training loop.
</p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">generate_and_save_images</span>(model, epoch, test_input):
    <span style="color: #408080; font-style: italic"># we&#39;re making inferences here</span>
    predictions <span style="color: #666666">=</span> model(test_input, training<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>)

    fig <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>figure(figsize<span style="color: #666666">=</span>(<span style="color: #666666">4</span>, <span style="color: #666666">4</span>))

    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(predictions<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>]):
        plt<span style="color: #666666">.</span>subplot(<span style="color: #666666">4</span>, <span style="color: #666666">4</span>, i<span style="color: #666666">+1</span>)
        plt<span style="color: #666666">.</span>imshow(predictions[i, :, :, <span style="color: #666666">0</span>] <span style="color: #666666">*</span> <span style="color: #666666">127.5</span> <span style="color: #666666">+</span> <span style="color: #666666">127.5</span>, cmap<span style="color: #666666">=</span><span style="color: #BA2121">&#39;gray&#39;</span>)
        plt<span style="color: #666666">.</span>axis(<span style="color: #BA2121">&#39;off&#39;</span>)

    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">f&#39;./images_from_seed_images/image_at_epoch_</span><span style="color: #BB6688; font-weight: bold">{</span><span style="color: #008000">str</span>(epoch)<span style="color: #666666">.</span>zfill(<span style="color: #666666">3</span>)<span style="color: #BB6688; font-weight: bold">}</span><span style="color: #BA2121">.png&#39;</span>)
    plt<span style="color: #666666">.</span>close()
    <span style="color: #408080; font-style: italic">#plt.show()</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Setting up checkpoints to periodically save our model during training so that
everything is not lost even if the program were to somehow terminate while
training.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #408080; font-style: italic"># Setting up checkpoints to save model during training</span>
checkpoint_dir <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;./training_checkpoints&#39;</span>
checkpoint_prefix <span style="color: #666666">=</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>join(checkpoint_dir, <span style="color: #BA2121">&#39;ckpt&#39;</span>)
checkpoint <span style="color: #666666">=</span> tf<span style="color: #666666">.</span>train<span style="color: #666666">.</span>Checkpoint(generator_optimizer<span style="color: #666666">=</span>generator_optimizer,
                            discriminator_optimizer<span style="color: #666666">=</span>discriminator_optimizer,
                            generator<span style="color: #666666">=</span>generator,
                            discriminator<span style="color: #666666">=</span>discriminator)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Now we define our training loop</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">train</span>(dataset, epochs):
    generator_loss_list <span style="color: #666666">=</span> []
    discriminator_loss_list <span style="color: #666666">=</span> []

    <span style="color: #008000; font-weight: bold">for</span> epoch <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(epochs):
        start <span style="color: #666666">=</span> time<span style="color: #666666">.</span>time()

        <span style="color: #008000; font-weight: bold">for</span> image_batch <span style="color: #AA22FF; font-weight: bold">in</span> dataset:
            gen_loss, disc_loss <span style="color: #666666">=</span> train_step(image_batch)
            generator_loss_list<span style="color: #666666">.</span>append(gen_loss<span style="color: #666666">.</span>numpy())
            discriminator_loss_list<span style="color: #666666">.</span>append(disc_loss<span style="color: #666666">.</span>numpy())

        <span style="color: #408080; font-style: italic">#generate_and_save_images(generator, epoch + 1, seed_images)</span>

        <span style="color: #008000; font-weight: bold">if</span> (epoch <span style="color: #666666">+</span> <span style="color: #666666">1</span>) <span style="color: #666666">%</span> <span style="color: #666666">15</span> <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            checkpoint<span style="color: #666666">.</span>save(file_prefix<span style="color: #666666">=</span>checkpoint_prefix)

        <span style="color: #008000">print</span>(<span style="color: #BA2121">f&#39;Time for epoch </span><span style="color: #BB6688; font-weight: bold">{</span>epoch<span style="color: #BB6688; font-weight: bold">}</span><span style="color: #BA2121"> is </span><span style="color: #BB6688; font-weight: bold">{</span>time<span style="color: #666666">.</span>time() <span style="color: #666666">-</span> start<span style="color: #BB6688; font-weight: bold">}</span><span style="color: #BA2121">&#39;</span>)

    <span style="color: #408080; font-style: italic">#generate_and_save_images(generator, epochs, seed_images)</span>

    loss_file <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;./data/lossfile.txt&#39;</span>
    <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(loss_file, <span style="color: #BA2121">&#39;w&#39;</span>) <span style="color: #008000; font-weight: bold">as</span> outfile:
        outfile<span style="color: #666666">.</span>write(<span style="color: #008000">str</span>(generator_loss_list))
        outfile<span style="color: #666666">.</span>write(<span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>)
        outfile<span style="color: #666666">.</span>write(<span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>)
        outfile<span style="color: #666666">.</span>write(<span style="color: #008000">str</span>(discriminator_loss_list))
        outfile<span style="color: #666666">.</span>write(<span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>)
        outfile<span style="color: #666666">.</span>write(<span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>To train simply call this function. <b>Warning</b>: this might take a long time so
there is a folder of a pretrained network already included in the repository.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">train(train_dataset, EPOCHS)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>And here is the result of training our model for 100 epochs</p>

<embed src="images_from_seed_images/generation.gif"  autoplay="false" loop="true"></embed>
<p><em></em></p>

<p>Now to avoid having to train and everything, which will take a while depending
on your computer setup we now load in the model which produced the above gif.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">checkpoint<span style="color: #666666">.</span>restore(tf<span style="color: #666666">.</span>train<span style="color: #666666">.</span>latest_checkpoint(checkpoint_dir))
restored_generator <span style="color: #666666">=</span> checkpoint<span style="color: #666666">.</span>generator
restored_discriminator <span style="color: #666666">=</span> checkpoint<span style="color: #666666">.</span>discriminator

<span style="color: #008000">print</span>(restored_generator)
<span style="color: #008000">print</span>(restored_discriminator)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
<h2 id="exploring-the-latent-space" class="anchor">Exploring the Latent Space </h2>

<p>So we have successfully loaded in our latest model. Let us now play around a bit
and see what kind of things we can learn about this model. Our generator takes
an array of 100 numbers. One idea can be to try to systematically change our
input. Let us try and see what we get
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">generate_latent_points</span>(number<span style="color: #666666">=100</span>, scale_means<span style="color: #666666">=1</span>, scale_stds<span style="color: #666666">=1</span>):
    latent_dim <span style="color: #666666">=</span> <span style="color: #666666">100</span>
    means <span style="color: #666666">=</span> scale_means <span style="color: #666666">*</span> tf<span style="color: #666666">.</span>linspace(<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>, num<span style="color: #666666">=</span>latent_dim)
    stds <span style="color: #666666">=</span> scale_stds <span style="color: #666666">*</span> tf<span style="color: #666666">.</span>linspace(<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>, num<span style="color: #666666">=</span>latent_dim)
    latent_space_value_range <span style="color: #666666">=</span> tf<span style="color: #666666">.</span>random<span style="color: #666666">.</span>normal([number, number],
                                                means,
                                                stds,
                                                dtype<span style="color: #666666">=</span>tf<span style="color: #666666">.</span>float64)

    <span style="color: #008000; font-weight: bold">return</span> latent_space_value_range

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">generate_images</span>(latent_points):
    <span style="color: #408080; font-style: italic"># notice we set training to false because we are making inferences</span>
    generated_images <span style="color: #666666">=</span> restored_generator(latent_space_value_range,
                                          training<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>)

    <span style="color: #008000; font-weight: bold">return</span> generated_images
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plot_result</span>(generated_images, number):
    <span style="color: #408080; font-style: italic"># obviously this assumes sqrt number is an int</span>
    fig, axs <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>subplots(<span style="color: #008000">int</span>(np<span style="color: #666666">.</span>sqrt(number)), <span style="color: #008000">int</span>(np<span style="color: #666666">.</span>sqrt(number)),
                            figsize<span style="color: #666666">=</span>(<span style="color: #666666">10</span>, <span style="color: #666666">10</span>))

    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">int</span>(np<span style="color: #666666">.</span>sqrt(number))):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">int</span>(np<span style="color: #666666">.</span>sqrt(number))):
            axs[i, j]<span style="color: #666666">.</span>imshow(generated_images[i<span style="color: #666666">*</span>j], cmap<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Greys&#39;</span>)
            axs[i, j]<span style="color: #666666">.</span>axis(<span style="color: #BA2121">&#39;off&#39;</span>)

    plt<span style="color: #666666">.</span>show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">generated_images <span style="color: #666666">=</span> generate_images(generate_latent_points())
plot_result(generated_images, number)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Interesting! We see that the generator generates images that look like MNIST
numbers: \( 1, 4, 7, 9 \). Let's try to tweak it a bit more to see if we are able
to generate a similar plot where we generate every MNIST number. Let us now try
to 'move' a bit around in the latent space. <b>Note</b>: decrease the plot number if
these following cells take too long to run on your computer.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">plot_number <span style="color: #666666">=</span> <span style="color: #666666">225</span>

generated_images <span style="color: #666666">=</span> generate_images(generate_latent_points(number<span style="color: #666666">=</span>plot_number,
                                                          scale_means<span style="color: #666666">=5</span>,
                                                          scale_stds<span style="color: #666666">=1</span>))
plot_result(generated_images, plot_number)

generated_images <span style="color: #666666">=</span> generate_images(generate_latent_points(number<span style="color: #666666">=</span>plot_number,
                                                          scale_means<span style="color: #666666">=-5</span>,
                                                          scale_stds<span style="color: #666666">=1</span>))
plot_result(generated_images, plot_number)

generated_images <span style="color: #666666">=</span> generate_images(generate_latent_points(number<span style="color: #666666">=</span>plot_number,
                                                          scale_means<span style="color: #666666">=1</span>,
                                                          scale_stds<span style="color: #666666">=5</span>))
plot_result(generated_images, plot_number)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Again, we have found something interesting. <em>Moving</em> around using our means
takes us from digit to digit, while <em>moving</em> around using our standard
deviations seem to increase the number of different digits! In the last image
above, we can barely make out every MNIST digit. Let us make on last plot using
this information by upping the standard deviation of our Gaussian noises.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">plot_number <span style="color: #666666">=</span> <span style="color: #666666">400</span>
generated_images <span style="color: #666666">=</span> generate_images(generate_latent_points(number<span style="color: #666666">=</span>plot_number,
                                                          scale_means<span style="color: #666666">=1</span>,
                                                          scale_stds<span style="color: #666666">=10</span>))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>A pretty cool result! We see that our generator indeed has learned a
distribution which qualitatively looks a whole lot like the MNIST dataset.
</p>

<!-- ------------------- end of main content --------------- -->
</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<!-- Bootstrap footer
<footer>
<a href="https://..."><img width="250" align=right src="https://..."></a>
</footer>
-->
<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2024, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>
</body>
</html>

