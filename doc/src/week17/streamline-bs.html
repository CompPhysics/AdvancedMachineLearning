<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html streamline.do.txt --html_style=bootstrap --pygments_html_style=default --html_admon=bootstrap_panel --html_output=streamline-bs --no_mako
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Mathematics of discriminative and generative deep learning, from deep neural networks to diffusion models">
<title>Mathematics of discriminative and generative deep learning, from deep neural networks to diffusion models</title>
<!-- Bootstrap style: bootstrap -->
<!-- doconce format html streamline.do.txt --html_style=bootstrap --pygments_html_style=default --html_admon=bootstrap_panel --html_output=streamline-bs --no_mako -->
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->
<style type="text/css">
/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:50px;      /* fixed header height for style bootstrap */
  margin:-50px 0 0; /* negative fixed header height */
}
</style>
</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Types of machine learning',
               2,
               None,
               'types-of-machine-learning'),
              ('Main categories', 2, None, 'main-categories'),
              ('Machine learning. A simple perspective on the interface '
               'between ML and Physics',
               2,
               None,
               'machine-learning-a-simple-perspective-on-the-interface-between-ml-and-physics'),
              ('ML in Nuclear  Physics (or any field in physics)',
               2,
               None,
               'ml-in-nuclear-physics-or-any-field-in-physics'),
              ('The plethora  of machine learning algorithms/methods',
               2,
               None,
               'the-plethora-of-machine-learning-algorithms-methods'),
              ('What Is Generative Modeling?',
               2,
               None,
               'what-is-generative-modeling'),
              ('Example of generative modeling, "taken from Generative Deep '
               'Learning by David '
               'Foster":"https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html"',
               2,
               None,
               'example-of-generative-modeling-taken-from-generative-deep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html'),
              ('Generative Modeling', 2, None, 'generative-modeling'),
              ('Generative Versus Discriminative Modeling',
               2,
               None,
               'generative-versus-discriminative-modeling'),
              ('Example of discriminative modeling, "taken from Generative '
               'Deeep Learning by David '
               'Foster":"https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html"',
               2,
               None,
               'example-of-discriminative-modeling-taken-from-generative-deeep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html'),
              ('Discriminative Modeling', 2, None, 'discriminative-modeling'),
              ('Taxonomy of generative deep learning, "taken from Generative '
               'Deep Learning by David '
               'Foster":"https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html"',
               2,
               None,
               'taxonomy-of-generative-deep-learning-taken-from-generative-deep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html'),
              ('Good books with hands-on material and codes',
               2,
               None,
               'good-books-with-hands-on-material-and-codes'),
              ('More references', 2, None, 'more-references'),
              ('What are the basic Machine Learning ingredients?',
               2,
               None,
               'what-are-the-basic-machine-learning-ingredients'),
              ('Low-level machine learning, the family of ordinary least '
               'squares methods',
               2,
               None,
               'low-level-machine-learning-the-family-of-ordinary-least-squares-methods'),
              ('Setting up the equations', 2, None, 'setting-up-the-equations'),
              ('The objective/cost/loss function',
               2,
               None,
               'the-objective-cost-loss-function'),
              ('Training solution', 2, None, 'training-solution'),
              ('Ridge and LASSO Regression',
               2,
               None,
               'ridge-and-lasso-regression'),
              ('From OLS to Ridge and Lasso',
               2,
               None,
               'from-ols-to-ridge-and-lasso'),
              ('Lasso regression', 2, None, 'lasso-regression'),
              ('Selected references', 2, None, 'selected-references'),
              ('Setting up the basic equations for neural networks',
               2,
               None,
               'setting-up-the-basic-equations-for-neural-networks'),
              ('Overarching view of a neural network',
               2,
               None,
               'overarching-view-of-a-neural-network'),
              ('Illustration of a single perceptron model and a multilayer '
               'FFNN',
               2,
               None,
               'illustration-of-a-single-perceptron-model-and-a-multilayer-ffnn'),
              ('The optimization problem', 2, None, 'the-optimization-problem'),
              ('Weights and biases', 2, None, 'weights-and-biases'),
              ('Other ingredients of a neural network',
               2,
               None,
               'other-ingredients-of-a-neural-network'),
              ('Other parameters', 2, None, 'other-parameters'),
              ('Why Feed Forward Neural Networks (FFNN)?',
               2,
               None,
               'why-feed-forward-neural-networks-ffnn'),
              ('Universal approximation theorem',
               2,
               None,
               'universal-approximation-theorem'),
              ('The approximation theorem in words',
               2,
               None,
               'the-approximation-theorem-in-words'),
              ('More on the general approximation theorem',
               2,
               None,
               'more-on-the-general-approximation-theorem'),
              ('Class of functions we can approximate',
               2,
               None,
               'class-of-functions-we-can-approximate'),
              ('Simple example, fitting nuclear masses',
               2,
               None,
               'simple-example-fitting-nuclear-masses'),
              ('First network example, simple percepetron with one input',
               2,
               None,
               'first-network-example-simple-percepetron-with-one-input'),
              ('Optimizing the parameters',
               2,
               None,
               'optimizing-the-parameters'),
              ('Implementing the simple perceptron model',
               2,
               None,
               'implementing-the-simple-perceptron-model'),
              ('Exercise 1: Extensions to the above code',
               2,
               None,
               'exercise-1-extensions-to-the-above-code'),
              ('Adding a hidden layer', 2, None, 'adding-a-hidden-layer'),
              ('The derivatives', 2, None, 'the-derivatives'),
              ('Important observations', 2, None, 'important-observations'),
              ('The training', 2, None, 'the-training'),
              ('Code example', 2, None, 'code-example'),
              ('Exercise 2: Including more data',
               2,
               None,
               'exercise-2-including-more-data'),
              ('Simple neural network and the  back propagation equations',
               2,
               None,
               'simple-neural-network-and-the-back-propagation-equations'),
              ('The ouput layer', 2, None, 'the-ouput-layer'),
              ('Compact expressions', 2, None, 'compact-expressions'),
              ('Output layer', 2, None, 'output-layer'),
              ('Explicit derivatives', 2, None, 'explicit-derivatives'),
              ('Derivatives of the hidden layer',
               2,
               None,
               'derivatives-of-the-hidden-layer'),
              ('Final expression', 2, None, 'final-expression'),
              ('Completing the list', 2, None, 'completing-the-list'),
              ('Final expressions for the biases of the hidden layer',
               2,
               None,
               'final-expressions-for-the-biases-of-the-hidden-layer'),
              ('Gradient expressions', 2, None, 'gradient-expressions'),
              ('Exercise 3: Extended program',
               2,
               None,
               'exercise-3-extended-program'),
              ('Getting serious, the  back propagation equations for a neural '
               'network',
               2,
               None,
               'getting-serious-the-back-propagation-equations-for-a-neural-network'),
              ('Analyzing the last results',
               2,
               None,
               'analyzing-the-last-results'),
              ('More considerations', 2, None, 'more-considerations'),
              ('Derivatives in terms of $z_j^L$',
               2,
               None,
               'derivatives-in-terms-of-z-j-l'),
              ('Bringing it together', 2, None, 'bringing-it-together'),
              ('Final back propagating equation',
               2,
               None,
               'final-back-propagating-equation'),
              ('Using the chain rule and summing over all $k$ entries',
               2,
               None,
               'using-the-chain-rule-and-summing-over-all-k-entries'),
              ('Setting up the back propagation algorithm',
               2,
               None,
               'setting-up-the-back-propagation-algorithm'),
              ('Setting up the back propagation algorithm, part 2',
               2,
               None,
               'setting-up-the-back-propagation-algorithm-part-2'),
              ('Setting up the Back propagation algorithm, part 3',
               2,
               None,
               'setting-up-the-back-propagation-algorithm-part-3'),
              ('Updating the gradients', 2, None, 'updating-the-gradients'),
              ('Essential elements of generative models',
               2,
               None,
               'essential-elements-of-generative-models'),
              ('Energy models', 2, None, 'energy-models'),
              ('Probability model', 2, None, 'probability-model'),
              ('Marginal and conditional probabilities',
               2,
               None,
               'marginal-and-conditional-probabilities'),
              ('Change of notation', 2, None, 'change-of-notation'),
              ('Optimization problem', 2, None, 'optimization-problem'),
              ('Further simplifications', 2, None, 'further-simplifications'),
              ('Optimizing the logarithm instead',
               2,
               None,
               'optimizing-the-logarithm-instead'),
              ('Expression for the gradients',
               2,
               None,
               'expression-for-the-gradients'),
              ('The derivative of the partition function',
               2,
               None,
               'the-derivative-of-the-partition-function'),
              ('Explicit expression for the derivative',
               2,
               None,
               'explicit-expression-for-the-derivative'),
              ('Final expression', 2, None, 'final-expression'),
              ('Introducing the energy model',
               2,
               None,
               'introducing-the-energy-model'),
              ('More compact notation', 2, None, 'more-compact-notation'),
              ('Anticipating results to be derived',
               2,
               None,
               'anticipating-results-to-be-derived'),
              ('Boltzmann Machines, marginal and conditional probabilities',
               2,
               None,
               'boltzmann-machines-marginal-and-conditional-probabilities'),
              ('Generative and discriminative models',
               2,
               None,
               'generative-and-discriminative-models'),
              ('Basics of the Boltzmann machine',
               2,
               None,
               'basics-of-the-boltzmann-machine'),
              ('More about the basics', 2, None, 'more-about-the-basics'),
              ('Difficult to train', 2, None, 'difficult-to-train'),
              ('The network layers', 2, None, 'the-network-layers'),
              ('Goal of hidden layer', 2, None, 'goal-of-hidden-layer'),
              ('The parameters', 2, None, 'the-parameters'),
              ('Joint distribution', 2, None, 'joint-distribution'),
              ('Network Elements, the energy function',
               2,
               None,
               'network-elements-the-energy-function'),
              ('Defining different types of RBMs',
               2,
               None,
               'defining-different-types-of-rbms'),
              ('Gaussian-binary RBM', 2, None, 'gaussian-binary-rbm'),
              ('Code for RBMs using PyTorch',
               2,
               None,
               'code-for-rbms-using-pytorch'),
              ('Energy-based models and Langevin sampling',
               2,
               None,
               'energy-based-models-and-langevin-sampling'),
              ('Tensor-flow examples', 2, None, 'tensor-flow-examples'),
              ('Kullback-Leibler divergence',
               2,
               None,
               'kullback-leibler-divergence'),
              ('Jensen-Shannon divergence',
               2,
               None,
               'jensen-shannon-divergence'),
              ('Generative model,  basic overview (Borrowed from Rashcka et '
               'al)',
               2,
               None,
               'generative-model-basic-overview-borrowed-from-rashcka-et-al'),
              ('Reminder on VAEs', 2, None, 'reminder-on-vaes'),
              ('Evidence Lower Bound', 2, None, 'evidence-lower-bound'),
              ('ELBO equations', 2, None, 'elbo-equations'),
              ('Introducing the encoder function',
               2,
               None,
               'introducing-the-encoder-function'),
              ('ELBO', 2, None, 'elbo'),
              ('Analysis', 2, None, 'analysis'),
              ('The VAE', 2, None, 'the-vae'),
              ('Dissecting the equations', 2, None, 'dissecting-the-equations'),
              ('Bottlenecking distribution',
               2,
               None,
               'bottlenecking-distribution'),
              ('Decoder and encoder', 2, None, 'decoder-and-encoder'),
              ('Defining feature of VAEs', 2, None, 'defining-feature-of-vaes'),
              ('Analytical evaluation', 2, None, 'analytical-evaluation'),
              ('Reparameterization trick', 2, None, 'reparameterization-trick'),
              ('Actual implementation', 2, None, 'actual-implementation'),
              ('Interpretation', 2, None, 'interpretation'),
              ('Deterministic function', 2, None, 'deterministic-function'),
              ('After training', 2, None, 'after-training')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="streamline-bs.html">Mathematics of discriminative and generative deep learning, from deep neural networks to diffusion models</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#types-of-machine-learning" style="font-size: 80%;">Types of machine learning</a></li>
     <!-- navigation toc: --> <li><a href="#main-categories" style="font-size: 80%;">Main categories</a></li>
     <!-- navigation toc: --> <li><a href="#machine-learning-a-simple-perspective-on-the-interface-between-ml-and-physics" style="font-size: 80%;">Machine learning. A simple perspective on the interface between ML and Physics</a></li>
     <!-- navigation toc: --> <li><a href="#ml-in-nuclear-physics-or-any-field-in-physics" style="font-size: 80%;">ML in Nuclear  Physics (or any field in physics)</a></li>
     <!-- navigation toc: --> <li><a href="#the-plethora-of-machine-learning-algorithms-methods" style="font-size: 80%;">The plethora  of machine learning algorithms/methods</a></li>
     <!-- navigation toc: --> <li><a href="#what-is-generative-modeling" style="font-size: 80%;">What Is Generative Modeling?</a></li>
     <!-- navigation toc: --> <li><a href="#example-of-generative-modeling-taken-from-generative-deep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html" style="font-size: 80%;">Example of generative modeling, "taken from Generative Deep Learning by David Foster":"https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html"</a></li>
     <!-- navigation toc: --> <li><a href="#generative-modeling" style="font-size: 80%;">Generative Modeling</a></li>
     <!-- navigation toc: --> <li><a href="#generative-versus-discriminative-modeling" style="font-size: 80%;">Generative Versus Discriminative Modeling</a></li>
     <!-- navigation toc: --> <li><a href="#example-of-discriminative-modeling-taken-from-generative-deeep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html" style="font-size: 80%;">Example of discriminative modeling, "taken from Generative Deeep Learning by David Foster":"https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html"</a></li>
     <!-- navigation toc: --> <li><a href="#discriminative-modeling" style="font-size: 80%;">Discriminative Modeling</a></li>
     <!-- navigation toc: --> <li><a href="#taxonomy-of-generative-deep-learning-taken-from-generative-deep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html" style="font-size: 80%;">Taxonomy of generative deep learning, "taken from Generative Deep Learning by David Foster":"https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html"</a></li>
     <!-- navigation toc: --> <li><a href="#good-books-with-hands-on-material-and-codes" style="font-size: 80%;">Good books with hands-on material and codes</a></li>
     <!-- navigation toc: --> <li><a href="#more-references" style="font-size: 80%;">More references</a></li>
     <!-- navigation toc: --> <li><a href="#what-are-the-basic-machine-learning-ingredients" style="font-size: 80%;">What are the basic Machine Learning ingredients?</a></li>
     <!-- navigation toc: --> <li><a href="#low-level-machine-learning-the-family-of-ordinary-least-squares-methods" style="font-size: 80%;">Low-level machine learning, the family of ordinary least squares methods</a></li>
     <!-- navigation toc: --> <li><a href="#setting-up-the-equations" style="font-size: 80%;">Setting up the equations</a></li>
     <!-- navigation toc: --> <li><a href="#the-objective-cost-loss-function" style="font-size: 80%;">The objective/cost/loss function</a></li>
     <!-- navigation toc: --> <li><a href="#training-solution" style="font-size: 80%;">Training solution</a></li>
     <!-- navigation toc: --> <li><a href="#ridge-and-lasso-regression" style="font-size: 80%;">Ridge and LASSO Regression</a></li>
     <!-- navigation toc: --> <li><a href="#from-ols-to-ridge-and-lasso" style="font-size: 80%;">From OLS to Ridge and Lasso</a></li>
     <!-- navigation toc: --> <li><a href="#lasso-regression" style="font-size: 80%;">Lasso regression</a></li>
     <!-- navigation toc: --> <li><a href="#selected-references" style="font-size: 80%;">Selected references</a></li>
     <!-- navigation toc: --> <li><a href="#setting-up-the-basic-equations-for-neural-networks" style="font-size: 80%;">Setting up the basic equations for neural networks</a></li>
     <!-- navigation toc: --> <li><a href="#overarching-view-of-a-neural-network" style="font-size: 80%;">Overarching view of a neural network</a></li>
     <!-- navigation toc: --> <li><a href="#illustration-of-a-single-perceptron-model-and-a-multilayer-ffnn" style="font-size: 80%;">Illustration of a single perceptron model and a multilayer FFNN</a></li>
     <!-- navigation toc: --> <li><a href="#the-optimization-problem" style="font-size: 80%;">The optimization problem</a></li>
     <!-- navigation toc: --> <li><a href="#weights-and-biases" style="font-size: 80%;">Weights and biases</a></li>
     <!-- navigation toc: --> <li><a href="#other-ingredients-of-a-neural-network" style="font-size: 80%;">Other ingredients of a neural network</a></li>
     <!-- navigation toc: --> <li><a href="#other-parameters" style="font-size: 80%;">Other parameters</a></li>
     <!-- navigation toc: --> <li><a href="#why-feed-forward-neural-networks-ffnn" style="font-size: 80%;">Why Feed Forward Neural Networks (FFNN)?</a></li>
     <!-- navigation toc: --> <li><a href="#universal-approximation-theorem" style="font-size: 80%;">Universal approximation theorem</a></li>
     <!-- navigation toc: --> <li><a href="#the-approximation-theorem-in-words" style="font-size: 80%;">The approximation theorem in words</a></li>
     <!-- navigation toc: --> <li><a href="#more-on-the-general-approximation-theorem" style="font-size: 80%;">More on the general approximation theorem</a></li>
     <!-- navigation toc: --> <li><a href="#class-of-functions-we-can-approximate" style="font-size: 80%;">Class of functions we can approximate</a></li>
     <!-- navigation toc: --> <li><a href="#simple-example-fitting-nuclear-masses" style="font-size: 80%;">Simple example, fitting nuclear masses</a></li>
     <!-- navigation toc: --> <li><a href="#first-network-example-simple-percepetron-with-one-input" style="font-size: 80%;">First network example, simple percepetron with one input</a></li>
     <!-- navigation toc: --> <li><a href="#optimizing-the-parameters" style="font-size: 80%;">Optimizing the parameters</a></li>
     <!-- navigation toc: --> <li><a href="#implementing-the-simple-perceptron-model" style="font-size: 80%;">Implementing the simple perceptron model</a></li>
     <!-- navigation toc: --> <li><a href="#exercise-1-extensions-to-the-above-code" style="font-size: 80%;">Exercise 1: Extensions to the above code</a></li>
     <!-- navigation toc: --> <li><a href="#adding-a-hidden-layer" style="font-size: 80%;">Adding a hidden layer</a></li>
     <!-- navigation toc: --> <li><a href="#the-derivatives" style="font-size: 80%;">The derivatives</a></li>
     <!-- navigation toc: --> <li><a href="#important-observations" style="font-size: 80%;">Important observations</a></li>
     <!-- navigation toc: --> <li><a href="#the-training" style="font-size: 80%;">The training</a></li>
     <!-- navigation toc: --> <li><a href="#code-example" style="font-size: 80%;">Code example</a></li>
     <!-- navigation toc: --> <li><a href="#exercise-2-including-more-data" style="font-size: 80%;">Exercise 2: Including more data</a></li>
     <!-- navigation toc: --> <li><a href="#simple-neural-network-and-the-back-propagation-equations" style="font-size: 80%;">Simple neural network and the  back propagation equations</a></li>
     <!-- navigation toc: --> <li><a href="#the-ouput-layer" style="font-size: 80%;">The ouput layer</a></li>
     <!-- navigation toc: --> <li><a href="#compact-expressions" style="font-size: 80%;">Compact expressions</a></li>
     <!-- navigation toc: --> <li><a href="#output-layer" style="font-size: 80%;">Output layer</a></li>
     <!-- navigation toc: --> <li><a href="#explicit-derivatives" style="font-size: 80%;">Explicit derivatives</a></li>
     <!-- navigation toc: --> <li><a href="#derivatives-of-the-hidden-layer" style="font-size: 80%;">Derivatives of the hidden layer</a></li>
     <!-- navigation toc: --> <li><a href="#final-expression" style="font-size: 80%;">Final expression</a></li>
     <!-- navigation toc: --> <li><a href="#completing-the-list" style="font-size: 80%;">Completing the list</a></li>
     <!-- navigation toc: --> <li><a href="#final-expressions-for-the-biases-of-the-hidden-layer" style="font-size: 80%;">Final expressions for the biases of the hidden layer</a></li>
     <!-- navigation toc: --> <li><a href="#gradient-expressions" style="font-size: 80%;">Gradient expressions</a></li>
     <!-- navigation toc: --> <li><a href="#exercise-3-extended-program" style="font-size: 80%;">Exercise 3: Extended program</a></li>
     <!-- navigation toc: --> <li><a href="#getting-serious-the-back-propagation-equations-for-a-neural-network" style="font-size: 80%;">Getting serious, the  back propagation equations for a neural network</a></li>
     <!-- navigation toc: --> <li><a href="#analyzing-the-last-results" style="font-size: 80%;">Analyzing the last results</a></li>
     <!-- navigation toc: --> <li><a href="#more-considerations" style="font-size: 80%;">More considerations</a></li>
     <!-- navigation toc: --> <li><a href="#derivatives-in-terms-of-z-j-l" style="font-size: 80%;">Derivatives in terms of \( z_j^L \)</a></li>
     <!-- navigation toc: --> <li><a href="#bringing-it-together" style="font-size: 80%;">Bringing it together</a></li>
     <!-- navigation toc: --> <li><a href="#final-back-propagating-equation" style="font-size: 80%;">Final back propagating equation</a></li>
     <!-- navigation toc: --> <li><a href="#using-the-chain-rule-and-summing-over-all-k-entries" style="font-size: 80%;">Using the chain rule and summing over all \( k \) entries</a></li>
     <!-- navigation toc: --> <li><a href="#setting-up-the-back-propagation-algorithm" style="font-size: 80%;">Setting up the back propagation algorithm</a></li>
     <!-- navigation toc: --> <li><a href="#setting-up-the-back-propagation-algorithm-part-2" style="font-size: 80%;">Setting up the back propagation algorithm, part 2</a></li>
     <!-- navigation toc: --> <li><a href="#setting-up-the-back-propagation-algorithm-part-3" style="font-size: 80%;">Setting up the Back propagation algorithm, part 3</a></li>
     <!-- navigation toc: --> <li><a href="#updating-the-gradients" style="font-size: 80%;">Updating the gradients</a></li>
     <!-- navigation toc: --> <li><a href="#essential-elements-of-generative-models" style="font-size: 80%;">Essential elements of generative models</a></li>
     <!-- navigation toc: --> <li><a href="#energy-models" style="font-size: 80%;">Energy models</a></li>
     <!-- navigation toc: --> <li><a href="#probability-model" style="font-size: 80%;">Probability model</a></li>
     <!-- navigation toc: --> <li><a href="#marginal-and-conditional-probabilities" style="font-size: 80%;">Marginal and conditional probabilities</a></li>
     <!-- navigation toc: --> <li><a href="#change-of-notation" style="font-size: 80%;">Change of notation</a></li>
     <!-- navigation toc: --> <li><a href="#optimization-problem" style="font-size: 80%;">Optimization problem</a></li>
     <!-- navigation toc: --> <li><a href="#further-simplifications" style="font-size: 80%;">Further simplifications</a></li>
     <!-- navigation toc: --> <li><a href="#optimizing-the-logarithm-instead" style="font-size: 80%;">Optimizing the logarithm instead</a></li>
     <!-- navigation toc: --> <li><a href="#expression-for-the-gradients" style="font-size: 80%;">Expression for the gradients</a></li>
     <!-- navigation toc: --> <li><a href="#the-derivative-of-the-partition-function" style="font-size: 80%;">The derivative of the partition function</a></li>
     <!-- navigation toc: --> <li><a href="#explicit-expression-for-the-derivative" style="font-size: 80%;">Explicit expression for the derivative</a></li>
     <!-- navigation toc: --> <li><a href="#final-expression" style="font-size: 80%;">Final expression</a></li>
     <!-- navigation toc: --> <li><a href="#introducing-the-energy-model" style="font-size: 80%;">Introducing the energy model</a></li>
     <!-- navigation toc: --> <li><a href="#more-compact-notation" style="font-size: 80%;">More compact notation</a></li>
     <!-- navigation toc: --> <li><a href="#anticipating-results-to-be-derived" style="font-size: 80%;">Anticipating results to be derived</a></li>
     <!-- navigation toc: --> <li><a href="#boltzmann-machines-marginal-and-conditional-probabilities" style="font-size: 80%;">Boltzmann Machines, marginal and conditional probabilities</a></li>
     <!-- navigation toc: --> <li><a href="#generative-and-discriminative-models" style="font-size: 80%;">Generative and discriminative models</a></li>
     <!-- navigation toc: --> <li><a href="#basics-of-the-boltzmann-machine" style="font-size: 80%;">Basics of the Boltzmann machine</a></li>
     <!-- navigation toc: --> <li><a href="#more-about-the-basics" style="font-size: 80%;">More about the basics</a></li>
     <!-- navigation toc: --> <li><a href="#difficult-to-train" style="font-size: 80%;">Difficult to train</a></li>
     <!-- navigation toc: --> <li><a href="#the-network-layers" style="font-size: 80%;">The network layers</a></li>
     <!-- navigation toc: --> <li><a href="#goal-of-hidden-layer" style="font-size: 80%;">Goal of hidden layer</a></li>
     <!-- navigation toc: --> <li><a href="#the-parameters" style="font-size: 80%;">The parameters</a></li>
     <!-- navigation toc: --> <li><a href="#joint-distribution" style="font-size: 80%;">Joint distribution</a></li>
     <!-- navigation toc: --> <li><a href="#network-elements-the-energy-function" style="font-size: 80%;">Network Elements, the energy function</a></li>
     <!-- navigation toc: --> <li><a href="#defining-different-types-of-rbms" style="font-size: 80%;">Defining different types of RBMs</a></li>
     <!-- navigation toc: --> <li><a href="#gaussian-binary-rbm" style="font-size: 80%;">Gaussian-binary RBM</a></li>
     <!-- navigation toc: --> <li><a href="#code-for-rbms-using-pytorch" style="font-size: 80%;">Code for RBMs using PyTorch</a></li>
     <!-- navigation toc: --> <li><a href="#energy-based-models-and-langevin-sampling" style="font-size: 80%;">Energy-based models and Langevin sampling</a></li>
     <!-- navigation toc: --> <li><a href="#tensor-flow-examples" style="font-size: 80%;">Tensor-flow examples</a></li>
     <!-- navigation toc: --> <li><a href="#kullback-leibler-divergence" style="font-size: 80%;">Kullback-Leibler divergence</a></li>
     <!-- navigation toc: --> <li><a href="#jensen-shannon-divergence" style="font-size: 80%;">Jensen-Shannon divergence</a></li>
     <!-- navigation toc: --> <li><a href="#generative-model-basic-overview-borrowed-from-rashcka-et-al" style="font-size: 80%;">Generative model,  basic overview (Borrowed from Rashcka et al)</a></li>
     <!-- navigation toc: --> <li><a href="#reminder-on-vaes" style="font-size: 80%;">Reminder on VAEs</a></li>
     <!-- navigation toc: --> <li><a href="#evidence-lower-bound" style="font-size: 80%;">Evidence Lower Bound</a></li>
     <!-- navigation toc: --> <li><a href="#elbo-equations" style="font-size: 80%;">ELBO equations</a></li>
     <!-- navigation toc: --> <li><a href="#introducing-the-encoder-function" style="font-size: 80%;">Introducing the encoder function</a></li>
     <!-- navigation toc: --> <li><a href="#elbo" style="font-size: 80%;">ELBO</a></li>
     <!-- navigation toc: --> <li><a href="#analysis" style="font-size: 80%;">Analysis</a></li>
     <!-- navigation toc: --> <li><a href="#the-vae" style="font-size: 80%;">The VAE</a></li>
     <!-- navigation toc: --> <li><a href="#dissecting-the-equations" style="font-size: 80%;">Dissecting the equations</a></li>
     <!-- navigation toc: --> <li><a href="#bottlenecking-distribution" style="font-size: 80%;">Bottlenecking distribution</a></li>
     <!-- navigation toc: --> <li><a href="#decoder-and-encoder" style="font-size: 80%;">Decoder and encoder</a></li>
     <!-- navigation toc: --> <li><a href="#defining-feature-of-vaes" style="font-size: 80%;">Defining feature of VAEs</a></li>
     <!-- navigation toc: --> <li><a href="#analytical-evaluation" style="font-size: 80%;">Analytical evaluation</a></li>
     <!-- navigation toc: --> <li><a href="#reparameterization-trick" style="font-size: 80%;">Reparameterization trick</a></li>
     <!-- navigation toc: --> <li><a href="#actual-implementation" style="font-size: 80%;">Actual implementation</a></li>
     <!-- navigation toc: --> <li><a href="#interpretation" style="font-size: 80%;">Interpretation</a></li>
     <!-- navigation toc: --> <li><a href="#deterministic-function" style="font-size: 80%;">Deterministic function</a></li>
     <!-- navigation toc: --> <li><a href="#after-training" style="font-size: 80%;">After training</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->
<div class="container">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->
<!-- ------------------- main content ---------------------- -->
<div class="jumbotron">
<center>
<h1>Mathematics of discriminative and generative deep learning, from deep neural networks to diffusion models</h1>
</center>  <!-- document title -->

<!-- author(s): Morten Hjorth-Jensen -->
<center>
<b>Morten Hjorth-Jensen</b> [1, 2]
</center>
<!-- institution(s) -->
<center>
[1] <b>Department of Physics and Center for Computing in Science Education, University of Oslo, Norway</b>
</center>
<center>
[2] <b>Department of Physics and Astronomy and Facility for Rare Isotope Beams, Michigan State University, East Lansing, Michigan, USA</b>
</center>
<br>
<center>
<h4>STREAMLINE meeting, May 9-10, MSU, 2024</h4>
</center> <!-- date -->
<br>

<!-- potential-jumbotron-button -->
</div> <!-- end jumbotron -->

<!-- !split -->
<h2 id="types-of-machine-learning" class="anchor">Types of machine learning </h2>

<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<p>The approaches to machine learning are many, but are often split into two main categories. 
In <em>supervised learning</em> we know the answer to a problem,
and let the computer deduce the logic behind it. On the other hand, <em>unsupervised learning</em>
is a method for finding patterns and relationship in data sets without any prior knowledge of the system.
</p>

<p>An emerging  third category is  <em>reinforcement learning</em>. This is a paradigm 
of learning inspired by behavioural psychology, where learning is achieved by trial-and-error, 
solely from rewards and punishment.
</p>
</div>
</div>


<!-- !split -->
<h2 id="main-categories" class="anchor">Main categories </h2>
<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<p>Another way to categorize machine learning tasks is to consider the desired output of a system.
Some of the most common tasks are:
</p>

<ul>
  <li> Classification: Outputs are divided into two or more classes. The goal is to   produce a model that assigns inputs into one of these classes. An example is to identify  digits based on pictures of hand-written ones. Classification is typically supervised learning.</li>
  <li> Regression: Finding a functional relationship between an input data set and a reference data set.   The goal is to construct a function that maps input data to continuous output values.</li>
  <li> Clustering: Data are divided into groups with certain common traits, without knowing the different groups beforehand.  It is thus a form of unsupervised learning.</li>
</ul>
</div>
</div>


<!-- !split -->
<h2 id="machine-learning-a-simple-perspective-on-the-interface-between-ml-and-physics" class="anchor">Machine learning. A simple perspective on the interface between ML and Physics </h2>

<br/><br/>
<center>
<p><img src="figures/mlimage.png" width="800" align="bottom"></p>
</center>
<br/><br/>

<!-- !split -->
<h2 id="ml-in-nuclear-physics-or-any-field-in-physics" class="anchor">ML in Nuclear  Physics (or any field in physics) </h2>

<br/><br/>
<center>
<p><img src="figures/ML-NP.png" width="900" align="bottom"></p>
</center>
<br/><br/>

<!-- !split -->
<h2 id="the-plethora-of-machine-learning-algorithms-methods" class="anchor">The plethora  of machine learning algorithms/methods </h2>

<ol>
<li> Deep learning: Neural Networks (NN), Convolutional NN, Recurrent NN, Boltzmann machines, autoencoders and variational autoencoders  and generative adversarial networks, stable diffusion and many more generative models</li>
<li> Bayesian statistics and Bayesian Machine Learning, Bayesian experimental design, Bayesian Regression models, Bayesian neural networks, Gaussian processes and much more</li>
<li> Dimensionality reduction (Principal component analysis), Clustering Methods and more</li>
<li> Ensemble Methods, Random forests, bagging and voting methods, gradient boosting approaches</li> 
<li> Linear and logistic regression, Kernel methods, support vector machines and more</li>
<li> Reinforcement Learning; Transfer Learning and more</li> 
</ol>
<!-- !split -->
<h2 id="what-is-generative-modeling" class="anchor">What Is Generative Modeling? </h2>

<p>Generative modeling can be broadly defined as follows:</p>

<p>Generative modeling is a branch of machine learning that involves
training a model to produce new data that is similar to a given
dataset.
</p>

<p>What does this mean in practice? Suppose we have a dataset containing
photos of horses. We can train a generative model on this dataset to
capture the rules that govern the complex relationships between pixels
in images of horses. Then we can sample from this model to create
novel, realistic images of horses that did not exist in the original
dataset. 
</p>

<!-- !split -->
<h2 id="example-of-generative-modeling-taken-from-generative-deep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html" class="anchor">Example of generative modeling, <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_self">taken from Generative Deep Learning by David Foster</a>  </h2>

<br/><br/>
<center>
<p><img src="figures/generativelearning.png" width="900" align="bottom"></p>
</center>
<br/><br/>

<!-- !split -->
<h2 id="generative-modeling" class="anchor">Generative Modeling </h2>

<p>In order to build a generative model, we require a dataset consisting
of many examples of the entity we are trying to generate. This is
known as the training data, and one such data point is called an
observation.
</p>

<p>Each observation consists of many features. For an image generation
problem, the features are usually the individual pixel values; for a
text generation problem, the features could be individual words or
groups of letters. It is our goal to build a model that can generate
new sets of features that look as if they have been created using the
same rules as the original data. Conceptually, for image generation
this is an incredibly difficult task, considering the vast number of
ways that individual pixel values can be assigned and the relatively
tiny number of such arrangements that constitute an image of the
entity we are trying to generate.
</p>

<!-- !split -->
<h2 id="generative-versus-discriminative-modeling" class="anchor">Generative Versus Discriminative Modeling </h2>

<p>In order to truly understand what generative modeling aims to achieve
and why this is important, it is useful to compare it to its
counterpart, discriminative modeling. If you have studied machine
learning, most problems you will have faced will have most likely been
discriminative in nature. 
</p>

<!-- !split -->
<h2 id="example-of-discriminative-modeling-taken-from-generative-deeep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html" class="anchor">Example of discriminative modeling, <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_self">taken from Generative Deeep Learning by David Foster</a>  </h2>

<br/><br/>
<center>
<p><img src="figures/standarddeeplearning.png" width="900" align="bottom"></p>
</center>
<br/><br/>

<!-- !split -->
<h2 id="discriminative-modeling" class="anchor">Discriminative Modeling </h2>

<p>When performing discriminative modeling, each observation in the
training data has a label. For a binary classification problem such as
our data could be labeled as ones and zeros. Our model then learns how to
discriminate between these two groups and outputs the probability that
a new observation has label 1 or 0
</p>

<p>In contrast, generative modeling doesn&#8217;t require the dataset to be
labeled because it concerns itself with generating entirely new
data (for example an image), rather than trying to predict a label for say  a given image.
</p>

<!-- !split -->
<h2 id="taxonomy-of-generative-deep-learning-taken-from-generative-deep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html" class="anchor">Taxonomy of generative deep learning, <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_self">taken from Generative Deep Learning by David Foster</a>  </h2>

<br/><br/>
<center>
<p><img src="figures/generativemodels.png" width="900" align="bottom"></p>
</center>
<br/><br/>

<!-- !split -->
<h2 id="good-books-with-hands-on-material-and-codes" class="anchor">Good books with hands-on material and codes </h2>
<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<ul>
<li> <a href="https://sebastianraschka.com/blog/2022/ml-pytorch-book.html" target="_self">Sebastian Rashcka et al, Machine learning with Sickit-Learn and PyTorch</a></li>
<li> <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_self">David Foster, Generative Deep Learning with TensorFlow</a></li>
<li> <a href="https://github.com/PacktPublishing/Hands-On-Generative-AI-with-Python-and-TensorFlow-2" target="_self">Babcock and Gavras, Generative AI with Python and TensorFlow 2</a></li>
</ul>
</div>
</div>


<p>All three books have GitHub sites from where  one can download all codes. A good and more general text (2016)
is Goodfellow, Bengio and Courville, <a href="https://www.deeplearningbook.org/" target="_self">Deep Learning</a>
</p>

<!-- !split -->
<h2 id="more-references" class="anchor">More references </h2>

<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<ol>
<li> A central paper is the one by Sohl-Dickstein et al, Deep Unsupervised Learning using Nonequilibrium Thermodynamics, <a href="https://arxiv.org/abs/1503.03585" target="_self"><tt>https://arxiv.org/abs/1503.03585</tt></a></li>
<li> See also Diederik P. Kingma, Tim Salimans, Ben Poole, Jonathan Ho, Variational Diffusion Models, <a href="https://arxiv.org/abs/2107.00630" target="_self"><tt>https://arxiv.org/abs/2107.00630</tt></a></li>
</ol>
</div>
</div>
   

<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<ol>
<li> Calvin Luo <a href="https://calvinyluo.com/2022/08/26/diffusion-tutorial.html" target="_self"><tt>https://calvinyluo.com/2022/08/26/diffusion-tutorial.html</tt></a></li>
<li> An Introduction to Variational Autoencoders, by Kingma and Welling, see <a href="https://arxiv.org/abs/1906.02691" target="_self"><tt>https://arxiv.org/abs/1906.02691</tt></a></li>
</ol>
</div>
</div>


<!-- !split -->
<h2 id="what-are-the-basic-machine-learning-ingredients" class="anchor">What are the basic Machine Learning ingredients? </h2>
<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<p>Almost every problem in ML and data science starts with the same ingredients:</p>
<ul>
<li> The dataset \( \boldsymbol{x} \) (could be some observable quantity of the system we are studying)</li>
<li> A model which is a function of a set of parameters \( \boldsymbol{\alpha} \) that relates to the dataset, say a likelihood  function \( p(\boldsymbol{x}\vert \boldsymbol{\alpha}) \) or just a simple model \( f(\boldsymbol{\alpha}) \)</li>
<li> A so-called <b>loss/cost/risk</b> function \( \mathcal{C} (\boldsymbol{x}, f(\boldsymbol{\alpha})) \) which allows us to decide how well our model represents the dataset.</li> 
</ul>
<p>We seek to minimize the function \( \mathcal{C} (\boldsymbol{x}, f(\boldsymbol{\alpha})) \) by finding the parameter values which minimize \( \mathcal{C} \). This leads to  various minimization algorithms. It may surprise many, but at the heart of all machine learning algortihms there is an optimization problem. </p>
</div>
</div>


<!-- !split -->
<h2 id="low-level-machine-learning-the-family-of-ordinary-least-squares-methods" class="anchor">Low-level machine learning, the family of ordinary least squares methods  </h2>

<p>Our data which we want to apply a machine learning method on, consist
of a set of inputs \( \boldsymbol{x}^T=[x_0,x_1,x_2,\dots,x_{n-1}] \) and the
outputs we want to model \( \boldsymbol{y}^T=[y_0,y_1,y_2,\dots,y_{n-1}] \).
We assume  that the output data can be represented (for a regression case) by a continuous function \( f \)
through
</p>
$$
\boldsymbol{y}=f(\boldsymbol{x})+\boldsymbol{\epsilon}.
$$


<!-- !split -->
<h2 id="setting-up-the-equations" class="anchor">Setting up the equations </h2>

<p>In linear regression we approximate the unknown function with another
continuous function \( \tilde{\boldsymbol{y}}(\boldsymbol{x}) \) which depends linearly on
some unknown parameters
\( \boldsymbol{\theta}^T=[\theta_0,\theta_1,\theta_2,\dots,\theta_{p-1}] \).
</p>

<p>The input data can be organized in terms of a so-called design matrix 
with an approximating function \( \boldsymbol{\tilde{y}} \) 
</p>
$$
\boldsymbol{\tilde{y}}= \boldsymbol{X}\boldsymbol{\theta},
$$


<!-- !split -->
<h2 id="the-objective-cost-loss-function" class="anchor">The objective/cost/loss function </h2>

<p>The  simplest approach is the mean squared error</p>
$$
C(\boldsymbol{\Theta})=\frac{1}{n}\sum_{i=0}^{n-1}\left(y_i-\tilde{y}_i\right)^2=\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{\tilde{y}}\right)^T\left(\boldsymbol{y}-\boldsymbol{\tilde{y}}\right)\right\},
$$

<p>or using the matrix \( \boldsymbol{X} \) and in a more compact matrix-vector notation as</p>
$$
C(\boldsymbol{\Theta})=\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\right)^T\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\right)\right\}.
$$

<p>This function represents one of many possible ways to define the so-called cost function.</p>

<!-- !split -->
<h2 id="training-solution" class="anchor">Training solution  </h2>

<p>Optimizing with respect to the unknown parameters \( \theta_j \) we get </p>
$$
\boldsymbol{X}^T\boldsymbol{y} = \boldsymbol{X}^T\boldsymbol{X}\boldsymbol{\theta},  
$$

<p>and if the matrix \( \boldsymbol{X}^T\boldsymbol{X} \) is invertible we have the optimal values</p>
$$
\hat{\boldsymbol{\theta}} =\left(\boldsymbol{X}^T\boldsymbol{X}\right)^{-1}\boldsymbol{X}^T\boldsymbol{y}.
$$

<p>We say we 'learn' the unknown parameters \( \boldsymbol{\theta} \) from the last equation.</p>

<!-- !split -->
<h2 id="ridge-and-lasso-regression" class="anchor">Ridge and LASSO Regression </h2>

<p>Our optimization problem is</p>
$$
{\displaystyle \min_{\boldsymbol{\theta}\in {\mathbb{R}}^{p}}}\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\right)^T\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\right)\right\}.
$$

<p>or we can state it as</p>
$$
{\displaystyle \min_{\boldsymbol{\theta}\in
{\mathbb{R}}^{p}}}\frac{1}{n}\sum_{i=0}^{n-1}\left(y_i-\tilde{y}_i\right)^2=\frac{1}{n}\vert\vert \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\vert\vert_2^2,
$$

<p>where we have used the definition of  a norm-2 vector, that is</p>
$$
\vert\vert \boldsymbol{x}\vert\vert_2 = \sqrt{\sum_i x_i^2}. 
$$


<!-- !split -->
<h2 id="from-ols-to-ridge-and-lasso" class="anchor">From OLS to Ridge and Lasso </h2>

<p>By minimizing the above equation with respect to the parameters
\( \boldsymbol{\theta} \) we could then obtain an analytical expression for the
parameters \( \boldsymbol{\theta} \).  We can add a regularization parameter \( \lambda \) by
defining a new cost function to be optimized, that is
</p>

$$
{\displaystyle \min_{\boldsymbol{\theta}\in
{\mathbb{R}}^{p}}}\frac{1}{n}\vert\vert \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\vert\vert_2^2+\lambda\vert\vert \boldsymbol{\theta}\vert\vert_2^2
$$

<p>which leads to the Ridge regression minimization problem where we
require that \( \vert\vert \boldsymbol{\theta}\vert\vert_2^2\le t \), where \( t \) is
a finite number larger than zero. We do not include such a constraints in the discussions here.
</p>

<!-- !split -->
<h2 id="lasso-regression" class="anchor">Lasso regression  </h2>

<p>Defining</p>

$$
C(\boldsymbol{X},\boldsymbol{\theta})=\frac{1}{n}\vert\vert \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\vert\vert_2^2+\lambda\vert\vert \boldsymbol{\theta}\vert\vert_1,
$$

<p>we have a new optimization equation</p>
$$
{\displaystyle \min_{\boldsymbol{\theta}\in
{\mathbb{R}}^{p}}}\frac{1}{n}\vert\vert \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\vert\vert_2^2+\lambda\vert\vert \boldsymbol{\theta}\vert\vert_1
$$

<p>which leads to Lasso regression. Lasso stands for least absolute shrinkage and selection operator. 
Here we have defined the norm-1 as 
</p>
$$
\vert\vert \boldsymbol{x}\vert\vert_1 = \sum_i \vert x_i\vert. 
$$


<!-- !split -->
<h2 id="selected-references" class="anchor">Selected references </h2>
<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<ul>
<li> <a href="https://arxiv.org/abs/1803.08823" target="_self">Mehta et al.</a> and <a href="https://www.sciencedirect.com/science/article/pii/S0370157319300766?via%3Dihub" target="_self">Physics Reports (2019)</a>.</li>
<li> <a href="https://link.aps.org/doi/10.1103/RevModPhys.91.045002" target="_self">Machine Learning and the Physical Sciences by Carleo et al</a></li>
<li> <a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.94.031003" target="_self">Artificial Intelligence and Machine Learning in Nuclear Physics, Amber Boehnlein et al., Reviews Modern of Physics 94, 031003 (2022)</a></li> 
<li> <a href="https://journals.aps.org/prresearch/pdf/10.1103/PhysRevResearch.5.033062" target="_self">Dilute neutron star matter from neural-network quantum states by Fore et al, Physical Review Research 5, 033062 (2023)</a></li>
<li> Neural-network quantum states for ultra-cold Fermi gases, Jane Kim et al, Nature Physics Communcication, in press, see <a href="https://doi.org/10.48550/arXiv.2305.08831" target="_self"><tt>https://doi.org/10.48550/arXiv.2305.08831</tt></a></li>
<li> <a href="https://doi.org/10.48550/arXiv.2305.07240" target="_self">Message-Passing Neural Quantum States for the Homogeneous Electron Gas, Gabriel Pescia, Jane Kim et al. arXiv.2305.07240,</a></li>
<li> <a href="https://pdg.lbl.gov/2021/reviews/rpp2021-rev-machine-learning.pdf" target="_self">Particle Data Group summary on ML methods</a></li>
</ul>
</div>
</div>


<!-- !split -->
<h2 id="setting-up-the-basic-equations-for-neural-networks" class="anchor">Setting up the basic equations for neural networks </h2>

<p>Neural networks, in its so-called feed-forward form, where each
iterations contains a feed-forward stage and a back-propgagation
stage, consist of series of affine matrix-matrix and matrix-vector
multiplications. The unknown parameters (the so-called biases and
weights which deternine the architecture of a neural network), are
uptaded iteratively using the so-called back-propagation algorithm.
This algorithm corresponds to the so-called reverse mode of the
automatic differentation algorithm. These algorithms will be discussed
in more detail below.
</p>

<p>We start however first with the  definitions of the various variables which make up a neural network.</p>

<!-- !split -->
<h2 id="overarching-view-of-a-neural-network" class="anchor">Overarching view of a neural network </h2>

<p>The architecture of a neural network defines our model. This model
aims at describing some function \( f(\boldsymbol{x} \) which aims at describing
some final result (outputs or tagrget values) given a specific inpput
\( \boldsymbol{x} \). Note that here \( \boldsymbol{y} \) and \( \boldsymbol{x} \) are not limited to be
vectors.
</p>

<p>The architecture consists of</p>
<ol>
<li> An input and an output layer where the input layer is defined by the inputs \( \boldsymbol{x} \). The output layer produces the model ouput \( \boldsymbol{\tilde{y}} \) which is compared with the target value \( \boldsymbol{y} \)</li>
<li> A given number of hidden layers and neurons/nodes/units for each layer (this may vary)</li>
<li> A given activation function \( \sigma(\boldsymbol{z}) \) with arguments \( \boldsymbol{z} \) to be defined below. The activation functions may differ from layer to layer.</li>
<li> The last layer, normally called <b>output</b> layer has normally an activation function tailored to the specific problem</li>
<li> Finally we define a so-called cost or loss function which is used to gauge the quality of our model.</li> 
</ol>
<!-- !split -->
<h2 id="illustration-of-a-single-perceptron-model-and-a-multilayer-ffnn" class="anchor">Illustration of a single perceptron model and a multilayer FFNN </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 1:  In a) we show a single perceptron model while in b) we dispay a network with two  hidden layers, an input layer and an output layer. </p>
</center>
<p><img src="figures/nns.png" width="600" align="bottom"></p>
</center>

<!-- !split -->
<h2 id="the-optimization-problem" class="anchor">The optimization problem </h2>

<p>The cost function is a function of the unknown parameters
\( \boldsymbol{\Theta} \) where the latter is a container for all possible
parameters needed to define a neural network
</p>

<p>If we are dealing with a regression task a typical cost/loss function
is the mean squared error
</p>
$$
C(\boldsymbol{\Theta})=\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\right)^T\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\right)\right\}.
$$

<p>This function represents one of many possible ways to define
the so-called cost function.
</p>

<!-- !split -->
<h2 id="weights-and-biases" class="anchor">Weights and biases </h2>

<p>For neural networks the parameters
\( \boldsymbol{\Theta} \) are given by the so-called weights and biases (to be
defined below).
</p>

<p>The weights are given by matrix elements \( w_{ij}^{(l)} \) where the
superscript indicates the layer number. The biases are typically given
by vector elements representing each single node of a given layer,
that is \( b_j^{(l)} \).
</p>

<!-- !split -->
<h2 id="other-ingredients-of-a-neural-network" class="anchor">Other ingredients of a neural network </h2>

<p>Having defined the architecture of a neural network, the optimization
of the cost function with respect to the parameters \( \boldsymbol{\Theta} \),
involves the calculations of gradients and their optimization. The
gradients represent the derivatives of a multidimensional object and
are often approximated by various gradient methods, including
</p>
<ol>
<li> various quasi-Newton methods,</li>
<li> plain gradient descent (GD) with a constant learning rate \( \eta \),</li>
<li> GD with momentum and other approximations to the learning rates such as</li>
<ul>
  <li> Adapative gradient (ADAgrad)</li>
  <li> Root mean-square propagation (RMSprop)</li>
  <li> Adaptive gradient with momentum (ADAM) and many other</li>
</ul>
<li> Stochastic gradient descent and various families of learning rate approximations</li>
</ol>
<!-- !split -->
<h2 id="other-parameters" class="anchor">Other parameters </h2>

<p>In addition to the above, there are often additional hyperparamaters
which are included in the setup of a neural network. These will be
discussed below.
</p>

<!-- !split -->
<h2 id="why-feed-forward-neural-networks-ffnn" class="anchor">Why Feed Forward Neural Networks (FFNN)?  </h2>

<p>According to the <em>Universal approximation theorem</em>, a feed-forward
neural network with just a single hidden layer containing a finite
number of neurons can approximate a continuous multidimensional
function to arbitrary accuracy, assuming the activation function for
the hidden layer is a <b>non-constant, bounded and
monotonically-increasing continuous function</b>.
</p>

<!-- !split -->
<h2 id="universal-approximation-theorem" class="anchor">Universal approximation theorem </h2>

<p>The universal approximation theorem plays a central role in deep
learning.  <a href="https://link.springer.com/article/10.1007/BF02551274" target="_self">Cybenko (1989)</a> showed
the following:
</p>

<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<p>Let \( \sigma \) be any continuous sigmoidal function such that</p>
$$
\sigma(z) = \left\{\begin{array}{cc} 1 & z\rightarrow \infty\\ 0 & z \rightarrow -\infty \end{array}\right.
$$

<p>Given a continuous and deterministic function \( F(\boldsymbol{x}) \) on the unit
cube in \( d \)-dimensions \( F\in [0,1]^d \), \( x\in [0,1]^d \) and a parameter
\( \epsilon >0 \), there is a one-layer (hidden) neural network
\( f(\boldsymbol{x};\boldsymbol{\Theta}) \) with \( \boldsymbol{\Theta}=(\boldsymbol{W},\boldsymbol{b}) \) and \( \boldsymbol{W}\in
\mathbb{R}^{m\times n} \) and \( \boldsymbol{b}\in \mathbb{R}^{n} \), for which
</p>
$$
\vert F(\boldsymbol{x})-f(\boldsymbol{x};\boldsymbol{\Theta})\vert < \epsilon \hspace{0.1cm} \forall \boldsymbol{x}\in[0,1]^d.
$$
</div>
</div>


<!-- !split -->
<h2 id="the-approximation-theorem-in-words" class="anchor">The approximation theorem in words </h2>

<p><b>Any continuous function \( y=F(\boldsymbol{x}) \) supported on the unit cube in
\( d \)-dimensions can be approximated by a one-layer sigmoidal network to
arbitrary accuracy.</b>
</p>

<p><a href="https://www.sciencedirect.com/science/article/abs/pii/089360809190009T" target="_self">Hornik (1991)</a> extended the theorem by letting any non-constant, bounded activation function to be included using that the expectation value</p>
$$
\mathbb{E}[\vert F(\boldsymbol{x})\vert^2] =\int_{\boldsymbol{x}\in D} \vert F(\boldsymbol{x})\vert^2p(\boldsymbol{x})d\boldsymbol{x} < \infty.
$$

<p>Then we have</p>
$$
\mathbb{E}[\vert F(\boldsymbol{x})-f(\boldsymbol{x};\boldsymbol{\Theta})\vert^2] =\int_{\boldsymbol{x}\in D} \vert F(\boldsymbol{x})-f(\boldsymbol{x};\boldsymbol{\Theta})\vert^2p(\boldsymbol{x})d\boldsymbol{x} < \epsilon.
$$


<!-- !split -->
<h2 id="more-on-the-general-approximation-theorem" class="anchor">More on the general approximation theorem </h2>

<p>None of the proofs give any insight into the relation between the
number of of hidden layers and nodes and the approximation error
\( \epsilon \), nor the magnitudes of \( \boldsymbol{W} \) and \( \boldsymbol{b} \).
</p>

<p>Neural networks (NNs) have what we may call a kind of universality no matter what function we want to compute.</p>

<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<p>It does not mean that an NN can be used to exactly compute any function. Rather, we get an approximation that is as good as we want. </p>
</div>
</div>


<!-- !split -->
<h2 id="class-of-functions-we-can-approximate" class="anchor">Class of functions we can approximate </h2>

<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<p>The class of functions that can be approximated are the continuous ones.
If the function \( F(\boldsymbol{x}) \) is discontinuous, it won't in general be possible to approximate it. However, an NN may still give an approximation even if we fail in some points.
</p>
</div>
</div>


<!-- !split -->
<h2 id="simple-example-fitting-nuclear-masses" class="anchor">Simple example, fitting nuclear masses </h2>

<p>See example at <a href="https://github.com/CompPhysics/MachineLearning/blob/master/doc/pub/week34/ipynb/week34.ipynb" target="_self"><tt>https://github.com/CompPhysics/MachineLearning/blob/master/doc/pub/week34/ipynb/week34.ipynb</tt></a>, and scroll down to nuclear masses.</p>

<p>And the recent article <a href="https://www.sciencedirect.com/science/article/pii/S0375947423001100" target="_self"><tt>https://www.sciencedirect.com/science/article/pii/S0375947423001100</tt></a></p>

<!-- !split -->
<h2 id="first-network-example-simple-percepetron-with-one-input" class="anchor">First network example, simple percepetron with one input </h2>

<p>As yet another example we define now a simple perceptron model with
all quantities given by scalars. We consider only one input variable
\( x \) and one target value \( y \).  We define an activation function
\( \sigma_1 \) which takes as input
</p>

$$
z_1 = w_1x+b_1,
$$

<p>where \( w_1 \) is the weight and \( b_1 \) is the bias. These are the
parameters we want to optimize.  The output is \( a_1=\sigma(z_1) \) (see
graph from whiteboard notes). This output is then fed into the
<b>cost/loss</b> function, which we here for the sake of simplicity just
define as the squared error
</p>

$$
C(x;w_1,b_1)=\frac{1}{2}(a_1-y)^2.
$$


<!-- !split -->
<h2 id="optimizing-the-parameters" class="anchor">Optimizing the parameters </h2>

<p>In setting up the feed forward and back propagation parts of the
algorithm, we need now the derivative of the various variables we want
to train.
</p>

<p>We need</p>
$$
\frac{\partial C}{\partial w_1} \hspace{0.1cm}\mathrm{and}\hspace{0.1cm}\frac{\partial C}{\partial b_1}. 
$$

<p>Using the chain rule we find </p>
$$
\frac{\partial C}{\partial w_1}=\frac{\partial C}{\partial a_1}\frac{\partial a_1}{\partial z_1}\frac{\partial z_1}{\partial w_1}=(a_1-y)\sigma_1'x,
$$

<p>and</p>
$$
\frac{\partial C}{\partial b_1}=\frac{\partial C}{\partial a_1}\frac{\partial a_1}{\partial z_1}\frac{\partial z_1}{\partial b_1}=(a_1-y)\sigma_1',
$$

<p>which we later will just define as</p>
$$
\frac{\partial C}{\partial a_1}\frac{\partial a_1}{\partial z_1}=\delta_1.
$$


<!-- !split -->
<h2 id="implementing-the-simple-perceptron-model" class="anchor">Implementing the simple perceptron model </h2>

<p>In the example code here we implement the above equations (with explict
expressions for the derivatives) with just one input variable \( x \) and
one output variable.  The target value \( y=2x+1 \) is a simple linear
function in \( x \). Since this is a regression problem, we define the cost function to be proportional to the least squares error
</p>
$$
C(y,w_1,b_1)=\frac{1}{2}(a_1-y)^2,
$$

<p>with \( a_1 \) the output from the network.</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #408080; font-style: italic"># import necessary packages</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">feed_forward</span>(x):
    <span style="color: #408080; font-style: italic"># weighted sum of inputs to the output layer</span>
    z_1 <span style="color: #666666">=</span> x<span style="color: #666666">*</span>output_weights <span style="color: #666666">+</span> output_bias
    <span style="color: #408080; font-style: italic"># Output from output node (one node only)</span>
    <span style="color: #408080; font-style: italic"># Here the output is equal to the input</span>
    a_1 <span style="color: #666666">=</span> z_1
    <span style="color: #008000; font-weight: bold">return</span> a_1

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">backpropagation</span>(x, y):
    a_1 <span style="color: #666666">=</span> feed_forward(x)
    <span style="color: #408080; font-style: italic"># derivative of cost function</span>
    derivative_cost <span style="color: #666666">=</span> a_1 <span style="color: #666666">-</span> y
    <span style="color: #408080; font-style: italic"># the variable delta in the equations, note that output a_1 = z_1, its derivatives wrt z_o is thus 1</span>
    delta_1 <span style="color: #666666">=</span> derivative_cost
    <span style="color: #408080; font-style: italic"># gradients for the output layer</span>
    output_weights_gradient <span style="color: #666666">=</span> delta_1<span style="color: #666666">*</span>x
    output_bias_gradient <span style="color: #666666">=</span> delta_1
    <span style="color: #408080; font-style: italic"># The cost function is 0.5*(a_1-y)^2. This gives a measure of the error for each iteration</span>
    <span style="color: #008000; font-weight: bold">return</span> output_weights_gradient, output_bias_gradient

<span style="color: #408080; font-style: italic"># ensure the same random numbers appear every time</span>
np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">0</span>)
<span style="color: #408080; font-style: italic"># Input variable</span>
x <span style="color: #666666">=</span> <span style="color: #666666">4.0</span>
<span style="color: #408080; font-style: italic"># Target values</span>
y <span style="color: #666666">=</span> <span style="color: #666666">2*</span>x<span style="color: #666666">+1.0</span>

<span style="color: #408080; font-style: italic"># Defining the neural network</span>
n_inputs <span style="color: #666666">=</span> <span style="color: #666666">1</span>
n_outputs <span style="color: #666666">=</span> <span style="color: #666666">1</span>
<span style="color: #408080; font-style: italic"># Initialize the network</span>
<span style="color: #408080; font-style: italic"># weights and bias in the output layer</span>
output_weights <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>randn()
output_bias <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>randn()

<span style="color: #408080; font-style: italic"># implementing a simple gradient descent approach with fixed learning rate</span>
eta <span style="color: #666666">=</span> <span style="color: #666666">0.01</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">40</span>):
    <span style="color: #408080; font-style: italic"># calculate gradients from back propagation</span>
    derivative_w1, derivative_b1 <span style="color: #666666">=</span> backpropagation(x, y)
    <span style="color: #408080; font-style: italic"># update weights and biases</span>
    output_weights <span style="color: #666666">-=</span> eta <span style="color: #666666">*</span> derivative_w1
    output_bias <span style="color: #666666">-=</span> eta <span style="color: #666666">*</span> derivative_b1
<span style="color: #408080; font-style: italic"># our final prediction after training</span>
ytilde <span style="color: #666666">=</span> output_weights<span style="color: #666666">*</span>x<span style="color: #666666">+</span>output_bias
<span style="color: #008000">print</span>(<span style="color: #666666">0.5*</span>((ytilde<span style="color: #666666">-</span>y)<span style="color: #666666">**2</span>))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Running this code gives us an acceptable results after some 40-50 iterations. Note that the results depend on the value of the learning rate.</p>

<!-- !split -->

<!-- --- begin exercise --- -->
<h2 id="exercise-1-extensions-to-the-above-code" class="anchor">Exercise 1: Extensions to the above code </h2>

<p>Feel free to add more input nodes and weights to the above
code. Furthermore, try to increase the amount of input and
target/output data. Try also to perform calculations for more values
of the learning rates. Feel free to add either hyperparameters with an
\( l_1 \) norm or an \( l_2 \) norm and discuss your results.
</p>

<p>You could also try to change the function \( f(x)=y \) from a linear polynomial in \( x \) to a higher-order polynomial.
Comment your results.
</p>

<p><b>Hint</b>: Increasing the number of input variables and input nodes requires a rewrite of the input data in terms of a matrix. You need to figure out the correct dimensionalities.</p>

<!-- --- end exercise --- -->

<!-- !split -->
<h2 id="adding-a-hidden-layer" class="anchor">Adding a hidden layer </h2>

<p>We change our simple model to (see graph below)
a network with just one hidden layer but with scalar variables only.
</p>

<p>Our output variable changes to \( a_2 \) and \( a_1 \) is now the output from the hidden node and \( a_0=x \).
We have then
</p>
$$
z_1 = w_1a_0+b_1 \hspace{0.1cm} \wedge a_1 = \sigma_1(z_1),
$$

$$
z_2 = w_2a_1+b_2 \hspace{0.1cm} \wedge a_2 = \sigma_2(z_2),
$$

<p>and the cost function</p>
$$
C(x;\boldsymbol{\Theta})=\frac{1}{2}(a_2-y)^2,
$$

<p>with \( \boldsymbol{\Theta}=[w_1,w_2,b_1,b_2] \).</p>

<!-- !split -->
<h2 id="the-derivatives" class="anchor">The derivatives </h2>

<p>The derivatives are now, using the chain rule again</p>

$$
\frac{\partial C}{\partial w_2}=\frac{\partial C}{\partial a_2}\frac{\partial a_2}{\partial z_2}\frac{\partial z_2}{\partial w_2}=(a_2-y)\sigma_2'a_1=\delta_2a_1,
$$

$$
\frac{\partial C}{\partial b_2}=\frac{\partial C}{\partial a_2}\frac{\partial a_2}{\partial z_2}\frac{\partial z_2}{\partial b_2}=(a_2-y)\sigma_2'=\delta_2,
$$

$$
\frac{\partial C}{\partial w_1}=\frac{\partial C}{\partial a_2}\frac{\partial a_2}{\partial z_2}\frac{\partial z_2}{\partial a_1}\frac{\partial a_1}{\partial z_1}\frac{\partial z_1}{\partial w_1}=(a_2-y)\sigma_2'a_1\sigma_1'a_0,
$$

$$
\frac{\partial C}{\partial b_1}=\frac{\partial C}{\partial a_2}\frac{\partial a_2}{\partial z_2}\frac{\partial z_2}{\partial a_1}\frac{\partial a_1}{\partial z_1}\frac{\partial z_1}{\partial b_1}=(a_2-y)\sigma_2'\sigma_1'=\delta_1.
$$

<p>Can you generalize this to more than one hidden layer?</p>

<!-- !split -->
<h2 id="important-observations" class="anchor">Important observations </h2>

<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<p>From the above equations we see that the derivatives of the activation
functions play a central role. If they vanish, the training may
stop. This is called the vanishing gradient problem, see discussions below. If they become
large, the parameters \( w_i \) and \( b_i \) may simply go to infinity. This
is referenced as  the exploding gradient problem.
</p>
</div>
</div>


<!-- !split -->
<h2 id="the-training" class="anchor">The training </h2>

<p>The training of the parameters is done through various gradient descent approximations with</p>

$$
w_{i}\leftarrow w_{i}- \eta \delta_i a_{i-1},
$$

<p>and</p>
$$
b_i \leftarrow b_i-\eta \delta_i,
$$

<p>with \( \eta \) is the learning rate.</p>

<p>One iteration consists of one feed forward step and one back-propagation step. Each back-propagation step does one update of the parameters \( \boldsymbol{\Theta} \).</p>

<p>For the first hidden layer \( a_{i-1}=a_0=x \) for this simple model.</p>

<!-- !split -->
<h2 id="code-example" class="anchor">Code example  </h2>

<p>The code here implements the above model with one hidden layer and
scalar variables for the same function we studied in the previous
example.  The code is however set up so that we can add multiple
inputs \( x \) and target values \( y \). Note also that we have the
possibility of defining a feature matrix \( \boldsymbol{X} \) with more than just
one column for the input values. This will turn useful in our next example. We have also defined matrices and vectors for all of our operations although it is not necessary here.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #408080; font-style: italic"># We use the Sigmoid function as activation function</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sigmoid</span>(z):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">1.0+</span>np<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>z))

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">forwardpropagation</span>(x):
    <span style="color: #408080; font-style: italic"># weighted sum of inputs to the hidden layer</span>
    z_1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>matmul(x, w_1) <span style="color: #666666">+</span> b_1
    <span style="color: #408080; font-style: italic"># activation in the hidden layer</span>
    a_1 <span style="color: #666666">=</span> sigmoid(z_1)
    <span style="color: #408080; font-style: italic"># weighted sum of inputs to the output layer</span>
    z_2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>matmul(a_1, w_2) <span style="color: #666666">+</span> b_2
    a_2 <span style="color: #666666">=</span> z_2
    <span style="color: #008000; font-weight: bold">return</span> a_1, a_2

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">backpropagation</span>(x, y):
    a_1, a_2 <span style="color: #666666">=</span> forwardpropagation(x)
    <span style="color: #408080; font-style: italic"># parameter delta for the output layer, note that a_2=z_2 and its derivative wrt z_2 is just 1</span>
    delta_2 <span style="color: #666666">=</span> a_2 <span style="color: #666666">-</span> y
    <span style="color: #008000">print</span>(<span style="color: #666666">0.5*</span>((a_2<span style="color: #666666">-</span>y)<span style="color: #666666">**2</span>))
    <span style="color: #408080; font-style: italic"># delta for  the hidden layer</span>
    delta_1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>matmul(delta_2, w_2<span style="color: #666666">.</span>T) <span style="color: #666666">*</span> a_1 <span style="color: #666666">*</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> a_1)
    <span style="color: #408080; font-style: italic"># gradients for the output layer</span>
    output_weights_gradient <span style="color: #666666">=</span> np<span style="color: #666666">.</span>matmul(a_1<span style="color: #666666">.</span>T, delta_2)
    output_bias_gradient <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(delta_2, axis<span style="color: #666666">=0</span>)
    <span style="color: #408080; font-style: italic"># gradient for the hidden layer</span>
    hidden_weights_gradient <span style="color: #666666">=</span> np<span style="color: #666666">.</span>matmul(x<span style="color: #666666">.</span>T, delta_1)
    hidden_bias_gradient <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(delta_1, axis<span style="color: #666666">=0</span>)
    <span style="color: #008000; font-weight: bold">return</span> output_weights_gradient, output_bias_gradient, hidden_weights_gradient, hidden_bias_gradient


<span style="color: #408080; font-style: italic"># ensure the same random numbers appear every time</span>
np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">0</span>)
<span style="color: #408080; font-style: italic"># Input variable</span>
x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">4.0</span>],dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>float64)
<span style="color: #408080; font-style: italic"># Target values</span>
y <span style="color: #666666">=</span> <span style="color: #666666">2*</span>x<span style="color: #666666">+1.0</span> 

<span style="color: #408080; font-style: italic"># Defining the neural network, only scalars here</span>
n_inputs <span style="color: #666666">=</span> x<span style="color: #666666">.</span>shape
n_features <span style="color: #666666">=</span> <span style="color: #666666">1</span>
n_hidden_neurons <span style="color: #666666">=</span> <span style="color: #666666">1</span>
n_outputs <span style="color: #666666">=</span> <span style="color: #666666">1</span>

<span style="color: #408080; font-style: italic"># Initialize the network</span>
<span style="color: #408080; font-style: italic"># weights and bias in the hidden layer</span>
w_1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>randn(n_features, n_hidden_neurons)
b_1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(n_hidden_neurons) <span style="color: #666666">+</span> <span style="color: #666666">0.01</span>

<span style="color: #408080; font-style: italic"># weights and bias in the output layer</span>
w_2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>randn(n_hidden_neurons, n_outputs)
b_2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(n_outputs) <span style="color: #666666">+</span> <span style="color: #666666">0.01</span>

eta <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">50</span>):
    <span style="color: #408080; font-style: italic"># calculate gradients</span>
    derivW2, derivB2, derivW1, derivB1 <span style="color: #666666">=</span> backpropagation(x, y)
    <span style="color: #408080; font-style: italic"># update weights and biases</span>
    w_2 <span style="color: #666666">-=</span> eta <span style="color: #666666">*</span> derivW2
    b_2 <span style="color: #666666">-=</span> eta <span style="color: #666666">*</span> derivB2
    w_1 <span style="color: #666666">-=</span> eta <span style="color: #666666">*</span> derivW1
    b_1 <span style="color: #666666">-=</span> eta <span style="color: #666666">*</span> derivB1
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>We see that after some few iterations (the results do depend on the learning rate however), we get an error which is rather small.</p>

<!-- !split -->

<!-- --- begin exercise --- -->
<h2 id="exercise-2-including-more-data" class="anchor">Exercise 2: Including more data </h2>

<p>Try to increase the amount of input and
target/output data. Try also to perform calculations for more values
of the learning rates. Feel free to add either hyperparameters with an
\( l_1 \) norm or an \( l_2 \) norm and discuss your results.
Discuss your results as functions of the amount of training data and various learning rates.
</p>

<p><b>Challenge:</b> Try to change the activation functions and replace the hard-coded analytical expressions with automatic derivation via either <b>autograd</b> or <b>JAX</b>.</p>

<!-- --- end exercise --- -->

<!-- !split -->
<h2 id="simple-neural-network-and-the-back-propagation-equations" class="anchor">Simple neural network and the  back propagation equations  </h2>

<p>Let us now try to increase our level of ambition and attempt at setting 
up the equations for a neural network with two input nodes, one hidden
layer with two hidden nodes and one output layer with one output node/neuron only (see graph)..
</p>

<p>We need to define the following parameters and variables with the input layer (layer \( (0) \)) 
where we label the  nodes \( x_0 \) and \( x_1 \)
</p>
$$
x_0 = a_0^{(0)} \wedge x_1 = a_1^{(0)}.
$$

<p>The  hidden layer (layer \( (1) \)) has  nodes which yield the outputs \( a_0^{(1)} \) and \( a_1^{(1)} \)) with  weight \( \boldsymbol{w} \) and bias \( \boldsymbol{b} \) parameters</p>
$$
w_{ij}^{(1)}=\left\{w_{00}^{(1)},w_{01}^{(1)},w_{10}^{(1)},w_{11}^{(1)}\right\} \wedge b^{(1)}=\left\{b_0^{(1)},b_1^{(1)}\right\}.
$$


<!-- !split -->
<h2 id="the-ouput-layer" class="anchor">The ouput layer </h2>

<p>Finally, we have the ouput layer given by layer label \( (2) \) with output \( a^{(2)} \) and weights and biases to be determined given by the variables</p>
$$
w_{i}^{(2)}=\left\{w_{0}^{(2)},w_{1}^{(2)}\right\} \wedge b^{(2)}.
$$

<p>Our output is \( \tilde{y}=a^{(2)} \) and we define a generic cost function \( C(a^{(2)},y;\boldsymbol{\Theta}) \) where \( y \) is the target value (a scalar here).
The parameters we need to optimize are given by
</p>
$$
\boldsymbol{\Theta}=\left\{w_{00}^{(1)},w_{01}^{(1)},w_{10}^{(1)},w_{11}^{(1)},w_{0}^{(2)},w_{1}^{(2)},b_0^{(1)},b_1^{(1)},b^{(2)}\right\}.
$$


<!-- !split -->
<h2 id="compact-expressions" class="anchor">Compact expressions </h2>

<p>We can define the inputs to the activation functions for the various layers in terms of various matrix-vector multiplications and vector additions.
The inputs to the first hidden layer are
</p>
$$
\begin{bmatrix}z_0^{(1)} \\ z_1^{(1)} \end{bmatrix}=\begin{bmatrix}w_{00}^{(1)} & w_{01}^{(1)}\\ w_{10}^{(1)} &w_{11}^{(1)} \end{bmatrix}\begin{bmatrix}a_0^{(0)} \\ a_1^{(0)} \end{bmatrix}+\begin{bmatrix}b_0^{(1)} \\ b_1^{(1)} \end{bmatrix},
$$

<p>with outputs</p>
$$
\begin{bmatrix}a_0^{(1)} \\ a_1^{(1)} \end{bmatrix}=\begin{bmatrix}\sigma^{(1)}(z_0^{(1)}) \\ \sigma^{(1)}(z_1^{(1)}) \end{bmatrix}.
$$


<!-- !split -->
<h2 id="output-layer" class="anchor">Output layer </h2>

<p>For the final output layer we have the inputs to the final activation function </p>
$$
z^{(2)} = w_{0}^{(2)}a_0^{(1)} +w_{1}^{(2)}a_1^{(1)}+b^{(2)},
$$

<p>resulting in the  output</p>
$$
a^{(2)}=\sigma^{(2)}(z^{(2)}).
$$


<!-- !split -->
<h2 id="explicit-derivatives" class="anchor">Explicit derivatives </h2>

<p>In total we have nine parameters which we need to train.  Using the
chain rule (or just the back-propagation algorithm) we can find all
derivatives. Since we will use automatic differentiation in reverse
mode, we start with the derivatives of the cost function with respect
to the parameters of the output layer, namely
</p>

$$
\frac{\partial C}{\partial w_{i}^{(2)}}=\frac{\partial C}{\partial a^{(2)}}\frac{\partial a^{(2)}}{\partial z^{(2)}}\frac{\partial z^{(2)}}{\partial w_{i}^{(2)}}=\delta^{(2)}a_i^{(1)},
$$

<p>with</p>
$$
\delta^{(2)}=\frac{\partial C}{\partial a^{(2)}}\frac{\partial a^{(2)}}{\partial z^{(2)}}
$$

<p>and finally</p>
$$
\frac{\partial C}{\partial b^{(2)}}=\frac{\partial C}{\partial a^{(2)}}\frac{\partial a^{(2)}}{\partial z^{(2)}}\frac{\partial z^{(2)}}{\partial b^{(2)}}=\delta^{(2)}.
$$


<!-- !split -->
<h2 id="derivatives-of-the-hidden-layer" class="anchor">Derivatives of the hidden layer </h2>

<p>Using the chain rule we have the following expressions for say one of the weight parameters (it is easy to generalize to the other weight parameters)</p>
$$
\frac{\partial C}{\partial w_{00}^{(1)}}=\frac{\partial C}{\partial a^{(2)}}\frac{\partial a^{(2)}}{\partial z^{(2)}}
\frac{\partial z^{(2)}}{\partial z_0^{(1)}}\frac{\partial z_0^{(1)}}{\partial w_{00}^{(1)}}=    \delta^{(2)}\frac{\partial z^{(2)}}{\partial z_0^{(1)}}\frac{\partial z_0^{(1)}}{\partial w_{00}^{(1)}},
$$

<p>which, noting that</p>
$$
z^{(2)} =w_0^{(2)}a_0^{(1)}+w_1^{(2)}a_1^{(1)}+b^{(2)},
$$

<p>allows us to rewrite </p>
$$
\frac{\partial z^{(2)}}{\partial z_0^{(1)}}\frac{\partial z_0^{(1)}}{\partial w_{00}^{(1)}}=w_0^{(2)}\frac{\partial a_0^{(1)}}{\partial z_0^{(1)}}a_0^{(1)}.
$$


<!-- !split -->
<h2 id="final-expression" class="anchor">Final expression </h2>
<p>Defining</p>
$$
\delta_0^{(1)}=w_0^{(2)}\frac{\partial a_0^{(1)}}{\partial z_0^{(1)}}\delta^{(2)},
$$

<p>we have </p>
$$
\frac{\partial C}{\partial w_{00}^{(1)}}=\delta_0^{(1)}a_0^{(1)}.
$$

<p>Similarly, we obtain</p>
$$
\frac{\partial C}{\partial w_{01}^{(1)}}=\delta_0^{(1)}a_1^{(1)}.
$$


<!-- !split -->
<h2 id="completing-the-list" class="anchor">Completing the list </h2>

<p>Similarly, we find</p>
$$
\frac{\partial C}{\partial w_{10}^{(1)}}=\delta_1^{(1)}a_0^{(1)},
$$

<p>and </p>
$$
\frac{\partial C}{\partial w_{11}^{(1)}}=\delta_1^{(1)}a_1^{(1)},
$$

<p>where we have defined </p>
$$
\delta_1^{(1)}=w_1^{(2)}\frac{\partial a_1^{(1)}}{\partial z_1^{(1)}}\delta^{(2)}.
$$


<!-- !split -->
<h2 id="final-expressions-for-the-biases-of-the-hidden-layer" class="anchor">Final expressions for the biases of the hidden layer </h2>

<p>For the sake of completeness, we list the derivatives of the biases, which are</p>
$$
\frac{\partial C}{\partial b_{0}^{(1)}}=\delta_0^{(1)},
$$

<p>and</p>
$$
\frac{\partial C}{\partial b_{1}^{(1)}}=\delta_1^{(1)}.
$$

<p>As we will see below, these expressions can be generalized in a more compact form. </p>

<!-- !split -->
<h2 id="gradient-expressions" class="anchor">Gradient expressions </h2>

<p>For this specific model, with just one output node and two hidden
nodes, the gradient descent equations take the following form for output layer
</p>
$$
w_{i}^{(2)}\leftarrow w_{i}^{(2)}- \eta \delta^{(2)} a_{i}^{(1)},
$$

<p>and</p>
$$
b^{(2)} \leftarrow b^{(2)}-\eta \delta^{(2)},
$$

<p>and</p>
$$
w_{ij}^{(1)}\leftarrow w_{ij}^{(1)}- \eta \delta_{i}^{(1)} a_{j}^{(0)},
$$

<p>and</p>
$$
b_{i}^{(1)} \leftarrow b_{i}^{(1)}-\eta \delta_{i}^{(1)},
$$

<p>where \( \eta \) is the learning rate.</p>

<!-- !split -->

<!-- --- begin exercise --- -->
<h2 id="exercise-3-extended-program" class="anchor">Exercise 3: Extended program </h2>

<p>We extend our simple code to a function which depends on two variable \( x_0 \) and \( x_1 \), that is</p>
$$
y=f(x_0,x_1)=x_0^2+3x_0x_1+x_1^2+5.
$$

<p>We feed our network with \( n=100 \) entries \( x_0 \) and \( x_1 \). We have thus two features represented by these variable and an input matrix/design matrix \( \boldsymbol{X}\in \mathbf{R}^{n\times 2} \)</p>
$$
\boldsymbol{X}=\begin{bmatrix} x_{00} & x_{01} \\ x_{00} & x_{01} \\ x_{10} & x_{11} \\ x_{20} & x_{21} \\ \dots & \dots \\ \dots & \dots \\ x_{n-20} & x_{n-21} \\ x_{n-10} & x_{n-11} \end{bmatrix}.
$$

<p>Write a code, based on the previous code examples, which takes as input these data and fit the above function.
You can extend your code to include automatic differentiation.
</p>

<p>With these examples, we are now ready to embark upon the writing of more a general code for neural networks.</p>

<!-- --- end exercise --- -->

<!-- !split -->
<h2 id="getting-serious-the-back-propagation-equations-for-a-neural-network" class="anchor">Getting serious, the  back propagation equations for a neural network </h2>

<p>Now it is time to move away from one node in each layer only. Our inputs are also represented either by several inputs.</p>

<p>We have thus</p>
$$
\frac{\partial{\cal C}((\boldsymbol{\Theta}^L)}{\partial w_{jk}^L}  =  \left(a_j^L - y_j\right)a_j^L(1-a_j^L)a_k^{L-1}, 
$$

<p>Defining</p>
$$
\delta_j^L = a_j^L(1-a_j^L)\left(a_j^L - y_j\right) = \sigma'(z_j^L)\frac{\partial {\cal C}}{\partial (a_j^L)},
$$

<p>and using the Hadamard product of two vectors we can write this as</p>
$$
\boldsymbol{\delta}^L = \sigma'(\hat{z}^L)\circ\frac{\partial {\cal C}}{\partial (\boldsymbol{a}^L)}.
$$


<!-- !split -->
<h2 id="analyzing-the-last-results" class="anchor">Analyzing the last results </h2>

<p>This is an important expression. The second term on the right handside
measures how fast the cost function is changing as a function of the $j$th
output activation.  If, for example, the cost function doesn't depend
much on a particular output node \( j \), then \( \delta_j^L \) will be small,
which is what we would expect. The first term on the right, measures
how fast the activation function \( f \) is changing at a given activation
value \( z_j^L \).
</p>

<!-- !split -->
<h2 id="more-considerations" class="anchor">More considerations </h2>

<p>Notice that everything in the above equations is easily computed.  In
particular, we compute \( z_j^L \) while computing the behaviour of the
network, and it is only a small additional overhead to compute
\( \sigma'(z^L_j) \).  The exact form of the derivative with respect to the
output depends on the form of the cost function.
However, provided the cost function is known there should be little
trouble in calculating
</p>

$$
\frac{\partial {\cal C}}{\partial (a_j^L)}
$$

<p>With the definition of \( \delta_j^L \) we have a more compact definition of the derivative of the cost function in terms of the weights, namely</p>
$$
\frac{\partial{\cal C}}{\partial w_{jk}^L}  =  \delta_j^La_k^{L-1}.
$$


<!-- !split -->
<h2 id="derivatives-in-terms-of-z-j-l" class="anchor">Derivatives in terms of \( z_j^L \) </h2>

<p>It is also easy to see that our previous equation can be written as</p>

$$
\delta_j^L =\frac{\partial {\cal C}}{\partial z_j^L}= \frac{\partial {\cal C}}{\partial a_j^L}\frac{\partial a_j^L}{\partial z_j^L},
$$

<p>which can also be interpreted as the partial derivative of the cost function with respect to the biases \( b_j^L \), namely</p>
$$
\delta_j^L = \frac{\partial {\cal C}}{\partial b_j^L}\frac{\partial b_j^L}{\partial z_j^L}=\frac{\partial {\cal C}}{\partial b_j^L},
$$

<p>That is, the error \( \delta_j^L \) is exactly equal to the rate of change of the cost function as a function of the bias. </p>

<!-- !split -->
<h2 id="bringing-it-together" class="anchor">Bringing it together </h2>

<p>We have now three equations that are essential for the computations of the derivatives of the cost function at the output layer. These equations are needed to start the algorithm and they are</p>

$$
\begin{equation}
\frac{\partial{\cal C}(\hat{W^L})}{\partial w_{jk}^L}  =  \delta_j^La_k^{L-1},
\label{_auto1}
\end{equation}
$$

<p>and</p>
$$
\begin{equation}
\delta_j^L = \sigma'(z_j^L)\frac{\partial {\cal C}}{\partial (a_j^L)},
\label{_auto2}
\end{equation}
$$

<p>and</p>

$$
\begin{equation}
\delta_j^L = \frac{\partial {\cal C}}{\partial b_j^L},
\label{_auto3}
\end{equation}
$$


<!-- !split -->
<h2 id="final-back-propagating-equation" class="anchor">Final back propagating equation </h2>

<p>We have that (replacing \( L \) with a general layer \( l \))</p>
$$
\delta_j^l =\frac{\partial {\cal C}}{\partial z_j^l}.
$$

<p>We want to express this in terms of the equations for layer \( l+1 \).</p>

<!-- !split -->
<h2 id="using-the-chain-rule-and-summing-over-all-k-entries" class="anchor">Using the chain rule and summing over all \( k \) entries </h2>

<p>We obtain</p>
$$
\delta_j^l =\sum_k \frac{\partial {\cal C}}{\partial z_k^{l+1}}\frac{\partial z_k^{l+1}}{\partial z_j^{l}}=\sum_k \delta_k^{l+1}\frac{\partial z_k^{l+1}}{\partial z_j^{l}},
$$

<p>and recalling that</p>
$$
z_j^{l+1} = \sum_{i=1}^{M_{l}}w_{ij}^{l+1}a_i^{l}+b_j^{l+1},
$$

<p>with \( M_l \) being the number of nodes in layer \( l \), we obtain</p>
$$
\delta_j^l =\sum_k \delta_k^{l+1}w_{kj}^{l+1}\sigma'(z_j^l),
$$

<p>This is our final equation.</p>

<p>We are now ready to set up the algorithm for back propagation and learning the weights and biases.</p>

<!-- !split -->
<h2 id="setting-up-the-back-propagation-algorithm" class="anchor">Setting up the back propagation algorithm </h2>

<p>The four equations  provide us with a way of computing the gradient of the cost function. Let us write this out in the form of an algorithm.</p>

<p><b>First</b>, we set up the input data \( \hat{x} \) and the activations
\( \hat{z}_1 \) of the input layer and compute the activation function and
the pertinent outputs \( \hat{a}^1 \).
</p>

<p><b>Secondly</b>, we perform then the feed forward till we reach the output
layer and compute all \( \hat{z}_l \) of the input layer and compute the
activation function and the pertinent outputs \( \hat{a}^l \) for
\( l=1,2,3,\dots,L \).
</p>

<p><b>Notation</b>: The first hidden layer has \( l=1 \) as label and the final output layer has \( l=L \).</p>

<!-- !split -->
<h2 id="setting-up-the-back-propagation-algorithm-part-2" class="anchor">Setting up the back propagation algorithm, part 2 </h2>

<p>Thereafter we compute the ouput error \( \hat{\delta}^L \) by computing all</p>
$$
\delta_j^L = \sigma'(z_j^L)\frac{\partial {\cal C}}{\partial (a_j^L)}.
$$

<p>Then we compute the back propagate error for each \( l=L-1,L-2,\dots,1 \) as</p>
$$
\delta_j^l = \sum_k \delta_k^{l+1}w_{kj}^{l+1}\sigma'(z_j^l).
$$


<!-- !split -->
<h2 id="setting-up-the-back-propagation-algorithm-part-3" class="anchor">Setting up the Back propagation algorithm, part 3 </h2>

<p>Finally, we update the weights and the biases using gradient descent
for each \( l=L-1,L-2,\dots,1 \) and update the weights and biases
according to the rules
</p>

$$
w_{jk}^l\leftarrow  = w_{jk}^l- \eta \delta_j^la_k^{l-1},
$$


$$
b_j^l \leftarrow b_j^l-\eta \frac{\partial {\cal C}}{\partial b_j^l}=b_j^l-\eta \delta_j^l,
$$

<p>with \( \eta \) being the learning rate.</p>

<!-- !split -->
<h2 id="updating-the-gradients" class="anchor">Updating the gradients  </h2>

<p>With the back propagate error for each \( l=L-1,L-2,\dots,1 \) as</p>
$$
\delta_j^l = \sum_k \delta_k^{l+1}w_{kj}^{l+1}sigma'(z_j^l),
$$

<p>we update the weights and the biases using gradient descent for each \( l=L-1,L-2,\dots,1 \) and update the weights and biases according to the rules</p>
$$
w_{jk}^l\leftarrow  = w_{jk}^l- \eta \delta_j^la_k^{l-1},
$$


$$
b_j^l \leftarrow b_j^l-\eta \frac{\partial {\cal C}}{\partial b_j^l}=b_j^l-\eta \delta_j^l,
$$


<!-- !split -->
<h2 id="essential-elements-of-generative-models" class="anchor">Essential elements of generative models </h2>

<p>The aim of generative methods is to train a probability distribution \( p \). The methods we will focus on are:</p>
<ol>
<li> Energy based models, with the family of Boltzmann distributions as a typical example</li>
<li> Variational autoencoders, based on our discussions on autoencoders</li>
<li> Generative adversarial networks (GANs) and</li>
<li> Diffusion models</li>
</ol>
<!-- !split -->
<h2 id="energy-models" class="anchor">Energy models </h2>

<p>Last week we defined a domain \( \boldsymbol{X} \) of stochastic variables \( \boldsymbol{X}= \{x_0,x_1, \dots , x_{n-1}\} \) with a pertinent probability distribution</p>
$$
p(\boldsymbol{X})=\prod_{x_i\in \boldsymbol{X}}p(x_i),
$$

<p>where we have assumed that the random varaibles \( x_i \) are all independent and identically distributed (iid).</p>

<p>We will now assume that we can defined this function in terms of optimization parameters \( \boldsymbol{\Theta} \), which could be the biases and weights of deep network, and a set of hidden variables we also assume to be random variables which also are iid. The domain of these variables is
\( \boldsymbol{H}= \{h_0,h_1, \dots , h_{m-1}\} \).
</p>

<!-- !split -->
<h2 id="probability-model" class="anchor">Probability model </h2>

<p>We define a probability</p>
$$
p(x_i,h_j;\boldsymbol{\Theta}) = \frac{f(x_i,h_j;\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})},
$$

<p>where \( f(x_i,h_j;\boldsymbol{\Theta}) \) is a function which we assume is larger or
equal than zero and obeys all properties required for a probability
distribution and \( Z(\boldsymbol{\Theta}) \) is a normalization constant. Inspired by
statistical mechanics, we call it often for the partition function.
It is defined as (assuming that we have discrete probability distributions)
</p>
$$
Z(\boldsymbol{\Theta})=\sum_{x_i\in \boldsymbol{X}}\sum_{h_j\in \boldsymbol{H}} f(x_i,h_j;\boldsymbol{\Theta}).
$$


<!-- !split -->
<h2 id="marginal-and-conditional-probabilities" class="anchor">Marginal and conditional probabilities </h2>

<p>We can in turn define the marginal probabilities</p>
$$
p(x_i;\boldsymbol{\Theta}) = \frac{\sum_{h_j\in \boldsymbol{H}}f(x_i,h_j;\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})},
$$

<p>and </p>
$$
p(h_i;\boldsymbol{\Theta}) = \frac{\sum_{x_i\in \boldsymbol{X}}f(x_i,h_j;\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})}.
$$


<!-- !split -->
<h2 id="change-of-notation" class="anchor">Change of notation </h2>

<p><b>Note the change to a vector notation</b>. A variable like \( \boldsymbol{x} \)
represents now a specific <b>configuration</b>. We can generate an infinity
of such configurations. The final partition function is then the sum
over all such possible configurations, that is
</p>

$$
Z(\boldsymbol{\Theta})=\sum_{x_i\in \boldsymbol{X}}\sum_{h_j\in \boldsymbol{H}} f(x_i,h_j;\boldsymbol{\Theta}),
$$

<p>changes to</p>
$$
Z(\boldsymbol{\Theta})=\sum_{\boldsymbol{x}}\sum_{\boldsymbol{h}} f(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}).
$$

<p>If we have a binary set of variable \( x_i \) and \( h_j \) and \( M \) values of \( x_i \) and \( N \) values of \( h_j \) we have in total \( 2^M \) and \( 2^N \) possible \( \boldsymbol{x} \) and \( \boldsymbol{h} \) configurations, respectively.</p>

<p>We see that even for the modest binary case, we can easily approach a
number of configuration which is not possible to deal with.
</p>

<!-- !split -->
<h2 id="optimization-problem" class="anchor">Optimization problem </h2>

<p>At the end, we are not interested in the probabilities of the hidden variables. The probability we thus want to optimize is </p>
$$
p(\boldsymbol{X};\boldsymbol{\Theta})=\prod_{x_i\in \boldsymbol{X}}p(x_i;\boldsymbol{\Theta})=\prod_{x_i\in \boldsymbol{X}}\left(\frac{\sum_{h_j\in \boldsymbol{H}}f(x_i,h_j;\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})}\right),
$$

<p>which we rewrite as</p>
$$
p(\boldsymbol{X};\boldsymbol{\Theta})=\frac{1}{Z(\boldsymbol{\Theta})}\prod_{x_i\in \boldsymbol{X}}\left(\sum_{h_j\in \boldsymbol{H}}f(x_i,h_j;\boldsymbol{\Theta})\right).
$$


<!-- !split -->
<h2 id="further-simplifications" class="anchor">Further simplifications </h2>

<p>We simplify further by rewriting it as</p>
$$
p(\boldsymbol{X};\boldsymbol{\Theta})=\frac{1}{Z(\boldsymbol{\Theta})}\prod_{x_i\in \boldsymbol{X}}f(x_i;\boldsymbol{\Theta}),
$$

<p>where we used \( p(x_i;\boldsymbol{\Theta}) = \sum_{h_j\in \boldsymbol{H}}f(x_i,h_j;\boldsymbol{\Theta}) \).
The optimization problem is then
</p>
$$
{\displaystyle \mathrm{arg} \hspace{0.1cm}\max_{\boldsymbol{\boldsymbol{\Theta}}\in {\mathbb{R}}^{p}}} \hspace{0.1cm}p(\boldsymbol{X};\boldsymbol{\Theta}).
$$


<!-- !split -->
<h2 id="optimizing-the-logarithm-instead" class="anchor">Optimizing the logarithm instead </h2>

<p>Computing the derivatives with respect to the parameters \( \boldsymbol{\Theta} \) is
easier (and equivalent) with taking the logarithm of the
probability. We will thus optimize
</p>
$$
{\displaystyle \mathrm{arg} \hspace{0.1cm}\max_{\boldsymbol{\boldsymbol{\Theta}}\in {\mathbb{R}}^{p}}} \hspace{0.1cm}\log{p(\boldsymbol{X};\boldsymbol{\Theta})},
$$

<p>which leads to</p>
$$
\nabla_{\boldsymbol{\Theta}}\log{p(\boldsymbol{X};\boldsymbol{\Theta})}=0.
$$


<!-- !split -->
<h2 id="expression-for-the-gradients" class="anchor">Expression for the gradients </h2>
<p>This leads to the following equation</p>
$$
\nabla_{\boldsymbol{\Theta}}\log{p(\boldsymbol{X};\boldsymbol{\Theta})}=\nabla_{\boldsymbol{\Theta}}\left(\sum_{x_i\in \boldsymbol{X}}\log{f(x_i;\boldsymbol{\Theta})}\right)-\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=0.
$$

<p>The first term is called the positive phase and we assume that we have a model for the function \( f \) from which we can sample values. Below we will develop an explicit model for this.
The second term is called the negative phase and is the one which leads to more difficulties.
</p>

<!-- !split -->
<h2 id="the-derivative-of-the-partition-function" class="anchor">The derivative of the partition function </h2>

<p>The partition function, defined above as</p>
$$
Z(\boldsymbol{\Theta})=\sum_{x_i\in \boldsymbol{X}}\sum_{h_j\in \boldsymbol{H}} f(x_i,h_j;\boldsymbol{\Theta}),
$$

<p>is in general the most problematic term. In principle both \( x \) and \( h \) can span large degrees of freedom, if not even infinitely many ones, and computing the partition function itself is often not desirable or even feasible. The above derivative of the partition function can however be written in terms of an expectation value which is in turn evaluated  using Monte Carlo sampling and the theory of Markov chains, popularly shortened to MCMC (or just MC$^2$).</p>

<!-- !split -->
<h2 id="explicit-expression-for-the-derivative" class="anchor">Explicit expression for the derivative </h2>
<p>We can rewrite</p>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\frac{\nabla_{\boldsymbol{\Theta}}Z(\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})},
$$

<p>which reads in more detail</p>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\frac{\nabla_{\boldsymbol{\Theta}} \sum_{x_i\in \boldsymbol{X}}f(x_i;\boldsymbol{\Theta})   }{Z(\boldsymbol{\Theta})}.
$$

<p>We can rewrite the function \( f \) (we have assumed that is larger or
equal than zero) as \( f=\exp{\log{f}} \). We can then reqrite the last
equation as
</p>

$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\frac{ \sum_{x_i\in \boldsymbol{X}} \nabla_{\boldsymbol{\Theta}}\exp{\log{f(x_i;\boldsymbol{\Theta})}}   }{Z(\boldsymbol{\Theta})}.
$$


<!-- !split -->
<h2 id="final-expression" class="anchor">Final expression </h2>

<p>Taking the derivative gives us</p>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\frac{ \sum_{x_i\in \boldsymbol{X}}f(x_i;\boldsymbol{\Theta}) \nabla_{\boldsymbol{\Theta}}\log{f(x_i;\boldsymbol{\Theta})}   }{Z(\boldsymbol{\Theta})}, 
$$

<p>which is the expectation value of \( \log{f} \)</p>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\sum_{x_i\in \boldsymbol{X}}p(x_i;\boldsymbol{\Theta}) \nabla_{\boldsymbol{\Theta}}\log{f(x_i;\boldsymbol{\Theta})},
$$

<p>that is</p>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\mathbb{E}(\log{f(x_i;\boldsymbol{\Theta})}).
$$

<p>This quantity is evaluated using Monte Carlo sampling, with Gibbs
sampling as the standard sampling rule.  Before we discuss the
explicit algorithms, we need to remind ourselves about Markov chains
and sampling rules like the Metropolis-Hastings algorithm and Gibbs
sampling.
</p>

<!-- !split -->
<h2 id="introducing-the-energy-model" class="anchor">Introducing the energy model </h2>

<p>As we will see below, a typical Boltzmann machines employs a probability distribution</p>
$$
p(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}) = \frac{f(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})},
$$

<p>where \( f(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}) \) is given by a so-called energy model. If we assume that the random variables \( x_i \) and \( h_j \) take binary values only, for example \( x_i,h_j=\{0,1\} \), we have a so-called binary-binary model where</p>
$$
f(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta})=-E(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta}) = \sum_{x_i\in \boldsymbol{X}} x_i a_i+\sum_{h_j\in \boldsymbol{H}} b_j h_j + \sum_{x_i\in \boldsymbol{X},h_j\in\boldsymbol{H}} x_i w_{ij} h_j,
$$

<p>where the set of parameters are given by the biases and weights \( \boldsymbol{\Theta}=\{\boldsymbol{a},\boldsymbol{b},\boldsymbol{W}\} \).
<b>Note the vector notation</b> instead of \( x_i \) and \( h_j \) for \( f \). The vectors \( \boldsymbol{x} \) and \( \boldsymbol{h} \) represent a specific instance of stochastic variables \( x_i \) and \( h_j \). These arrangements of \( \boldsymbol{x} \) and \( \boldsymbol{h} \) lead to a specific energy configuration.
</p>

<!-- !split -->
<h2 id="more-compact-notation" class="anchor">More compact notation </h2>

<p>With the above definition we can write the probability as</p>
$$
p(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}) = \frac{\exp{(\boldsymbol{a}^T\boldsymbol{x}+\boldsymbol{b}^T\boldsymbol{h}+\boldsymbol{x}^T\boldsymbol{W}\boldsymbol{h})}}{Z(\boldsymbol{\Theta})},
$$

<p>where the biases \( \boldsymbol{a} \) and \( \boldsymbol{h} \) and the weights defined by the matrix \( \boldsymbol{W} \) are the parameters we need to optimize.</p>

<!-- !split -->
<h2 id="anticipating-results-to-be-derived" class="anchor">Anticipating results to be derived </h2>

<p>Since the binary-binary energy model is linear in the parameters \( a_i \), \( b_j \) and
\( w_{ij} \), it is easy to see that the derivatives with respect to the
various optimization parameters yield expressions used in the
evaluation of gradients like
</p>
$$
\frac{\partial E(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta})}{\partial w_{ij}}=-x_ih_j,
$$

<p>and</p>
$$
\frac{\partial E(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta})}{\partial a_i}=-x_i,
$$

<p>and</p>
$$
\frac{\partial E(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta})}{\partial b_j}=-h_j.
$$


<!-- !split -->
<h2 id="boltzmann-machines-marginal-and-conditional-probabilities" class="anchor">Boltzmann Machines, marginal and conditional probabilities  </h2>

<p>A generative model can learn to represent and sample from a
probability distribution. The core idea is to learn a parametric model
of the probability distribution from which the training data was
drawn. As an example
</p>
<ol>
<li> A model for images could learn to draw new examples of cats and dogs, given a training dataset of images of cats and dogs.</li>
<li> Generate a sample of an ordered or disordered Ising model phase, having been given samples of such phases.</li>
<li> Model the trial function for Monte Carlo calculations</li>
</ol>
<!-- !split -->
<h2 id="generative-and-discriminative-models" class="anchor">Generative and discriminative models </h2>

<p>Generative and discriminative models use both gradient-descent based
learning procedures for minimizing cost functions
</p>

<p>However, in energy based models we don't use backpropagation and automatic
differentiation for computing gradients, instead we turn to Markov
Chain Monte Carlo methods.
</p>

<p>A typical deep neural network has several hidden layers. A restricted
Boltzmann machine has normally one hidden layer, however several RBMs can
be stacked to make up deep Belief Networks, of which they constitute
the building blocks.
</p>

<!-- !split -->
<h2 id="basics-of-the-boltzmann-machine" class="anchor">Basics of the Boltzmann machine </h2>
<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<p>A BM is what we would call an undirected probabilistic graphical model
with stochastic continuous or discrete units.
</p>
</div>
</div>

<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<p>It is interpreted as a stochastic recurrent neural network where the
state of each unit(neurons/nodes) depends on the units it is connected
to. The weights in the network represent thus the strength of the
interaction between various units/nodes.
</p>
</div>
</div>


<!-- !split -->
<h2 id="more-about-the-basics" class="anchor">More about the basics </h2>
<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<p>A standard BM network is divided into a set of observable and visible units \( \boldsymbol{x} \) and a set of unknown hidden units/nodes \( \boldsymbol{h} \).</p>
</div>
</div>


<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<p>Additionally there can be bias nodes for the hidden and visible layers. These biases are normally set to \( 1 \).</p>
</div>
</div>


<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<p>BMs are stackable, meaning they cwe can train a BM which serves as input to another BM. We can construct deep networks for learning complex PDFs. The layers can be trained one after another, a feature which makes them popular in deep learning</p>
</div>
</div>


<!-- !split -->
<h2 id="difficult-to-train" class="anchor">Difficult to train </h2>

<p>However, they are often hard to train. This leads to the introduction
of so-called restricted BMs, or RBMS.  Here we take away all lateral
connections between nodes in the visible layer as well as connections
between nodes in the hidden layer.
</p>

<!-- !split -->
<h2 id="the-network-layers" class="anchor">The network layers </h2>

<ol>
<li> A function \( \boldsymbol{x} \) that represents the visible layer, a vector of \( M \) elements (nodes). This layer represents both what the RBM might be given as training input, and what we want it to be able to reconstruct. This might for example be the pixels of an image, the spin values of the Ising model, or coefficients representing speech.</li>
<li> The function \( \boldsymbol{h} \) represents the hidden, or latent, layer. A vector of \( N \) elements (nodes). Also called "feature detectors".</li>
</ol>
<!-- !split -->
<h2 id="goal-of-hidden-layer" class="anchor">Goal of hidden layer </h2>

<p>The goal of the hidden layer is to increase the model's expressive
power. We encode complex interactions between visible variables by
introducing additional, hidden variables that interact with visible
degrees of freedom in a simple manner, yet still reproduce the complex
correlations between visible degrees in the data once marginalized
over (integrated out).
</p>

<!-- !split -->
<h2 id="the-parameters" class="anchor">The parameters </h2>

<p>The network parameters, to be optimized/learned:</p>
<ol>
<li> \( \boldsymbol{a} \) represents the visible bias, a vector of same length \( M \) as \( \boldsymbol{x} \).</li>
<li> \( \boldsymbol{b} \) represents the hidden bias, a vector of same length \( N \)  as \( \boldsymbol{h} \).</li>
<li> \( \boldsymbol{W} \) represents the interaction weights, a matrix of size \( M\times N \).</li>
</ol>
<p>Note that we have specified the lengths of \( bm{x} \) and \( \boldsymbol{h} \). These
lengths define the number of visible and hidden units, respectively.
</p>

<!-- !split -->
<h2 id="joint-distribution" class="anchor">Joint distribution </h2>

<p>The restricted Boltzmann machine is described by a Boltzmann distribution</p>
$$
\begin{align*}
	P_{rbm}(\boldsymbol{x},\boldsymbol{h},\boldsymbol{\Theta}) = \frac{1}{Z(\boldsymbol{\Theta})} \exp{-(E(\boldsymbol{x},\boldsymbol{h},\boldsymbol{\Theta}))},
\end{align*}
$$

<p>where \( Z \) is the normalization constant or partition function discussed earlier and defined as </p>
$$
\begin{align*}
	Z(\boldsymbol{\Theta}) = \int \int \exp{-E(\boldsymbol{x},\boldsymbol{h},\boldsymbol{\Theta})} d\boldsymbol{x} d\boldsymbol{h}.
\end{align*}
$$

<p>It is common to set  the temperature \( T \) to one. It is omitted in the equations above. The energy is thus a dimensionless function.</p>

<!-- !split -->
<h2 id="network-elements-the-energy-function" class="anchor">Network Elements, the energy function  </h2>

<p>The function \( E(\boldsymbol{x},\boldsymbol{h},\boldsymbol{\Theta}) \) gives the <b>energy</b> of a
configuration (pair of vectors) \( (\boldsymbol{x}, \boldsymbol{h}) \). The lower
the energy of a configuration, the higher the probability of it. This
function also depends on the parameters \( \boldsymbol{a} \), \( \boldsymbol{b} \) and
\( W \). Thus, when we adjust them during the learning procedure, we are
adjusting the energy function to best fit our problem.
</p>

<!-- !split -->
<h2 id="defining-different-types-of-rbms" class="anchor">Defining different types of RBMs </h2>

<p>There are different variants of RBMs, and the differences lie in the types of visible and hidden units we choose as well as in the implementation of the energy function \( E(\boldsymbol{x},\boldsymbol{h},\boldsymbol{\Theta}) \). The connection between the nodes in the two layers is given by the weights \( w_{ij} \). </p>

<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->

<p>RBMs were first developed using binary units in both the visible and hidden layer. The corresponding energy function is defined as follows:</p>
$$
\begin{align*}
	E(\boldsymbol{x}, \boldsymbol{h},\boldsymbol{\Theta}) = - \sum_i^M x_i a_i- \sum_j^N b_j h_j - \sum_{i,j}^{M,N} x_i w_{ij} h_j,
\end{align*}
$$

<p>where the binary values taken on by the nodes are most commonly 0 and 1.</p>
</div>
</div>


<!-- !split -->
<h2 id="gaussian-binary-rbm" class="anchor">Gaussian-binary RBM </h2>

<p>Another varient is the RBM where the visible units are Gaussian while the hidden units remain binary:</p>
$$
\begin{align*}
	E(\boldsymbol{x}, \boldsymbol{h},\boldsymbol{\Theta}) = \sum_i^M \frac{(x_i - a_i)^2}{2\sigma_i^2} - \sum_j^N b_j h_j - \sum_{i,j}^{M,N} \frac{x_i w_{ij} h_j}{\sigma_i^2}. 
\end{align*}
$$

<p>This type of RBMs are useful when we model continuous data (i.e., we wish \( \boldsymbol{x} \) to be continuous). The paramater \( \sigma_i^2 \) is meant to represent a variance and is foten just set to one.</p>

<!-- !split -->
<h2 id="code-for-rbms-using-pytorch" class="anchor">Code for RBMs using PyTorch </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torch</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torch.utils.data</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torch.nn</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">nn</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torch.nn.functional</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">F</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">torch.optim</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">optim</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">torch.autograd</span> <span style="color: #008000; font-weight: bold">import</span> Variable
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">torchvision</span> <span style="color: #008000; font-weight: bold">import</span> datasets, transforms
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">torchvision.utils</span> <span style="color: #008000; font-weight: bold">import</span> make_grid , save_image
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>


batch_size <span style="color: #666666">=</span> <span style="color: #666666">64</span>
train_loader <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>utils<span style="color: #666666">.</span>data<span style="color: #666666">.</span>DataLoader(
datasets<span style="color: #666666">.</span>MNIST(<span style="color: #BA2121">&#39;./data&#39;</span>,
    train<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>,
    download <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>,
    transform <span style="color: #666666">=</span> transforms<span style="color: #666666">.</span>Compose(
        [transforms<span style="color: #666666">.</span>ToTensor()])
     ),
     batch_size<span style="color: #666666">=</span>batch_size
)

test_loader <span style="color: #666666">=</span> torch<span style="color: #666666">.</span>utils<span style="color: #666666">.</span>data<span style="color: #666666">.</span>DataLoader(
datasets<span style="color: #666666">.</span>MNIST(<span style="color: #BA2121">&#39;./data&#39;</span>,
    train<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>,
    transform<span style="color: #666666">=</span>transforms<span style="color: #666666">.</span>Compose(
    [transforms<span style="color: #666666">.</span>ToTensor()])
    ),
    batch_size<span style="color: #666666">=</span>batch_size)


<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">RBM</span>(nn<span style="color: #666666">.</span>Module):
   <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>,
               n_vis<span style="color: #666666">=784</span>,
               n_hin<span style="color: #666666">=500</span>,
               k<span style="color: #666666">=5</span>):
        <span style="color: #008000">super</span>(RBM, <span style="color: #008000">self</span>)<span style="color: #666666">.</span><span style="color: #0000FF">__init__</span>()
        <span style="color: #008000">self</span><span style="color: #666666">.</span>W <span style="color: #666666">=</span> nn<span style="color: #666666">.</span>Parameter(torch<span style="color: #666666">.</span>randn(n_hin,n_vis)<span style="color: #666666">*1e-2</span>)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>v_bias <span style="color: #666666">=</span> nn<span style="color: #666666">.</span>Parameter(torch<span style="color: #666666">.</span>zeros(n_vis))
        <span style="color: #008000">self</span><span style="color: #666666">.</span>h_bias <span style="color: #666666">=</span> nn<span style="color: #666666">.</span>Parameter(torch<span style="color: #666666">.</span>zeros(n_hin))
        <span style="color: #008000">self</span><span style="color: #666666">.</span>k <span style="color: #666666">=</span> k
    
   <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sample_from_p</span>(<span style="color: #008000">self</span>,p):
       <span style="color: #008000; font-weight: bold">return</span> F<span style="color: #666666">.</span>relu(torch<span style="color: #666666">.</span>sign(p <span style="color: #666666">-</span> Variable(torch<span style="color: #666666">.</span>rand(p<span style="color: #666666">.</span>size()))))
    
   <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">v_to_h</span>(<span style="color: #008000">self</span>,v):
        p_h <span style="color: #666666">=</span> F<span style="color: #666666">.</span>sigmoid(F<span style="color: #666666">.</span>linear(v,<span style="color: #008000">self</span><span style="color: #666666">.</span>W,<span style="color: #008000">self</span><span style="color: #666666">.</span>h_bias))
        sample_h <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>sample_from_p(p_h)
        <span style="color: #008000; font-weight: bold">return</span> p_h,sample_h
    
   <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">h_to_v</span>(<span style="color: #008000">self</span>,h):
        p_v <span style="color: #666666">=</span> F<span style="color: #666666">.</span>sigmoid(F<span style="color: #666666">.</span>linear(h,<span style="color: #008000">self</span><span style="color: #666666">.</span>W<span style="color: #666666">.</span>t(),<span style="color: #008000">self</span><span style="color: #666666">.</span>v_bias))
        sample_v <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>sample_from_p(p_v)
        <span style="color: #008000; font-weight: bold">return</span> p_v,sample_v
        
   <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">forward</span>(<span style="color: #008000">self</span>,v):
        pre_h1,h1 <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>v_to_h(v)
        
        h_ <span style="color: #666666">=</span> h1
        <span style="color: #008000; font-weight: bold">for</span> _ <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>k):
            pre_v_,v_ <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>h_to_v(h_)
            pre_h_,h_ <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>v_to_h(v_)
        
        <span style="color: #008000; font-weight: bold">return</span> v,v_
    
   <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">free_energy</span>(<span style="color: #008000">self</span>,v):
        vbias_term <span style="color: #666666">=</span> v<span style="color: #666666">.</span>mv(<span style="color: #008000">self</span><span style="color: #666666">.</span>v_bias)
        wx_b <span style="color: #666666">=</span> F<span style="color: #666666">.</span>linear(v,<span style="color: #008000">self</span><span style="color: #666666">.</span>W,<span style="color: #008000">self</span><span style="color: #666666">.</span>h_bias)
        hidden_term <span style="color: #666666">=</span> wx_b<span style="color: #666666">.</span>exp()<span style="color: #666666">.</span>add(<span style="color: #666666">1</span>)<span style="color: #666666">.</span>log()<span style="color: #666666">.</span>sum(<span style="color: #666666">1</span>)
        <span style="color: #008000; font-weight: bold">return</span> (<span style="color: #666666">-</span>hidden_term <span style="color: #666666">-</span> vbias_term)<span style="color: #666666">.</span>mean()




rbm <span style="color: #666666">=</span> RBM(k<span style="color: #666666">=1</span>)
train_op <span style="color: #666666">=</span> optim<span style="color: #666666">.</span>SGD(rbm<span style="color: #666666">.</span>parameters(),<span style="color: #666666">0.1</span>)

<span style="color: #008000; font-weight: bold">for</span> epoch <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">10</span>):
    loss_ <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> _, (data,target) <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(train_loader):
        data <span style="color: #666666">=</span> Variable(data<span style="color: #666666">.</span>view(<span style="color: #666666">-1</span>,<span style="color: #666666">784</span>))
        sample_data <span style="color: #666666">=</span> data<span style="color: #666666">.</span>bernoulli()
        
        v,v1 <span style="color: #666666">=</span> rbm(sample_data)
        loss <span style="color: #666666">=</span> rbm<span style="color: #666666">.</span>free_energy(v) <span style="color: #666666">-</span> rbm<span style="color: #666666">.</span>free_energy(v1)
        loss_<span style="color: #666666">.</span>append(loss<span style="color: #666666">.</span>data)
        train_op<span style="color: #666666">.</span>zero_grad()
        loss<span style="color: #666666">.</span>backward()
        train_op<span style="color: #666666">.</span>step()

    <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;Training loss for </span><span style="color: #BB6688; font-weight: bold">{}</span><span style="color: #BA2121"> epoch: </span><span style="color: #BB6688; font-weight: bold">{}</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>format(epoch, np<span style="color: #666666">.</span>mean(loss_)))


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">show_adn_save</span>(file_name,img):
    npimg <span style="color: #666666">=</span> np<span style="color: #666666">.</span>transpose(img<span style="color: #666666">.</span>numpy(),(<span style="color: #666666">1</span>,<span style="color: #666666">2</span>,<span style="color: #666666">0</span>))
    f <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;./</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">.png&quot;</span> <span style="color: #666666">%</span> file_name
    plt<span style="color: #666666">.</span>imshow(npimg)
    plt<span style="color: #666666">.</span>imsave(f,npimg)

show_adn_save(<span style="color: #BA2121">&quot;real&quot;</span>,make_grid(v<span style="color: #666666">.</span>view(<span style="color: #666666">32</span>,<span style="color: #666666">1</span>,<span style="color: #666666">28</span>,<span style="color: #666666">28</span>)<span style="color: #666666">.</span>data))
show_adn_save(<span style="color: #BA2121">&quot;generate&quot;</span>,make_grid(v1<span style="color: #666666">.</span>view(<span style="color: #666666">32</span>,<span style="color: #666666">1</span>,<span style="color: #666666">28</span>,<span style="color: #666666">28</span>)<span style="color: #666666">.</span>data))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split -->
<h2 id="energy-based-models-and-langevin-sampling" class="anchor">Energy-based models and Langevin sampling </h2>

<p>See discussions in Foster, chapter 7 on energy-based models at <a href="https://github.com/davidADSP/Generative_Deep_Learning_2nd_Edition/tree/main/notebooks/07_ebm/01_ebm" target="_self"><tt>https://github.com/davidADSP/Generative_Deep_Learning_2nd_Edition/tree/main/notebooks/07_ebm/01_ebm</tt></a></p>

<p>That notebook is based on a recent article by Du and Mordatch, <b>Implicit generation and modeling with energy-based models</b>, see <a href="https://arxiv.org/pdf/1903.08689.pdf." target="_self"><tt>https://arxiv.org/pdf/1903.08689.pdf.</tt></a></p>

<!-- !split -->
<h2 id="tensor-flow-examples" class="anchor">Tensor-flow examples </h2>

<ol>
<li> To create Boltzmann machine using Keras, see Babcock and Bali chapter 4, see <a href="https://github.com/PacktPublishing/Hands-On-Generative-AI-with-Python-and-TensorFlow-2/blob/master/Chapter_4/models/rbm.py" target="_self"><tt>https://github.com/PacktPublishing/Hands-On-Generative-AI-with-Python-and-TensorFlow-2/blob/master/Chapter_4/models/rbm.py</tt></a></li>
<li> See also Foster, chapter 7 on energy-based models at <a href="https://github.com/davidADSP/Generative_Deep_Learning_2nd_Edition/tree/main/notebooks/07_ebm/01_ebm" target="_self"><tt>https://github.com/davidADSP/Generative_Deep_Learning_2nd_Edition/tree/main/notebooks/07_ebm/01_ebm</tt></a></li>
</ol>
<!-- !split -->
<h2 id="kullback-leibler-divergence" class="anchor">Kullback-Leibler divergence </h2>

<p>Before we continue, we need to remind ourselves about the
Kullback-Leibler divergence introduced earlier. This will also allow
us to introduce another measure used in connection with the training
of Generative Adversarial Networks, the so-called Jensen-Shannon divergence..
These metrics are useful for quantifying the similarity between two probability distributions.
</p>

<p>The Kullback&#8211;Leibler (KL) divergence, labeled \( D_{KL} \),   measures how one probability distribution \( p \) diverges from a second expected probability distribution \( q \),
that is
</p>
$$
D_{KL}(p \| q) = \int_x p(x) \log \frac{p(x)}{q(x)} dx.
$$

<p>The KL-divegrnece \( D_{KL} \) achieves the minimum zero when \( p(x) == q(x) \) everywhere.</p>

<p>Note that the KL divergence is asymmetric. In cases where \( p(x) \) is
close to zero, but \( q(x) \) is significantly non-zero, the \( q \)'s effect
is disregarded. It could cause buggy results when we just want to
measure the similarity between two equally important distributions.
</p>

<!-- !split -->
<h2 id="jensen-shannon-divergence" class="anchor">Jensen-Shannon divergence </h2>

<p>The Jensen&#8211;Shannon (JS) divergence is another measure of similarity between
two probability distributions, bounded by \( [0, 1] \). The JS-divergence is
symmetric and more smooth than the KL-divergence.
It is defined as
</p>
$$
D_{JS}(p \| q) = \frac{1}{2} D_{KL}(p \| \frac{p + q}{2}) + \frac{1}{2} D_{KL}(q \| \frac{p + q}{2})
$$

<p>Many practitioners believe that one reason behind GANs' big success is
switching the loss function from asymmetric KL-divergence in
traditional maximum-likelihood approach to symmetric JS-divergence.
</p>

<!-- !split -->
<h2 id="generative-model-basic-overview-borrowed-from-rashcka-et-al" class="anchor">Generative model,  basic overview (Borrowed from Rashcka et al) </h2>

<!-- FIGURE: [figures/figure1.png, width=900 frac=1.0] -->

<!-- !split -->
<h2 id="reminder-on-vaes" class="anchor">Reminder on VAEs </h2>

<p>Mathematically, we can imagine the latent variables and the data we
observe as modeled by a joint distribution \( p(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta}) \).  Recall one
approach of generative modeling, termed likelihood-based, is to
learn a model to maximize the likelihood \( p(\boldsymbol{x};\boldsymbol{\Theta}) \) of all observed
\( \boldsymbol{x} \).  There are two ways we can manipulate this joint distribution
to recover the likelihood of purely our observed data \( p(\boldsymbol{x};\boldsymbol{\Theta}) \); we can
explicitly marginalize
out the latent variable \( \boldsymbol{h} \)
</p>
$$
\begin{equation*}
p(\boldsymbol{x}) = \int p(\boldsymbol{x}, \boldsymbol{h})d\boldsymbol{h}
\end{equation*}
$$

<p>or, we could also appeal to the chain rule of probability</p>
$$
\begin{equation*}
p(\boldsymbol{x}) = \frac{p(\boldsymbol{x}, \boldsymbol{h})}{p(\boldsymbol{h}|\boldsymbol{x})}
\end{equation*}
$$

<p>We suppress here the dependence	on the optimization parameters \( \boldsymbol{\Theta} \).</p>

<!-- !split -->
<h2 id="evidence-lower-bound" class="anchor">Evidence Lower Bound </h2>
<p>Directly computing and maximizing the likelihood \( p(\boldsymbol{x}) \) is
difficult because it either involves integrating out all latent
variables \( \boldsymbol{h} \), which is intractable for
complex models, or it involves having access to a ground truth latent
encoder \( p(\boldsymbol{h}|\boldsymbol{x}) \).
</p>

<p>Using the last  two equations, we can derive a term called the Evidence Lower Bound (ELBO), which as its name suggests, is a lower
  bound of the evidence.  The evidence is quantified in this case as
the log likelihood of the observed data.  Then, maximizing the ELBO
becomes a proxy objective with which to optimize a latent variable
model; in the best case, when the ELBO is powerfully parameterized and
perfectly optimized, it becomes exactly equivalent to the evidence.
</p>

<!-- !split -->
<h2 id="elbo-equations" class="anchor">ELBO equations </h2>
<p>Formally, the equation of the ELBO is</p>
$$
\begin{equation*}
\mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\left[\log\frac{p(\boldsymbol{x}, \boldsymbol{h})}{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\right]
\end{equation*}
$$

<p>To make the relationship with the evidence explicit, we can mathematically write:</p>
$$
\begin{equation*}
\log p(\boldsymbol{x}) \geq \mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\left[\log\frac{p(\boldsymbol{x}, \boldsymbol{h})}{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\right]
\end{equation*}
$$


<!-- !split -->
<h2 id="introducing-the-encoder-function" class="anchor">Introducing the encoder function </h2>

<p>Here, \( q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x}) \) is a flexible approximate
variational distribution with parameters \( \boldsymbol{\phi} \) that we seek to
optimize.  Intuitively, it can be thought of as a parameterizable
model that is learned to estimate the true distribution over latent
variables for given observations \( \boldsymbol{x} \); in other words, it seeks to
approximate true posterior \( p(\boldsymbol{h}|\boldsymbol{x}) \).  As we saw last week when we
explored Variational Autoencoders, as we increase the lower bound
by tuning the parameters \( \boldsymbol{\phi} \) to maximize the ELBO, we gain
access to components that can be used to model the true data
distribution and sample from it, thus learning a generative model.
</p>

<!-- !split -->
<h2 id="elbo" class="anchor">ELBO  </h2>

<p>To better understand the relationship between the evidence and the ELBO, let us perform another derivation, this time using</p>

$$
\begin{align*}
\log p(\boldsymbol{x}) & = \log p(\boldsymbol{x}) \int q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})d\boldsymbol{h} && \text{(Multiply by $1 = \int q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})d\boldsymbol{h}$)}\\
          & = \int q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})(\log p(\boldsymbol{x}))d\boldsymbol{h} && \text{(Bring evidence into integral)}\\
          & = \mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\left[\log p(\boldsymbol{x})\right] && \text{(Definition of Expectation)}\\
          & = \mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\left[\log\frac{p(\boldsymbol{x}, \boldsymbol{h})}{p(\boldsymbol{h}|\boldsymbol{x})}\right]&& \\
          & = \mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\left[\log\frac{p(\boldsymbol{x}, \boldsymbol{h})q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}{p(\boldsymbol{h}|\boldsymbol{x})q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\right]&& \text{(Multiply by $1 = \frac{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}$)}\\
          & = \mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\left[\log\frac{p(\boldsymbol{x}, \boldsymbol{h})}{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\right] + \mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\left[\log\frac{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}{p(\boldsymbol{h}|\boldsymbol{x})}\right] && \text{(Split the Expectation)}\\
          & = \mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\left[\log\frac{p(\boldsymbol{x}, \boldsymbol{h})}{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\right] +
	  D_{KL}(q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})\vert\vert p(\boldsymbol{h}|\boldsymbol{x}))  && \text{(Definition of KL Divergence)}\\
          & \geq \mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\left[\log\frac{p(\boldsymbol{x}, \boldsymbol{h})}{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\right]  && \text{(KL Divergence always $\geq 0$)}
\end{align*}
$$


<!-- !split -->
<h2 id="analysis" class="anchor">Analysis </h2>

<p>From this derivation, we clearly observe from the last equation
that the evidence is equal to the ELBO plus the KL Divergence between
the approximate posterior \( q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x}) \) and the true
posterior \( p(\boldsymbol{h}|\boldsymbol{x}) \).  Understanding this term is the
key to understanding not only the relationship between the ELBO and
the evidence, but also the reason why optimizing the ELBO is an
appropriate objective at all.
</p>

<!-- !split -->
<h2 id="the-vae" class="anchor">The VAE </h2>

<p>In the default formulation of the VAE by Kingma and Welling (2015), we directly maximize the ELBO.  This
approach is \textit{variational}, because we optimize for the best
\( q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x}) \) amongst a family of potential posterior
distributions parameterized by \( \boldsymbol{\phi} \).  It is called an
\textit{autoencoder} because it is reminiscent of a traditional
autoencoder model, where input data is trained to predict itself after
undergoing an intermediate bottlenecking representation step.
</p>

<!-- !split -->
<h2 id="dissecting-the-equations" class="anchor">Dissecting the equations </h2>
<p>To make
this connection explicit, let us dissect the ELBO term further:
</p>

$$
\begin{align*}
{\mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\left[\log\frac{p(\boldsymbol{x}, \boldsymbol{h})}{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\right]}
&= {\mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\left[\log\frac{p_{\boldsymbol{\theta}}(\boldsymbol{x}|\boldsymbol{h})p(\boldsymbol{h})}{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\right]}         && {\text{(Chain Rule of Probability)}}\\
&= {\mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\left[\log p_{\boldsymbol{\theta}}(\boldsymbol{x}|\boldsymbol{h})\right] + \mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\left[\log\frac{p(\boldsymbol{h})}{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\right]}         && {\text{(Split the Expectation)}}\\
&= \underbrace{{\mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\left[\log p_{\boldsymbol{\theta}}(\boldsymbol{x}|\boldsymbol{h})\right]}}_\text{reconstruction term} - \underbrace{{D_{KL}(q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\vert\vert{p(\boldsymbol{h}))}}_\text{prior matching term} && {\text{(Definition of KL Divergence)}}
\end{align*}
$$


<!-- !split -->
<h2 id="bottlenecking-distribution" class="anchor">Bottlenecking distribution </h2>

<p>In this case, we learn an intermediate bottlenecking distribution
\( q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x}) \) that can be treated as
an \textit{encoder}; it transforms inputs into a distribution over
possible latents.  Simultaneously, we learn a deterministic function
\( p_{\boldsymbol{\theta}}(\boldsymbol{x}|\boldsymbol{h}) \) to convert a given latent vector
\( \boldsymbol{h} \) into an observation \( \boldsymbol{x} \), which can be interpreted as
a \textit{decoder}.
</p>

<!-- !split -->
<h2 id="decoder-and-encoder" class="anchor">Decoder and encoder </h2>
<p>The two terms in the last equation each have intuitive descriptions: the first
term measures the reconstruction likelihood of the decoder from our
variational distribution; this ensures that the learned distribution
is modeling effective latents that the original data can be
regenerated from.  The second term measures how similar the learned
variational distribution is to a prior belief held over latent
variables.  Minimizing this term encourages the encoder to actually
learn a distribution rather than collapse into a Dirac delta function.
Maximizing the ELBO is thus equivalent to maximizing its first term
and minimizing its second term.
</p>

<!-- !split -->
<h2 id="defining-feature-of-vaes" class="anchor">Defining feature of VAEs </h2>

<p>A defining feature of the VAE is how the ELBO is optimized jointly over parameters \( \boldsymbol{\phi} \) and \( \boldsymbol{\theta} \).  The encoder of the VAE is commonly chosen to model a multivariate Gaussian with diagonal covariance, and the prior is often selected to be a standard multivariate Gaussian: </p>
$$
\begin{align*}
    q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x}) &= N(\boldsymbol{h}; \boldsymbol{\mu}_{\boldsymbol{\phi}}(\boldsymbol{x}), \boldsymbol{\sigma}_{\boldsymbol{\phi}}^2(\boldsymbol{x})\textbf{I})\\
    p(\boldsymbol{h}) &= N(\boldsymbol{h}; \boldsymbol{0}, \textbf{I})
\end{align*}
$$


<!-- !split -->
<h2 id="analytical-evaluation" class="anchor">Analytical evaluation </h2>

<p>Then, the KL divergence term of the ELBO can be computed analytically, and the reconstruction term can be approximated using a Monte Carlo estimate.  Our objective can then be rewritten as:</p>
$$
\begin{align*}
  \mathrm{argmax}_{\boldsymbol{\phi}, \boldsymbol{\theta}} \mathbb{E}_{q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})}\left[\log p_{\boldsymbol{\theta}}(\boldsymbol{x}|\boldsymbol{h})\right] - D_{KL}(q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})\vert\vert p(\boldsymbol{h})) \approx \mathrm{argmax}_{\boldsymbol{\phi}, \boldsymbol{\theta}} \sum_{l=1}^{L}\log p_{\boldsymbol{\theta}}(\boldsymbol{x}|\boldsymbol{h}^{(l)}) - D_{KL}(q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x})\vert\vert p(\boldsymbol{h}))
\end{align*}
$$

<p>where latents \( \{\boldsymbol{h}^{(l)}\}_{l=1}^L \) are sampled from \( q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x}) \), for every observation \( \boldsymbol{x} \) in the dataset.</p>

<!-- !split -->
<h2 id="reparameterization-trick" class="anchor">Reparameterization trick </h2>

<p>However, a problem arises in this default setup: each \( \boldsymbol{h}^{(l)} \)
that our loss is computed on is generated by a stochastic sampling
procedure, which is generally non-differentiable.  Fortunately, this
can be addressed via the \textit{reparameterization trick} when
\( q_{\boldsymbol{\phi}}(\boldsymbol{h}|\boldsymbol{x}) \) is designed to model certain
distributions, including the multivariate Gaussian.
</p>

<!-- !split -->
<h2 id="actual-implementation" class="anchor">Actual implementation </h2>

<p>The reparameterization trick rewrites a random variable as a
deterministic function of a noise variable; this allows for the
optimization of the non-stochastic terms through gradient descent.
For example, samples from a normal distribution
\( x \sim N(x;\mu, \sigma^2) \) with arbitrary mean \( \mu \) and
variance \( \sigma^2 \) can be rewritten as
</p>

$$
\begin{align*}
    x &= \mu + \sigma\epsilon \quad \text{with } \epsilon \sim N(\epsilon; 0, \boldsymbol{I})
\end{align*}
$$


<!-- !split -->
<h2 id="interpretation" class="anchor">Interpretation </h2>
<p>An arbitrary Gaussian distributions can be interpreted as
standard Gaussians (of which \( \epsilon \) is a sample) that have their
mean shifted from zero to the target mean \( \mu \) by addition, and their
variance stretched by the target variance \( \sigma^2 \).  Therefore, by
the reparameterization trick, sampling from an arbitrary Gaussian
distribution can be performed by sampling from a standard Gaussian,
scaling the result by the target standard deviation, and shifting it
by the target mean.
</p>

<!-- !split -->
<h2 id="deterministic-function" class="anchor">Deterministic function  </h2>

<p>In a VAE, each \( \boldsymbol{h} \) is thus computed as a deterministic function of input \( \boldsymbol{x} \) and auxiliary noise variable \( \boldsymbol{\epsilon} \):</p>
$$
\begin{align*}
    \boldsymbol{h} &= \boldsymbol{\mu}_{\boldsymbol{\phi}}(\boldsymbol{x}) + \boldsymbol{\sigma}_{\boldsymbol{\phi}}(\boldsymbol{x})\odot\boldsymbol{\epsilon} \quad \text{with } \boldsymbol{\epsilon} \sim N(\boldsymbol{\epsilon};\boldsymbol{0}, \textbf{I})
\end{align*}
$$

<p>where \( \odot \) represents an element-wise product.  Under this
reparameterized version of \( \boldsymbol{h} \), gradients can then be computed
with respect to \( \boldsymbol{\phi} \) as desired, to optimize
\( \boldsymbol{\mu}_{\boldsymbol{\phi}} \) and \( \boldsymbol{\sigma}_{\boldsymbol{\phi}} \).  The VAE
therefore utilizes the reparameterization trick and Monte Carlo
estimates to optimize the ELBO jointly over \( \boldsymbol{\phi} \) and
\( \boldsymbol{\theta} \).
</p>

<!-- !split -->
<h2 id="after-training" class="anchor">After training </h2>

<p>After training a VAE, generating new data can be performed by sampling
directly from the latent space \( p(\boldsymbol{h}) \) and then running it through
the decoder.  Variational Autoencoders are particularly interesting
when the dimensionality of \( \boldsymbol{h} \) is less than that of input
\( \boldsymbol{x} \), as we might then be learning compact, useful
representations.  Furthermore, when a semantically meaningful latent
space is learned, latent vectors can be edited before being passed to
the decoder to more precisely control the data generated.
</p>

<!-- ------------------- end of main content --------------- -->
</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<!-- Bootstrap footer
<footer>
<a href="https://..."><img width="250" align=right src="https://..."></a>
</footer>
-->
<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2024, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>
</body>
</html>

