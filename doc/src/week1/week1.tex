
% LaTeX Beamer file automatically generated from DocOnce
% https://github.com/doconce/doconce

%-------------------- begin beamer-specific preamble ----------------------

\documentclass{beamer}

\usetheme{red_plain}
\usecolortheme{default}

% turn off the almost invisible, yet disturbing, navigation symbols:
\setbeamertemplate{navigation symbols}{}

% Examples on customization:
%\usecolortheme[named=RawSienna]{structure}
%\usetheme[height=7mm]{Rochester}
%\setbeamerfont{frametitle}{family=\rmfamily,shape=\itshape}
%\setbeamertemplate{items}[ball]
%\setbeamertemplate{blocks}[rounded][shadow=true]
%\useoutertheme{infolines}
%
%\usefonttheme{}
%\useinntertheme{}
%
%\setbeameroption{show notes}
%\setbeameroption{show notes on second screen=right}

% fine for B/W printing:
%\usecolortheme{seahorse}

\usepackage{pgf}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{relsize}

\usepackage{fancybox}  % make sure fancybox is loaded before fancyvrb

\usepackage{fancyvrb}
%\usepackage{minted} % requires pygments and latex -shell-escape filename
%\usepackage{anslistings}
%\usepackage{listingsutf8}

\usepackage{amsmath,amssymb,bm}
%\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{colortbl}
\usepackage[english]{babel}
\usepackage{tikz}
\usepackage{framed}
% Use some nice templates
\beamertemplatetransparentcovereddynamic

% --- begin table of contents based on sections ---
% Delete this, if you do not want the table of contents to pop up at
% the beginning of each section:
% (Only section headings can enter the table of contents in Beamer
% slides generated from DocOnce source, while subsections are used
% for the title in ordinary slides.)
\AtBeginSection[]
{
  \begin{frame}<beamer>[plain]
  \frametitle{}
  %\frametitle{Outline}
  \tableofcontents[currentsection]
  \end{frame}
}
% --- end table of contents based on sections ---

% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command:

%\beamerdefaultoverlayspecification{<+->}

\newcommand{\shortinlinecomment}[3]{\note{\textbf{#1}: #2}}
\newcommand{\longinlinecomment}[3]{\shortinlinecomment{#1}{#2}{#3}}

\definecolor{linkcolor}{rgb}{0,0,0.4}
\hypersetup{
    colorlinks=true,
    linkcolor=linkcolor,
    urlcolor=linkcolor,
    pdfmenubar=true,
    pdftoolbar=true,
    bookmarksdepth=3
    }
\setlength{\parskip}{0pt}  % {1em}

\newenvironment{doconceexercise}{}{}
\newcounter{doconceexercisecounter}
\newenvironment{doconce:movie}{}{}
\newcounter{doconce:movie:counter}

\newcommand{\subex}[1]{\noindent\textbf{#1}}  % for subexercises: a), b), etc

\logo{{\tiny \copyright\ 1999-2026, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license}}

%-------------------- end beamer-specific preamble ----------------------

% Add user's preamble




% insert custom LaTeX commands...

\raggedbottom
\makeindex

%-------------------- end preamble ----------------------

\begin{document}

% matching end for #ifdef PREAMBLE

\newcommand{\exercisesection}[1]{\subsection*{#1}}



% ------------------- main content ----------------------



% ----------------- title -------------------------

\title{Advanced machine learning and data analysis for the physical sciences}

% ----------------- author(s) -------------------------

\author{Morten Hjorth-Jensen\inst{1}}
\institute{Department of Physics and Center for Computing in Science Education, University of Oslo, Norway\inst{1}}
% ----------------- end author(s) -------------------------

\date{January 22, 2026
% <optional titlepage figure>
\ \\ 
{\tiny \copyright\ 1999-2026, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license}
}

\begin{frame}[plain,fragile]
\titlepage
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Overview of first week, January 19-23, 2026}

\begin{block}{}
\begin{itemize}
\item Presentation of course

\item Discussion of possible projects

\item Deep learning methods, mathematics and  review of neural networks
% o "Video of lecture at \href{{https://youtu.be/SY57dC46L9o}}{\nolinkurl{https://youtu.be/SY57dC46L9o}}

\item Recommended reading first three weeks: Raschka et al chapters 11-12 and Goodfellow et al chapters 6-8
\begin{itemize}

 \item Permanent Zoom link for the whole semester is \href{{https://uio.zoom.us/my/mortenhj}}{\nolinkurl{https://uio.zoom.us/my/mortenhj}}
\end{itemize}

\noindent
\end{itemize}

\noindent
\end{block}
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Practicalities}

\begin{itemize}
\item Lectures Thursdays 1015am-12pm, room FØ434, Department of Physics

\item Lab and exercise sessions Thursdays 1215pm-2pm, room FØ434, Department of Physics. First time january 29. Note that this is not in the official schedule.

\item We plan to work on two projects which will define the content of the course, the format can be agreed upon by the participants. Alternatively, one project only.

\item No exam, only two projects. Each projects counts 1/2 of the final grade. Alternatively, one long project which counts 100\% of the final grade

\item All info at the GitHub address \href{{https://github.com/CompPhysics/AdvancedMachineLearning}}{\nolinkurl{https://github.com/CompPhysics/AdvancedMachineLearning}}
\end{itemize}

\noindent
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Deep learning methods covered, tentative}

\begin{itemize}
\item \textbf{Deep learning}, often described as discriminative methods
\begin{enumerate}

 \item Feed forward neural networks and its mathematics (NNs)

 \item Convolutional neural networks (CNNs)

 \item Recurrent neural networks (RNNs)

 \item Autoencoders and principal component analysis

 \item Transformers  (tentative)
\end{enumerate}

\noindent
\end{itemize}

\noindent
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Generative methods}

\begin{itemize}
\item \textbf{Deep learning, generative methods}
\begin{enumerate}

 \item Basics of generative models

 \item Boltzmann machines and energy based methods

 \item Diffusion models

 \item Variational autoencoders (VAEe)

 \item Generative Adversarial Networks (GANs)

 \item Autoregressive methods (tentative)
\end{enumerate}

\noindent
\end{itemize}

\noindent
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Reinforcement learning}

\begin{itemize}
\item Basics of rerinforcement learning (tentative)
\end{itemize}

\noindent
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Both discriminative and generative}

\begin{itemize}
\item \textbf{Physics informed neural networks, PINNs}
\end{itemize}

\noindent
Projects can in general be designed to fit specific scientific goals
and research paths of the participants.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{AI agents for Science}

This is a topic we won't be able to cover, but for those interested, these series of lectures are excellent, see
\begin{enumerate}
\item \href{{https://agents4science.github.io/Class/curriculum.html}}{\nolinkurl{https://agents4science.github.io/Class/curriculum.html}}
\end{enumerate}

\noindent
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{\href{{https://jenfb.github.io/bkmr/overview.html}}{Additional topics:  Kernel regression (Gaussian processes) and Bayesian statistics}}

Kernel machine regression (KMR), also called Gaussian process
regression, is a popular tool in the machine learning literature. The
main idea behind KMR is to flexibly model the relationship between a
large number of variables and a particular outcome (dependent
variable).

These topics are not covered by the lectures but can be used to define projects.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Good books with hands-on material and codes}

\begin{block}{}
\begin{itemize}
\item \href{{https://sebastianraschka.com/blog/2022/ml-pytorch-book.html}}{Sebastian Rashcka et al, Machine learning with Sickit-Learn and PyTorch}

\item \href{{https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html}}{David Foster, Generative Deep Learning with TensorFlow}

\item \href{{https://github.com/PacktPublishing/Hands-On-Generative-AI-with-Python-and-TensorFlow-2}}{Bali and Gavras, Generative AI with Python and TensorFlow 2}
\end{itemize}

\noindent
\end{block}

All three books have GitHub addresses from where  one can download all codes. We will borrow most of the material from these three texts as well as 
from Goodfellow, Bengio and Courville's text \href{{https://www.deeplearningbook.org/}}{Deep Learning}
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Project paths, overarching view}

The course can also be used as a self-study course and besides the
lectures, many of you may wish to independently work on your own
projects related to for example your thesis project or own
research. In general, we have often followed five main paths for the
project(s). Below is a description of the various possibilities and
how they link with the lectures.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Project options}

The lectures during the first part of the semester deal with deep learning methods and their mathematics, including
\begin{itemize}
\item Neural networks (NNs)

\item Convolutional neural networks (CNNs)

\item Recurrent neural networks (RNNs)

\item Autoencoders (AEs)
\end{itemize}

\noindent
Based on these topics we can define one project with deadline March 20
or a one semester-long project with final deadline June 1 that focuses
on

\begin{itemize}
\item Physics Informed neural network path (PINNs) with a focus on partial differential equations (PDEs). Here we define some basic PDEs which are solved by using PINNs. We start normally with studies of selected PDEs using NNs. These can be expanded to include studies of RNNs and/or Autoencoders. In the lectures we will use selected PDEs to illustrate how we can use neural networks to solve differential equations.
\end{itemize}

\noindent
For coding, we leave it to you to decide if you wish to write your own
code or use deep learning libraries like PyTorch, Tensorflow/Keras, or
other.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Classification projects}

For the first part of the semester, focusing on the same methods as above, you can study (either with own data or data suggested by us) classification problems with
\begin{itemize}
\item NNs, CNNs and AEs (and possibly RNNs if you have classification problems with a temporal dependence). This topic can be extended to a full project (semester-long variant) where you also include the generative methods discussed below.
\end{itemize}

\noindent
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Mathematics of deep learning}

This project aims to bridge theoretical mathematics with practical
deep learning by developing neural networks for both regression and
classification tasks. The objective is to demonstrate how core
mathematical concepts such as linear algebra, multivariate calculus,
optimization theory, and probability, directly inform the design and
training of neural networks. In essence, familiar math tools (matrix
operations, derivatives, gradient-based optimization, probabilistic
loss functions) form the backbone of deep learning.

By tying theory to implementation, the project aims at 
illustrating that every practical behavior of a neural network
(convergence, generalization, etc.) has a mathematical explanation.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{High-performance computing path}

The previous project could be extended by adding an explicit
high-performance computing element.  The goal of this project could be
to study \emph{feed-forward neural networks} as mathematical objects and
numerical algorithms, with particular emphasis on how their structure
interacts with GPU architectures. The project combines theoretical
analysis (linear algebra, calculus, optimization, and numerical
stability) with practical implementation and performance modeling on
CPUs and GPUs.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Write your own CNN or RNN (or even a light LLM) from scratch}

Here we propose a path where you develop your own code for a
convolutional or eventually recurrent neural network and apply this to
data of your own selection. The code should be object oriented and
flexible allowing for eventual extensions by including different
Loss/Cost functions and other functionalities. Feel free to select
data sets from those suggested by us or use your own data.  This code
can also be extended upon by adding for example autoencoders. You can
compare your own codes with implementations using
TensorFlow(Keras)/PyTorch or other libraries.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Projects which link with the second part of the lectures}

In the second part of the lectures, we will focus on generative methods, with an emphasis on
\begin{itemize}
\item Boltzmann machines and energy based methods

\item Diffusion models

\item Variational autoencoders (VAEe)

\item Generative Adversarial Networks (GANs)

\item Autoregressive methods (tentative)
\end{itemize}

\noindent
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Generative modeling}

This proposal can be aligned with the classification project that
includes CNNs and AEs.  Deep learning methods can broadly be divided
into discriminative models, which learn decision boundaries for
labeled data, and generative models, which learn probability
distributions over data. CNNs dominate in classification tasks, while
generative models such as VAEs, Boltzmann machines, and diffusion
models provide probabilistic descriptions of data and enable
synthesis, uncertainty quantification, and representation learning.

The goal of this project is to develop a unified mathematical and
computational understanding of these model classes. Here one can 
analyze classification and generative learning as optimization
problems over high-dimensional function spaces, emphasizing
probabilistic modeling, variational principles, and numerical
optimization.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Reinforcement learning, PDE part}

Reinforcement learning (RL) and modern generative models are
increasingly understood through the lens of partial differential
equations (PDEs), stochastic processes, and variational
principles. Reinforcement learning is closely related to optimal
control and Hamilton--Jacobi--Bellman (HJB) equations, while
generative models such as diffusion models are
connected to Fokker--Planck equations, stochastic differential
equations (SDEs), and gradient flows in probability space.

The goal of this project is to develop a unified mathematical
understanding of reinforcement learning and generative learning as
PDE-driven optimization problems. Here one can analyze value
functions, policies, and probability densities as solutions to PDEs,
and compare how control and inference emerge from related mathematical
structures.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{New ML methods}

A recently developed machine method, dubbed Parametric Matrix Model
(PMM), has been successfully adapted to the parametrization of
differential equations, eigenvalue problems and classification
problems. See the article at \href{{https://www.nature.com/articles/s41467-025-61362-4}}{\nolinkurl{https://www.nature.com/articles/s41467-025-61362-4}} for more details.

Here one could compare this method to the PINNs project and the
application to the solution of PDEs. Alternatively, one can replace
the PDE data with classification problems.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Own data}

You can obviously used the methods we discuss during the lectures to
analyze your own data, be these from your thesis work or a research
problem you are interested in.
Here you can use the most relevant method(s)
(say convolutional neural networks for images) and apply this(these)
to data sets relevant for your own research.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Gaussian processes and Bayesian analysis}

The Gaussian processes/Bayesian statistics path: \href{{https://jenfb.github.io/bkmr/overview.html}}{Kernel regression
(Gaussian processes) and Bayesian
statistics} are popular
tools in the machine learning literature. The main idea behind these
approaches is to flexibly model the relationship between a large
number of variables and a particular outcome (dependent
variable). This can form a second part of a project where for example
standard Kernel regression methods are used on a specific data
set. Alternatively, participants can opt to work on a large project
relevant for their own research using gaussian processes and/or
Bayesian machine Learning.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{More on projects and final grade}

\begin{enumerate}
\item Two projects which count $50\%$ each for the final grade

\item Or alternatively one project which counts $100\%$ of the final grade.

\item Deadline first project March 20

\item Deadline second project June 1

\item If you opt for one project only, we need a temporary report (1-2 pages) of what has been done by March 20.
\end{enumerate}

\noindent
At the link \href{{https://github.com/CompPhysics/AdvancedMachineLearning/tree/main/doc/Projects/ProjectExamples}}{\nolinkurl{https://github.com/CompPhysics/AdvancedMachineLearning/tree/main/doc/Projects/ProjectExamples}}, you will find examples of previous projects.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Test yourself: Deep learning 1}

Deep learning (essentially neural networks)
background knowledge we deem important to be familiar with.

\begin{enumerate}
\item Can you describe the architecture of a typical feed forward  Neural Network (NN). 

\item What is an activation function and discuss the use of an activation function.

\item Can you name and explain three different types of activation functions?

\item You are using a deep neural network for a prediction task. After training your model, you notice that it is strongly overfitting the training set and that the performance on the test isn’t good. What can you do to reduce overfitting?

\item How would you know if your model is suffering from the problem of exploding gradients?

\item Can you name and explain a few hyperparameters used for training a neural network?
\end{enumerate}

\noindent
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Test yourself: Deep learning 2}

\begin{enumerate}
\item Describe the architecture of a typical Convolutional Neural Network (CNN)

\item What is the vanishing gradient problem in Neural Networks and how to fix it?

\item When it comes to training an artificial neural network, what could the reason be for why the cost/loss doesn't decrease in a few epochs?

\item How does L1/L2 regularization affect a neural network?

\item What is(are) the advantage(s) of deep learning over traditional methods like linear regression or logistic regression?
\end{enumerate}

\noindent
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Test yourself: Optimization part}

\begin{enumerate}
\item Which is the basic mathematical root-finding method behind essentially all gradient descent approaches(stochastic and non-stochastic)? 

\item And why don't we use it? Or stated differently, why do we introduce the learning rate as a parameter?

\item What might happen if you set the momentum hyperparameter too close to 1 (e.g., 0.9999) when using an optimizer for the learning rate?

\item Why should we use stochastic gradient descent instead of plain gradient descent?

\item Which parameters would you need to tune when use a stochastic gradient descent approach?
\end{enumerate}

\noindent
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Test yourself: Analysis of results}

\begin{enumerate}
\item How do you assess overfitting and underfitting?

\item Why do we divide the data in test and train and/or eventually validation sets?

\item Why would you use resampling methods in the data analysis? Mention some widely popular resampling methods.
\end{enumerate}

\noindent
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Types of machine learning}

\begin{block}{}
The approaches to machine learning are many, but are often split into two main categories. 
In \emph{supervised learning} we know the answer to a problem,
and let the computer deduce the logic behind it. On the other hand, \emph{unsupervised learning}
is a method for finding patterns and relationship in data sets without any prior knowledge of the system.

An emerging  third category is  \emph{reinforcement learning}. 

\end{block}
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Main categories}

\begin{block}{}

Another way to categorize machine learning tasks is to consider the desired output of a system.
Some of the most common tasks are:

\begin{enumerate}
\item Classification: Outputs are divided into two or more classes. The goal is to   produce a model that assigns inputs into one of these classes. An example is to identify  digits based on pictures of hand-written ones. Classification is typically supervised learning.

\item Regression: Finding a functional relationship between an input data set and a reference data set.   The goal is to construct a function that maps input data to continuous output values.

\item Clustering: Data are divided into groups with certain common traits, without knowing the different groups beforehand.  It is thus a form of unsupervised learning.
\end{enumerate}

\noindent
\end{block}
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{The plethora  of machine learning algorithms/methods}

\begin{enumerate}
\item Deep learning: Neural Networks (NNs), Convolutional NNs, Recurrent NNs, Transformers, Boltzmann machines, autoencoders and variational autoencoders  and generative adversarial networks and other generative models 

\item Bayesian statistics and Bayesian Machine Learning, Bayesian experimental design, Bayesian Regression models, Bayesian neural networks, Gaussian processes and much more

\item Dimensionality reduction (Principal component analysis), Clustering Methods and more

\item Ensemble Methods, Random forests, bagging and voting methods, gradient boosting approaches 

\item Linear and logistic regression, Kernel methods, support vector machines and more

\item Reinforcement Learning; Transfer Learning and more 
\end{enumerate}

\noindent
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{What Is Generative Modeling?}

Generative modeling can be broadly defined as follows:

Generative modeling is a branch of machine learning that involves
training a model to produce new data that is similar to a given
dataset.

What does this mean in practice? Suppose we have a dataset containing
photos of horses. We can train a generative model on this dataset to
capture the rules that govern the complex relationships between pixels
in images of horses. Then we can sample from this model to create
novel, realistic images of horses that did not exist in the original
dataset.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Example of generative modeling, \href{{https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html}}{taken from Generative Deep Learning by David Foster}}

\vspace{6mm}

% inline figure
\centerline{\includegraphics[width=1.0\linewidth]{figures/generativelearning.png}}

\vspace{6mm}
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Generative Modeling}

In order to build a generative model, we require a dataset consisting
of many examples of the entity we are trying to generate. This is
known as the training data, and one such data point is called an
observation.

Each observation consists of many features. For an image generation
problem, the features are usually the individual pixel values; for a
text generation problem, the features could be individual words or
groups of letters. It is our goal to build a model that can generate
new sets of features that look as if they have been created using the
same rules as the original data. Conceptually, for image generation
this is an incredibly difficult task, considering the vast number of
ways that individual pixel values can be assigned and the relatively
tiny number of such arrangements that constitute an image of the
entity we are trying to generate.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Generative Versus Discriminative Modeling}

In order to truly understand what generative modeling aims to achieve
and why this is important, it is useful to compare it to its
counterpart, discriminative modeling. If you have studied machine
learning, most problems you will have faced will have most likely been
discriminative in nature.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Example of discriminative modeling, \href{{https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html}}{taken from Generative Deeep Learning by David Foster}}

\vspace{6mm}

% inline figure
\centerline{\includegraphics[width=1.0\linewidth]{figures/standarddeeplearning.png}}

\vspace{6mm}
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Discriminative Modeling}

When performing discriminative modeling, each observation in the
training data has a label. For a binary classification problem such as
our data could be labeled as ones and zeros. Our model then learns how to
discriminate between these two groups and outputs the probability that
a new observation has label 1 or 0

In contrast, generative modeling doesn’t require the dataset to be
labeled because it concerns itself with generating entirely new
data (for example an image), rather than trying to predict a label for say  a given image.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Taxonomy of generative deep learning, \href{{https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html}}{taken from Generative Deep Learning by David Foster}}

\vspace{6mm}

% inline figure
\centerline{\includegraphics[width=1.0\linewidth]{figures/generativemodels.png}}

\vspace{6mm}
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Reminder on  the basic Machine Learning ingredients}

\begin{block}{}
Almost every problem in ML and data science starts with the same ingredients:
\begin{itemize}
\item The dataset $\bm{x}$ (could be some observable quantity of the system we are studying)

\item A model which is a function of a set of parameters $\bm{\alpha}$ that relates to the dataset, say a likelihood  function $p(\bm{x}\vert \bm{\alpha})$ or just a simple model $f(\bm{\alpha})$

\item A so-called \textbf{loss/cost/risk} function $\mathcal{C} (\bm{x}, f(\bm{\alpha}))$ which allows us to decide how well our model represents the dataset. 
\end{itemize}

\noindent
We seek to minimize the function $\mathcal{C} (\bm{x}, f(\bm{\alpha}))$ by finding the parameter values which minimize $\mathcal{C}$. This leads to  various minimization algorithms. It may surprise many, but at the heart of all machine learning algortihms there is an optimization problem. 
\end{block}
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Low-level machine learning, the family of ordinary least squares methods}

Our data which we want to apply a machine learning method on, consist
of a set of inputs $\bm{x}^T=[x_0,x_1,x_2,\dots,x_{n-1}]$ and the
outputs we want to model $\bm{y}^T=[y_0,y_1,y_2,\dots,y_{n-1}]$.
We assume  that the output data can be represented (for a regression case) by a continuous function $f$
through
\[
\bm{y}=f(\bm{x})+\bm{\epsilon}.
\]
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Setting up the equations}

In linear regression we approximate the unknown function with another
continuous function $\tilde{\bm{y}}(\bm{x})$ which depends linearly on
some unknown parameters
$\bm{\theta}^T=[\theta_0,\theta_1,\theta_2,\dots,\theta_{p-1}]$.

The input data can be organized in terms of a so-called design matrix 
with an approximating function $\bm{\tilde{y}}$ 
\[
\bm{\tilde{y}}= \bm{X}\bm{\theta},
\]
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{The objective/cost/loss function}

The  simplest approach is the mean squared error
\[
C(\bm{\Theta})=\frac{1}{n}\sum_{i=0}^{n-1}\left(y_i-\tilde{y}_i\right)^2=\frac{1}{n}\left\{\left(\bm{y}-\bm{\tilde{y}}\right)^T\left(\bm{y}-\bm{\tilde{y}}\right)\right\},
\]
or using the matrix $\bm{X}$ and in a more compact matrix-vector notation as
\[
C(\bm{\Theta})=\frac{1}{n}\left\{\left(\bm{y}-\bm{X}\bm{\theta}\right)^T\left(\bm{y}-\bm{X}\bm{\theta}\right)\right\}.
\]
This function represents one of many possible ways to define the so-called cost function.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Training solution}

Optimizing with respect to the unknown parameters $\theta_j$ we get 
\[
\bm{X}^T\bm{y} = \bm{X}^T\bm{X}\bm{\theta},  
\]
and if the matrix $\bm{X}^T\bm{X}$ is invertible we have the optimal values
\[
\hat{\bm{\theta}} =\left(\bm{X}^T\bm{X}\right)^{-1}\bm{X}^T\bm{y}.
\]

We say we 'learn' the unknown parameters $\bm{\theta}$ from the last equation.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Ridge and LASSO Regression}

Our optimization problem is
\[
{\displaystyle \min_{\bm{\theta}\in {\mathbb{R}}^{p}}}\frac{1}{n}\left\{\left(\bm{y}-\bm{X}\bm{\theta}\right)^T\left(\bm{y}-\bm{X}\bm{\theta}\right)\right\}.
\]
or we can state it as
\[
{\displaystyle \min_{\bm{\theta}\in
{\mathbb{R}}^{p}}}\frac{1}{n}\sum_{i=0}^{n-1}\left(y_i-\tilde{y}_i\right)^2=\frac{1}{n}\vert\vert \bm{y}-\bm{X}\bm{\theta}\vert\vert_2^2,
\]
where we have used the definition of  a norm-2 vector, that is
\[
\vert\vert \bm{x}\vert\vert_2 = \sqrt{\sum_i x_i^2}. 
\]
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{From OLS to Ridge and Lasso}

By minimizing the above equation with respect to the parameters
$\bm{\theta}$ we could then obtain an analytical expression for the
parameters $\bm{\theta}$.  We can add a regularization parameter $\lambda$ by
defining a new cost function to be optimized, that is

\[
{\displaystyle \min_{\bm{\theta}\in
{\mathbb{R}}^{p}}}\frac{1}{n}\vert\vert \bm{y}-\bm{X}\bm{\theta}\vert\vert_2^2+\lambda\vert\vert \bm{\theta}\vert\vert_2^2
\]

which leads to the Ridge regression minimization problem where we
require that $\vert\vert \bm{\theta}\vert\vert_2^2\le t$, where $t$ is
a finite number larger than zero. We do not include such a constraints in the discussions here.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Lasso regression}

Defining

\[
C(\bm{X},\bm{\theta})=\frac{1}{n}\vert\vert \bm{y}-\bm{X}\bm{\theta}\vert\vert_2^2+\lambda\vert\vert \bm{\theta}\vert\vert_1,
\]
we have a new optimization equation
\[
{\displaystyle \min_{\bm{\theta}\in
{\mathbb{R}}^{p}}}\frac{1}{n}\vert\vert \bm{y}-\bm{X}\bm{\theta}\vert\vert_2^2+\lambda\vert\vert \bm{\theta}\vert\vert_1
\]
which leads to Lasso regression. Lasso stands for least absolute shrinkage and selection operator. 
Here we have defined the norm-1 as 
\[
\vert\vert \bm{x}\vert\vert_1 = \sum_i \vert x_i\vert. 
\]
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Examples: Many-body physics, Quantum Monte Carlo and deep learning}

\begin{block}{}
Given a hamiltonian $H$ and a trial wave function $\Psi_T$, the variational principle states that the expectation value of $\langle H \rangle$, defined through 
\[
   \langle E \rangle =
   \frac{\int d\bm{R}\Psi^{\ast}_T(\bm{R})H(\bm{R})\Psi_T(\bm{R})}
        {\int d\bm{R}\Psi^{\ast}_T(\bm{R})\Psi_T(\bm{R})},
\]
is an upper bound to the ground state energy $E_0$ of the hamiltonian $H$, that is 
\[
    E_0 \le \langle E \rangle.
\]
In general, the integrals involved in the calculation of various  expectation values  are multi-dimensional ones. Traditional integration methods such as the Gauss-Legendre will not be adequate for say the  computation of the energy of a many-body system.  \textbf{Basic philosophy: Let a neural network find the optimal wave function}
\end{block}
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Quantum Monte Carlo Motivation}

\begin{block}{Basic steps }
Choose a trial wave function
$\psi_T(\bm{R})$.
\[
   P(\bm{R},\bm{\alpha})= \frac{\left|\psi_T(\bm{R},\bm{\alpha})\right|^2}{\int \left|\psi_T(\bm{R},\bm{\alpha})\right|^2d\bm{R}}.
\]
This is our model, or likelihood/probability distribution function  (PDF). It depends on some variational parameters $\bm{\alpha}$.
The approximation to the expectation value of the Hamiltonian is now 
\[
   \langle E[\bm{\alpha}] \rangle = 
   \frac{\int d\bm{R}\Psi^{\ast}_T(\bm{R},\bm{\alpha})H(\bm{R})\Psi_T(\bm{R},\bm{\alpha})}
        {\int d\bm{R}\Psi^{\ast}_T(\bm{R},\bm{\alpha})\Psi_T(\bm{R},\bm{\alpha})}.
\]
\end{block}
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Quantum Monte Carlo Motivation}

\begin{block}{Define a new quantity }
\[
   E_L(\bm{R},\bm{\alpha})=\frac{1}{\psi_T(\bm{R},\bm{\alpha})}H\psi_T(\bm{R},\bm{\alpha}),
\]
called the local energy, which, together with our trial PDF yields
\[
  \langle E[\bm{\alpha}] \rangle=\int P(\bm{R})E_L(\bm{R},\bm{\alpha}) d\bm{R}\approx \frac{1}{N}\sum_{i=1}^NE_L(\bm{R_i},\bm{\alpha})
\]
with $N$ being the number of Monte Carlo samples.
\end{block}
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Energy derivatives}

\begin{block}{}
The local energy as function of the variational parameters defines now our \textbf{objective/cost} function.

To find the derivatives of the local energy expectation value as function of the variational parameters, we can use the chain rule and the hermiticity of the Hamiltonian.  

Let us define (with the notation $\langle E[\bm{\alpha}]\rangle =\langle  E_L\rangle$)
\[
\bar{E}_{\alpha_i}=\frac{d\langle  E_L\rangle}{d\alpha_i},
\]
as the derivative of the energy with respect to the variational parameter $\alpha_i$
We define also the derivative of the trial function (skipping the subindex $T$) as 
\[
\bar{\Psi}_{i}=\frac{d\Psi}{d\alpha_i}.
\]
\end{block}
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Derivatives of the local energy}

\begin{block}{}
The elements of the gradient of the local energy are 
\[
\bar{E}_{i}= 2\left( \langle \frac{\bar{\Psi}_{i}}{\Psi}E_L\rangle -\langle \frac{\bar{\Psi}_{i}}{\Psi}\rangle\langle E_L \rangle\right).
\]
From a computational point of view it means that you need to compute the expectation values of 
\[
\langle \frac{\bar{\Psi}_{i}}{\Psi}E_L\rangle,
\]
and
\[
\langle \frac{\bar{\Psi}_{i}}{\Psi}\rangle\langle E_L\rangle
\]
These integrals are evaluted using MC intergration (with all its possible error sources). Use methods like stochastic gradient or other minimization methods to find the optimal parameters.
\end{block}
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Why Feed Forward Neural Networks (FFNN)?}

According to the \emph{Universal approximation theorem}, a feed-forward
neural network with just a single hidden layer containing a finite
number of neurons can approximate a continuous multidimensional
function to arbitrary accuracy, assuming the activation function for
the hidden layer is a \textbf{non-constant, bounded and
monotonically-increasing continuous function}.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{The electron gas in three dimensions with $N=14$ electrons (Wigner-Seitz radius $r_s=2$ a.u.), \href{{https://doi.org/10.48550/arXiv.2305.07240}}{Gabriel Pescia, Jane Kim et al.~arXiv.2305.07240,}}

\begin{block}{}

\vspace{6mm}

% inline figure
\centerline{\includegraphics[width=0.9\linewidth]{figures/elgasnew.png}}

\vspace{6mm}

\end{block}
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Extrapolations and model interpretability}

When you hear phrases like \textbf{predictions and estimations} and
\textbf{correlations and causations}, what do you think of?  May be you think
of the difference between classifying new data points and generating
new data points.
Or perhaps you consider that correlations represent some kind of symmetric statements like
if $A$ is correlated with $B$, then $B$ is correlated with
$A$. Causation on the other hand is directional, that is if $A$ causes $B$, $B$ does not
necessarily cause $A$.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Discipline  based statistical learning and data analysis}

The above concepts are in some sense the difference between \textbf{old-fashioned} machine
learning and statistics and Bayesian learning. In machine learning and prediction based
tasks, we are often interested in developing algorithms that are
capable of learning patterns from given data in an automated fashion,
and then using these learned patterns to make predictions or
assessments of newly given data. In many cases, our primary concern
is the quality of the predictions or assessments, and we are less
concerned about the underlying patterns that were learned in order
to make these predictions.

A discipline (Bioscience, Chemistry, Geoscience, Math, Physics..)  based statistical learning points however to approaches that give us both predictions and correlations as well as being able to produce error estimates and understand causations.  This leads us to the very interesting field of Bayesian statistics and Bayesian machine learning.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Bayes' Theorem}

Bayes' theorem
\[
p(X\vert Y)= \frac{p(X,Y)}{\sum_{i=0}^{n-1}p(Y\vert X=x_i)p(x_i)}=\frac{p(Y\vert X)p(X)}{\sum_{i=0}^{n-1}p(Y\vert X=x_i)p(x_i)}.
\]

The quantity $p(Y\vert X)$ on the right-hand side of the theorem is
evaluated for the observed data $Y$ and can be viewed as a function of
the parameter space represented by $X$. This function is not
necessarily normalized and is normally called the likelihood function.

The function $p(X)$ on the right hand side is called the prior while the function on the left hand side is the called the posterior probability. The denominator on the right hand side serves as a normalization factor for the posterior distribution.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Mathematics of deep learning and neural networks}

Throughout this course we will use the following notations. Vectors,
matrices and higher-order tensors are always boldfaced, with vectors
given by lower case letter letters and matrices and higher-order tensors given by upper case letters.

Unless otherwise stated, the elements $v_i$ of a vector $\bm{v}$ are assumed to be real. That is a vector of length $n$ is defined as
$\bm{x}\in \mathbb{R}^{n}$ and if we have a complex vector we have $\bm{x}\in \mathbb{C}^{n}$.

For a matrix of dimension $n\times n$ we have 
$\bm{A}\in \mathbb{R}^{n\times n}$ and the first matrix element starts with row element (row-wise ordering) zero and column element zero.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Some  mathematical notations}

\begin{enumerate}
\item For all/any  $\forall$

\item Implies $\implies$

\item Equivalent $\equiv$

\item Real variable $\mathbb{R}$

\item Integer variable $\mathbb{I}$

\item Complex  variable $\mathbb{C}$
\end{enumerate}

\noindent
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Vectors}

We start by defining a vector $\bm{x}$  with $n$ components, with $x_0$ as our first element, as

\[
\bm{x} = \begin{bmatrix} x_0\\ x_1 \\ x_2 \\ \dots \\ \dots \\ x_{n-1} \end{bmatrix}.
\]
and its transpose 
\[
\bm{x}^{T} = \begin{bmatrix} x_0 & x_1 & x_2 & \dots & \dots & x_{n-1} \end{bmatrix},
\]
In case we have a complex vector we define the hermitian conjugate
\[
\bm{x}^{\dagger} = \begin{bmatrix} x_0^* & x_1^* & x_2^* & \dots & \dots & x_{n-1}^* \end{bmatrix},
\]

With a given vector $\bm{x}$, we define the inner product as
\[
\bm{x}^T \bm{x} = \sum_{i=0}^{n-1} x_ix_i=x_0^2+x_1^2+\dots + x_{n-1}^2. 
\]
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Outer products}

In addition to inner products between vectors/states, the outer
product plays a central role in many applications. It is
defined as
\[
\bm{x}\bm{y}^T = \begin{bmatrix}
               x_0y_0 & x_0y_1 & x_0y_2 & \dots & \dots & x_0y_{n-2} & x_0y_{n-1} \\
	       x_1y_0 & x_1y_1 & x_1y_2 & \dots & \dots & x_1y_{n-2} & x_1y_{n-1} \\
	       x_2y_0 & x_2y_1 & x_2y_2 & \dots & \dots & x_2y_{n-2} & x_2y_{n-1} \\	       
               \dots &   \dots   & \dots  & \dots & \dots & \dots & \dots \\
               \dots &   \dots   & \dots  & \dots & \dots & \dots & \dots \\	       
	       x_{n-2}y_0 & x_{n-2}y_1 & x_{n-2}y_2 & \dots & \dots & x_{n-2}y_{n-2} & x_{n-2}y_{n-1} \\
	       x_{n-1}y_0 & x_{n-1}y_1 & x_{n-1}y_2 & \dots & \dots & x_{n-1}y_{n-2} & x_{n-1}y_{n-1} \end{bmatrix}	       
\]
The latter defines also our basic matrix layout.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Basic Matrix Features}

A general $n\times n$ matrix is given by 
\[
 \bm{A} =
\begin{bmatrix}
               a_{00} & a_{01} & a_{02} & \dots & \dots & a_{0n-2} & a_{0n-1} \\
               a_{10} & a_{11} & a_{12} & \dots & \dots & a_{1n-2} & a_{1n-1} \\
               \dots &   \dots   & \dots  & \dots & \dots & \dots & \dots \\
               \dots &   \dots   & \dots  & \dots & \dots & \dots & \dots \\	       
               a_{n-20} & a_{n-21} & a_{n-22} & \dots & \dots & a_{n-2n-2} & a_{n-2n-1} \\
               a_{n-10} & a_{n-11} & a_{n-12} & \dots & \dots & a_{n-1n-2} & a_{n-1n-1} \end{bmatrix},	       
\]
or in terms of its column vectors $\bm{a}_i$ as
\[
 \bm{A} =
\begin{bmatrix}\bm{a}_{0} & \bm{a}_{1} & \bm{a}_{2} & \dots & \dots & \bm{a}_{n-2} & \bm{a}_{n-1}\end{bmatrix}.	       
\]
We can think of a matrix as a diagram of in general $n$ rowns and $m$ columns. In the example here we have a square matrix.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Setting up the basic equations for neural networks}

Neural networks, in its so-called feed-forward form, where each
iterations contains a feed-forward stage and a back-propgagation
stage, consist of series of affine matrix-matrix and matrix-vector
multiplications. The unknown parameters (the so-called biases and
weights which deternine the architecture of a neural network), are
uptaded iteratively using the so-called back-propagation algorithm.
This algorithm corresponds to the so-called reverse mode of the
automatic differentation algorithm. These algorithms will be discussed
in more detail below.

We start however first with the  definitions of the various variables which make up a neural network.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Overarching view of a neural network}

The architecture of a neural network defines our model. This model
aims at describing some function $f(\bm{x}$ which aims at describing
some final result (outputs or tagrget values) given a specific inpput
$\bm{x}$. Note that here $\bm{y}$ and $\bm{x}$ are not limited to be
vectors.

The architecture consists of
\begin{enumerate}
\item An input and an output layer where the input layer is defined by the inputs $\bm{x}$. The output layer produces the model ouput $\bm{\tilde{y}}$ which is compared with the target value $\bm{y}$

\item A given number of hidden layers and neurons/nodes/units for each layer (this may vary)

\item A given activation function $\sigma(\bm{z})$ with arguments $\bm{z}$ to be defined below. The activation functions may differ from layer to layer.

\item The last layer, normally called \textbf{output} layer has normally an activation function tailored to the specific problem

\item Finally we define a so-called cost or loss function which is used to gauge the quality of our model. 
\end{enumerate}

\noindent
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{The optimzation problem}

The cost function is a function of the unknown parameters
$\bm{\Theta}$ where the latter is a container for all possible
parameters needed to define a neural network

If we are dealing with a regression task a typical cost/loss function
is the mean squared error
\[
C(\bm{\Theta})=\frac{1}{n}\left\{\left(\bm{y}-\bm{X}\bm{\theta}\right)^T\left(\bm{y}-\bm{X}\bm{\theta}\right)\right\}.
\]
This function represents one of many possible ways to define
the so-called cost function.

For neural networks the parameters
$\bm{\Theta}$ are given by the so-called weights and biases (to be
defined below).

The weights are given by matrix elements $w_{ij}^{(l)}$ where the
superscript indicates the layer number. The biases are typically given
by vector elements representing each single node of a given layer,
that is $b_j^{(l)}$.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Other ingredients of a neural network}

Having defined the architecture of a neural network, the optimization
of the cost function with respect to the parameters $\bm{\Theta}$,
involves the calculations of gradients and their optimization. The
gradients represent the derivatives of a multidimensional object and
are often approximated by various gradient methods, including
\begin{enumerate}
\item various quasi-Newton methods,

\item plain gradient descent (GD) with a constant learning rate $\eta$,

\item GD with momentum and other approximations to the learning rates such as
\begin{itemize}

  \item Adapative gradient (ADAgrad)

  \item Root mean-square propagation (RMSprop)

  \item Adaptive gradient with momentum (ADAM) and many other

\end{itemize}

\noindent
\item Stochastic gradient descent and various families of learning rate approximations
\end{enumerate}

\noindent
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Other parameters}

In addition to the above, there are often additional hyperparamaters
which are included in the setup of a neural network. These will be
discussed below.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Setting up the equations for a neural network}

The questions we want to ask are how do changes in the biases and the
weights in our network change the cost function and how can we use the
final output to modify the weights?

To derive these equations let us start with a plain regression problem
and define our cost function as

\[
{\cal C}(\bm{\Theta})  =  \frac{1}{2}\sum_{i=1}^n\left(y_i - \tilde{y}_i\right)^2, 
\]

where the $y_i$s are our $n$ targets (the values we want to
reproduce), while the outputs of the network after having propagated
all inputs $\bm{x}$ are given by $\bm{\tilde{y}}_i$.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Definitions}

With our definition of the targets $\bm{y}$, the outputs of the
network $\bm{\tilde{y}}$ and the inputs $\bm{x}$ we
define now the activation $z_j^l$ of node/neuron/unit $j$ of the
$l$-th layer as a function of the bias, the weights which add up from
the previous layer $l-1$ and the forward passes/outputs
$\hat{a}^{l-1}$ from the previous layer as

\[
z_j^l = \sum_{i=1}^{M_{l-1}}w_{ij}^la_i^{l-1}+b_j^l,
\]

where $b_k^l$ are the biases from layer $l$.  Here $M_{l-1}$
represents the total number of nodes/neurons/units of layer $l-1$. The
figure here illustrates this equation.  We can rewrite this in a more
compact form as the matrix-vector products we discussed earlier,

\[
\hat{z}^l = \left(\hat{W}^l\right)^T\hat{a}^{l-1}+\hat{b}^l.
\]
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Inputs to tje activation function}

With the activation values $\bm{z}^l$ we can in turn define the
output of layer $l$ as $\bm{a}^l = f(\bm{z}^l)$ where $f$ is our
activation function. In the examples here we will use the sigmoid
function discussed in our logistic regression lectures. We will also use the same activation function $f$ for all layers
and their nodes.  It means we have

\[
a_j^l = f(z_j^l) = \frac{1}{1+\exp{-(z_j^l)}}.
\]
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Derivatives and the chain rule}

From the definition of the activation $z_j^l$ we have
\[
\frac{\partial z_j^l}{\partial w_{ij}^l} = a_i^{l-1},
\]
and
\[
\frac{\partial z_j^l}{\partial a_i^{l-1}} = w_{ji}^l. 
\]

With our definition of the activation function we have that (note that this function depends only on $z_j^l$)
\[
\frac{\partial a_j^l}{\partial z_j^{l}} = a_j^l(1-a_j^l)=f(z_j^l)(1-f(z_j^l)). 
\]
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Derivative of the cost function}

With these definitions we can now compute the derivative of the cost function in terms of the weights.

Let us specialize to the output layer $l=L$. Our cost function is
\[
{\cal C}(\bm{\Theta}^L)  =  \frac{1}{2}\sum_{i=1}^n\left(y_i - \tilde{y}_i\right)^2=\frac{1}{2}\sum_{i=1}^n\left(a_i^L - y_i\right)^2, 
\]
The derivative of this function with respect to the weights is

\[
\frac{\partial{\cal C}(\bm{\Theta}^L)}{\partial w_{jk}^L}  =  \left(a_j^L - y_j\right)\frac{\partial a_j^L}{\partial w_{jk}^{L}}, 
\]
The last partial derivative can easily be computed and reads (by applying the chain rule)
\[
\frac{\partial a_j^L}{\partial w_{jk}^{L}} = \frac{\partial a_j^L}{\partial z_{j}^{L}}\frac{\partial z_j^L}{\partial w_{jk}^{L}}=a_j^L(1-a_j^L)a_k^{L-1}.  
\]
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Bringing it together, first back propagation equation}

We have thus
\[
\frac{\partial{\cal C}((\bm{\Theta}^L)}{\partial w_{jk}^L}  =  \left(a_j^L - y_j\right)a_j^L(1-a_j^L)a_k^{L-1}, 
\]

Defining
\[
\delta_j^L = a_j^L(1-a_j^L)\left(a_j^L - y_j\right) = f'(z_j^L)\frac{\partial {\cal C}}{\partial (a_j^L)},
\]
and using the Hadamard product of two vectors we can write this as
\[
\bm{\delta}^L = f'(\hat{z}^L)\circ\frac{\partial {\cal C}}{\partial (\bm{a}^L)}.
\]
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Analyzing the last results}

This is an important expression. The second term on the right handside
measures how fast the cost function is changing as a function of the $j$th
output activation.  If, for example, the cost function doesn't depend
much on a particular output node $j$, then $\delta_j^L$ will be small,
which is what we would expect. The first term on the right, measures
how fast the activation function $f$ is changing at a given activation
value $z_j^L$.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{More considerations}

Notice that everything in the above equations is easily computed.  In
particular, we compute $z_j^L$ while computing the behaviour of the
network, and it is only a small additional overhead to compute
$f'(z^L_j)$.  The exact form of the derivative with respect to the
output depends on the form of the cost function.
However, provided the cost function is known there should be little
trouble in calculating

\[
\frac{\partial {\cal C}}{\partial (a_j^L)}
\]

With the definition of $\delta_j^L$ we have a more compact definition of the derivative of the cost function in terms of the weights, namely
\[
\frac{\partial{\cal C}}{\partial w_{jk}^L}  =  \delta_j^La_k^{L-1}.
\]
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Derivatives in terms of $z_j^L$}

It is also easy to see that our previous equation can be written as

\[
\delta_j^L =\frac{\partial {\cal C}}{\partial z_j^L}= \frac{\partial {\cal C}}{\partial a_j^L}\frac{\partial a_j^L}{\partial z_j^L},
\]
which can also be interpreted as the partial derivative of the cost function with respect to the biases $b_j^L$, namely
\[
\delta_j^L = \frac{\partial {\cal C}}{\partial b_j^L}\frac{\partial b_j^L}{\partial z_j^L}=\frac{\partial {\cal C}}{\partial b_j^L},
\]
That is, the error $\delta_j^L$ is exactly equal to the rate of change of the cost function as a function of the bias.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Bringing it together}

We have now three equations that are essential for the computations of the derivatives of the cost function at the output layer. These equations are needed to start the algorithm and they are

\begin{equation}
\frac{\partial{\cal C}(\hat{W^L})}{\partial w_{jk}^L}  =  \delta_j^La_k^{L-1},
\end{equation}
and
\begin{equation}
\delta_j^L = f'(z_j^L)\frac{\partial {\cal C}}{\partial (a_j^L)},
\end{equation}
and

\begin{equation}
\delta_j^L = \frac{\partial {\cal C}}{\partial b_j^L},
\end{equation}
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Final back propagating equation}

We have that (replacing $L$ with a general layer $l$)
\[
\delta_j^l =\frac{\partial {\cal C}}{\partial z_j^l}.
\]
We want to express this in terms of the equations for layer $l+1$.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Using the chain rule and summing over all $k$ entries}

We obtain
\[
\delta_j^l =\sum_k \frac{\partial {\cal C}}{\partial z_k^{l+1}}\frac{\partial z_k^{l+1}}{\partial z_j^{l}}=\sum_k \delta_k^{l+1}\frac{\partial z_k^{l+1}}{\partial z_j^{l}},
\]
and recalling that
\[
z_j^{l+1} = \sum_{i=1}^{M_{l}}w_{ij}^{l+1}a_i^{l}+b_j^{l+1},
\]
with $M_l$ being the number of nodes in layer $l$, we obtain
\[
\delta_j^l =\sum_k \delta_k^{l+1}w_{kj}^{l+1}f'(z_j^l),
\]
This is our final equation.

We are now ready to set up the algorithm for back propagation and learning the weights and biases.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Setting up the back propagation algorithm}

The four equations  provide us with a way of computing the gradient of the cost function. Let us write this out in the form of an algorithm.

\textbf{First}, we set up the input data $\hat{x}$ and the activations
$\hat{z}_1$ of the input layer and compute the activation function and
the pertinent outputs $\hat{a}^1$.

\textbf{Secondly}, we perform then the feed forward till we reach the output
layer and compute all $\hat{z}_l$ of the input layer and compute the
activation function and the pertinent outputs $\hat{a}^l$ for
$l=2,3,\dots,L$.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Setting up the back propagation algorithm, part 2}

Thereafter we compute the ouput error $\hat{\delta}^L$ by computing all
\[
\delta_j^L = f'(z_j^L)\frac{\partial {\cal C}}{\partial (a_j^L)}.
\]

Then we compute the back propagate error for each $l=L-1,L-2,\dots,2$ as
\[
\delta_j^l = \sum_k \delta_k^{l+1}w_{kj}^{l+1}f'(z_j^l).
\]
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Setting up the Back propagation algorithm, part 3}

Finally, we update the weights and the biases using gradient descent
for each $l=L-1,L-2,\dots,1$ and update the weights and biases
according to the rules

\[
w_{jk}^l\leftarrow  = w_{jk}^l- \eta \delta_j^la_k^{l-1},
\]

\[
b_j^l \leftarrow b_j^l-\eta \frac{\partial {\cal C}}{\partial b_j^l}=b_j^l-\eta \delta_j^l,
\]
with $\eta$ being the learning rate.
\end{frame}

\begin{frame}[plain,fragile]
\frametitle{Updating the gradients}

With the back propagate error for each $l=L-1,L-2,\dots,1$ as
\[
\delta_j^l = \sum_k \delta_k^{l+1}w_{kj}^{l+1}f'(z_j^l),
\]
we update the weights and the biases using gradient descent for each $l=L-1,L-2,\dots,1$ and update the weights and biases according to the rules
\[
w_{jk}^l\leftarrow  = w_{jk}^l- \eta \delta_j^la_k^{l-1},
\]

\[
b_j^l \leftarrow b_j^l-\eta \frac{\partial {\cal C}}{\partial b_j^l}=b_j^l-\eta \delta_j^l,
\]
\end{frame}

\end{document}
