%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{Time-dependent Hartree-Fock}
\date{March 2023}
\release{}
\author{FYS5429}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}

\index{do (module)@\spxentry{do}\spxextra{module}}\index{GHF (class in do)@\spxentry{GHF}\spxextra{class in do}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{do.}}\sphinxbfcode{\sphinxupquote{GHF}}}{\emph{l=10}, \emph{grid\_length=10}, \emph{num\_grid\_points=201}, \emph{alpha=1.0}, \emph{a=0.25}, \emph{Omega=0.25}, \emph{omega=2}, \emph{epsilon0=1}, \emph{nparticles=2}, \emph{antisymmetrize=True}}{}
Initializes a system in the general spin representation. The default values in the creator are referred to the main analyzed case.

\sphinxstylestrong{Args}:
\begin{quote}

l (int) : number of harmonic oscillator eigenstates used for the expansion of the radial part of the single-particle wavefunctions

grid\_length (int) : extension of the mesh goes from -grid\_length to grid\_length

num\_grid\_points (int) : number of points in the mesh

alpha (float) : strength parameter in the shielded Coulomb potential

a (float) : shielding parameter in the shielded Coulomb potential

Omega (float) : frequency of the harmonic oscillator potential in which the electrons are trapped

omega (float) : frequency of the laser source

epsilon0 (float) : amplitude of the sinusoidal potential associated to the laser

nparticles (int) : number of electrons in the system

antisymmetrize (bool) : if True, antisymmetrizes the system.u matrix
\end{quote}

\sphinxstylestrong{Attributes}:
\begin{quote}

potential (func) : ODQD.HOPotential(Omega)

system : GeneralOrbitalSystem object (see \sphinxurl{https://schoyen.github.io/quantum-systems/})

Omega (float) : frequency of the harmonic oscillator potential in which the electrons are trapped

omega (float) : frequency of the laser source

epsilon0 (float) : amplitude of the sinusoidal potential associated to the laser

nparticles (int) : number of electrons in the system
\end{quote}
\index{anima() (do.GHF method)@\spxentry{anima()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.anima}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{anima}}}{\emph{i}, \emph{text}, \emph{line1}, \emph{line2}, \emph{integrator}, \emph{dt}, \emph{t\_max}, \emph{save\_every\_n}}{}
Iterative function needed for self.gif\_generator

\end{fulllineitems}

\index{eval\_dipole() (do.GHF method)@\spxentry{eval\_dipole()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.eval_dipole}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{eval\_dipole}}}{\emph{C}}{}
Returns the expected value of the position operator for the system, given by

\(\overline{x}(t) = \sum_i^{occ} \sum_{\alpha\beta} C_{\alpha,i}^*(t) C_{\beta,i} (t) \langle \chi_{\alpha}(x) \vert \hat{x} \vert \chi_{\beta}(x)\rangle\)
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
C (np.ndarray) : coefficient matrix

\item[{\sphinxstylestrong{Returns}:            }] \leavevmode
dipole (complex) : expected value for position operator

\end{description}

\end{fulllineitems}

\index{eval\_one\_body\_density() (do.GHF method)@\spxentry{eval\_one\_body\_density()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.eval_one_body_density}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{eval\_one\_body\_density}}}{\emph{C}}{}
Returns the one-body density of the system, according to

\(\rho(x) = \sum_i^{occ} \sum_{\alpha\beta} C_{\alpha,i}^* C_{\beta,i} \chi_{\alpha}^*(x) \chi_{\beta}(x)\)
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
C (np.ndarray) : coefficient matrix

\item[{\sphinxstylestrong{Returns}:}] \leavevmode
one\_body\_density (np.array)

\end{description}

\end{fulllineitems}

\index{eval\_total\_energy() (do.GHF method)@\spxentry{eval\_total\_energy()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.eval_total_energy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{eval\_total\_energy}}}{\emph{C}}{}
Returns the total energy of the system, given by

\(E[H] = \sum_{i=1}^2 \sum_{\alpha,\beta} C_{\alpha,i}^* C_{\beta,i} h_{\alpha\beta}^{ho} + \frac{1}{2} \sum_{i,j=1}^2 \sum_{\alpha\beta\gamma\delta} C_{\alpha,i}^* C_{\gamma,j}^* C_{\beta,i} C_{\delta,j}  u^{\alpha\gamma}_{\beta\delta,AS}\)
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
C (np.ndarray) : coefficient matrix

\item[{\sphinxstylestrong{Returns}:}] \leavevmode
energy (complex)

\end{description}

\end{fulllineitems}

\index{fill\_density\_matrix() (do.GHF method)@\spxentry{fill\_density\_matrix()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.fill_density_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fill\_density\_matrix}}}{\emph{C}}{}
Returns the density matrix evaluated using the coefficient matrix C, according to

\(M_{\alpha\beta} = \sum_i^{occ} C_{\alpha,i}^* C_{\beta,i}\)
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
C (np.ndarray) : coefficient matrix

\item[{\sphinxstylestrong{Returns}:}] \leavevmode
density\_matrix (np.ndarray)

\end{description}

\end{fulllineitems}

\index{fill\_fock\_matrix() (do.GHF method)@\spxentry{fill\_fock\_matrix()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.fill_fock_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fill\_fock\_matrix}}}{\emph{C}, \emph{t}}{}
Returns the Fock matrix evaluated using the coefficient matrix C evaluated at time t, according to

\(f_{\mu\nu}(t) =  h_{\mu\nu}^{ho} + x_{\mu\nu} \varepsilon_0 \sin(\omega t) + \sum_{j}^{occ} \sum_{\gamma\delta} C_{\gamma,j}^* C_{\delta,j} u^{\mu\gamma}_{\nu\delta,AS}\)
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
C (np.ndarray) : coefficient matrix

t (float) : time instant

\item[{\sphinxstylestrong{Returns}:}] \leavevmode
fock\_matrix (np.ndarray)

\end{description}

\end{fulllineitems}

\index{fourier\_analysis() (do.GHF method)@\spxentry{fourier\_analysis()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.fourier_analysis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fourier\_analysis}}}{\emph{tolerance}, \emph{max\_iter}, \emph{t\_laser\_ON}, \emph{t\_max}, \emph{dt}, \emph{eval\_energy=False}}{}
Solves the time-independent Ruthaan-Hall equations and then performs a time-evolution of the system switching off the laser source at a certain time.
Performs the Fourier analysis on the curves for overlap and dipole moment obtained for t\textgreater{}t\_laser\_ON.
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
tolerance (float) : stopping condition for the time-independent solver.

max\_iter (int) : maximum number of iterations before the time-independent solver stops.

t\_laser\_ON (float) : instant at which the laser is switched off

t\_max (float) : final instant for time evolution

dt (float) : time step

eval\_energy (bool) : if True, evaluates energy at every time step (for faster computations, set to False)

\item[{\sphinxstylestrong{Returns}:}] \leavevmode
C2 (np.ndarray) : coefficient matrix for t=t\_max

time (np.array) : time instants from tstart to t\_max spaced by dt

dipole (np.array) : dipole evaluated at each time instant

overlap (np.array) : overlap evaluated at each time instant

dipoleFFT (np.array) : fft of dipole values for t\textgreater{}t\_laser\_ON

dipolefreqFFT (np.array) : array of frequencies corresponding to dipoleFFT

overlapFFT (np.array) : fft of overlap values for t\textgreater{}t\_laser\_ON

overlapfreqFFT (np.array) : array of frequencies corresponding to overlapFFT

energy (np.array) : total energy at each time instant

\end{description}

\end{fulllineitems}

\index{gif\_generator() (do.GHF method)@\spxentry{gif\_generator()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.gif_generator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gif\_generator}}}{\emph{dt}, \emph{t\_max}, \emph{C0}, \emph{save\_every\_n=500}}{}
Generates an animated image (.gif) with the time evolution of the one-body density and the time evolution of the one body potential.
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
dt (float) : time step

t\_max (float) : total duration of the time evolution

C0 (np.ndarray) : coefficient matrix at time t=0

save\_every\_n (int) : number of time steps between two successive frames in the final .gif file

\end{description}

\end{fulllineitems}

\index{laser\_potential() (do.GHF method)@\spxentry{laser\_potential()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.laser_potential}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{laser\_potential}}}{\emph{t}}{}
Returns the value of the laser potential at time t.
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
t (float) : time instant

\item[{\sphinxstylestrong{Returns}:}] \leavevmode
epsilon0 * sin( omega * t ) (float)

\end{description}

\end{fulllineitems}

\index{plot\_AO() (do.GHF method)@\spxentry{plot\_AO()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.plot_AO}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_AO}}}{}{}
Plots the square modulus of the Atomic Orbitals (harmonic oscillator eigenstates).
The zero-level for each single particle state is its corresponding eigenvalue.

\end{fulllineitems}

\index{plot\_MO() (do.GHF method)@\spxentry{plot\_MO()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.plot_MO}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_MO}}}{\emph{epsilon}, \emph{C}}{}
Plots the square modulus of the Molecular Orbitals (after the basis change).
The zero-level for each single particle state is its corresponding eigenvalue.

\end{fulllineitems}

\index{plot\_fourier\_analysis() (do.GHF method)@\spxentry{plot\_fourier\_analysis()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.plot_fourier_analysis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_fourier\_analysis}}}{\emph{time}, \emph{dipole}, \emph{overlap}, \emph{xFFT}, \emph{xfreqFFT}, \emph{overlapFFT}, \emph{overlapfreqFFT}, \emph{energy=None}}{}
Plots the results of the Fourier analysis.
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
time (np.array) : array of time instants

dipole (np.array) : dipole for each time instant

overlap (np.array) : overlap for each time instant

xFFT (np.array) : fast Fourier transform of the dipole signal

xfreqFFT (np.array) : frequency spectrum of the dipole signal (useful for plotting)

overlapFFT (np.array) : fast Fourier transform of the overlap signal

overlapfreqFFT (np.array) : frequency spectrum of the overlap signal (useful for plotting)

energy (np.array) : energy for each time instant, may not be included

\end{description}

\end{fulllineitems}

\index{plot\_one\_body\_density() (do.GHF method)@\spxentry{plot\_one\_body\_density()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.plot_one_body_density}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_one\_body\_density}}}{\emph{one\_body\_density}}{}
Plots the comparison between the one-body density and the result by Zanghellini et al..
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
one\_body\_density (np.array) : result of self.eval\_one\_body\_density()

\end{description}

\end{fulllineitems}

\index{plot\_overlap() (do.GHF method)@\spxentry{plot\_overlap()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.plot_overlap}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_overlap}}}{\emph{time}, \emph{overlap}}{}
Plots the comparison between the overlaps evaluated in the time-dependent solver and by Zanghellini et al..
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
time (np.array) : array of time instants

overlap (np.array) : overlap for each time instant

\end{description}

\end{fulllineitems}

\index{rhsf() (do.GHF method)@\spxentry{rhsf()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.rhsf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{rhsf}}}{\emph{t}, \emph{C}}{}
Returns the right-hand side of the Ruthaan-Hall equations with the laser source on, corresponding to

\(\dot{C}(t) = -i f(t)C(t)\)

The output is reshaped into an array in order to be used into self.solve\_TDHF()
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
t (float) : time

C (np.array) : reshaped coefficient matrix into array

\item[{\sphinxstylestrong{Returns}:}] \leavevmode
rhs (np.array)

\end{description}

\end{fulllineitems}

\index{rhsf\_OFF() (do.GHF method)@\spxentry{rhsf\_OFF()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.rhsf_OFF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{rhsf\_OFF}}}{\emph{t}, \emph{C}}{}
Returns the right-hand side of the Ruthaan-Hall equations with the laser source off, given by

\(\dot{C}(t) = -i f(t)C(t)\)

The output is reshaped into an array in order to be used into self.solve\_TDHF()
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
t (float) : time

C (np.array) : coefficient matrix reshaped into array

\item[{\sphinxstylestrong{Returns}:}] \leavevmode
rhs (np.array)

\end{description}

\end{fulllineitems}

\index{solve\_TDHF() (do.GHF method)@\spxentry{solve\_TDHF()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.solve_TDHF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve\_TDHF}}}{\emph{tstart}, \emph{dt}, \emph{t\_max}, \emph{C0}, \emph{eval\_overlap=False}, \emph{eval\_dipole=False}, \emph{eval\_energy=False}, \emph{laser\_ON=True}}{}
Solves iteratively the time-dependent Ruthaan-Hall equations for the system.
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
t\_start (float) : time at which the evolution begins

dt (float) : time step

t\_max (float) : time at which the evolution ends

C0 (np.ndarray) : coefficient matrix at time t\_start

eval\_overlap (bool) : if True, the overlap with the wavefunction at t=t\_start is evaluated at every instant

eval\_dipole (bool) : if True, the expected value for the dipole operator is evaluated at every instant

eval\_energy (bool) : if True, the total energy is evaluated at every instant

laser\_ON (bool) : if True, the laser source is on

\item[{\sphinxstylestrong{Return}: }] \leavevmode
C (np.ndarray) : coefficient matrix at t=t\_max

time (np.array) : time instants from tstart to t\_max spaced by dt

overlap (np.array) : None if eval\_overlap==False

dipole (np.array) : None if eval\_dipole==False

energy (np.array) : None if eval\_energy==False

\end{description}

\end{fulllineitems}

\index{solve\_TIHF() (do.GHF method)@\spxentry{solve\_TIHF()}\spxextra{do.GHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.GHF.solve_TIHF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve\_TIHF}}}{\emph{tolerance}, \emph{max\_iter}, \emph{print\_ON=False}, \emph{eval\_energy\_per\_step=False}, \emph{eval\_delta\_per\_step=False}}{}
Solves the Ruthaan-Hall equations for the system.
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
tolerance (float) : stopping condition for the algorithm.

max\_iter (int) : maximum number of iterations before the algorithm stops

print\_ON (bool) : if True prints if the convergence or the max number of iterations has been reached.

eval\_energy\_per\_step (bool) : if True, the energy of the system is evaluated at every step

eval\_delta\_per\_step (bool) : if True, the \(\Delta\) parameter of the system is evaluated at every step

\item[{\sphinxstylestrong{Returns}:}] \leavevmode
epsilon (np.array) : final eigenvalues

C (np.ndarray) : final coefficient matrix

energy\_per\_step (np.array) : None if energy\_per\_step==False

delta\_per\_step (np.array) : None if delta\_per\_step==False

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{RHF (class in do)@\spxentry{RHF}\spxextra{class in do}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.RHF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{do.}}\sphinxbfcode{\sphinxupquote{RHF}}}{\emph{l=10}, \emph{grid\_length=10}, \emph{num\_grid\_points=201}, \emph{alpha=1.0}, \emph{a=0.25}, \emph{Omega=0.25}, \emph{omega=2}, \emph{epsilon0=1}, \emph{nparticles=2}, \emph{potential=None}, \emph{antisymmetrize=False}}{}
Initializes a system in the restricted spin representation. The default values in the creator are referred to the analyzed case.
A more detailed description is provided in the paper folder at \sphinxurl{https://github.com/Matteo294/FYS4411} .
The quantum-system documentation appears in \sphinxurl{https://schoyen.github.io/quantum-systems/}
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
l (int) : number of harmonic oscillator eigenstates used for the expansion of the radial part of the single-particle wavefunctions

grid\_length (int) : extension of the mesh goes from -grid\_length to grid\_length

num\_grid\_points (int) : number of points in the mesh

alpha (float) : strength parameter in the shielded Coulomb potential

a (float) : shielding parameter in the shielded Coulomb potential

Omega (float) : frequency of the harmonic oscillator potential in which the electrons are trapped

omega (float) : frequency of the laser source

epsilon0 (float) : amplitude of the sinusoidal potential associated to the laser

nparticles (int) : number of electrons in the system

antisimmetrize (bool) : MUST remain False

\item[{\sphinxstylestrong{Attributes}:}] \leavevmode
potential (func) : ODQD.HOPotential(Omega)

system : ODQD object (see \sphinxurl{https://schoyen.github.io/quantum-systems/})

Omega (float) : frequency of the harmonic oscillator potential in which the electrons are trapped

omega (float) : frequency of the laser source

epsilon0 (float) : amplitude of the sinusoidal potential associated to the laser

nparticles (int) : number of electrons in the system

\end{description}
\index{eval\_one\_body\_density() (do.RHF method)@\spxentry{eval\_one\_body\_density()}\spxextra{do.RHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.RHF.eval_one_body_density}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{eval\_one\_body\_density}}}{\emph{C}}{}
Returns the one-body density of the system, according to

\(\rho(x) = 2 \sum_i^{n/2} \sum_{\alpha\beta} C_{\alpha,i}^* C_{\beta,i} \chi_{\alpha}^*(x) \chi_{\beta}(x)\)
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
C (np.ndarray) : coefficient matrix

\item[{\sphinxstylestrong{Returns}:}] \leavevmode
one\_body\_density (np.array)

\end{description}

\end{fulllineitems}

\index{eval\_total\_energy() (do.RHF method)@\spxentry{eval\_total\_energy()}\spxextra{do.RHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.RHF.eval_total_energy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{eval\_total\_energy}}}{\emph{C}}{}
Returns the total energy of the system, given by

\(E[H] = 2\sum_{i=1}^{n/2} \sum_{\alpha,\beta} C_{\alpha,i}^* C_{\beta,i} h_{\alpha\beta}^{ho} + 2 \sum_{i,j=1}^{n/2} \sum_{\alpha\beta\gamma\delta} C_{\alpha,i}^* C_{\gamma,j}^* C_{\beta,i} C_{\delta,j}  u^{\alpha\gamma}_{\beta\delta} - \sum_{i,j=1}^{n/2} \sum_{\alpha\beta\gamma\delta} C_{\alpha,i}^* C_{\gamma,j}^* C_{\beta,i} C_{\delta,j}  u^{\alpha\gamma}_{\delta\beta}\)
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
C (np.ndarray) : coefficient matrix

\item[{\sphinxstylestrong{Returns}:}] \leavevmode
energy (complex)

\end{description}

\end{fulllineitems}

\index{fill\_density\_matrix() (do.RHF method)@\spxentry{fill\_density\_matrix()}\spxextra{do.RHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.RHF.fill_density_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fill\_density\_matrix}}}{\emph{C}}{}
Returns the density matrix evaluated using the coefficient matrix C, according to

\(M_{\alpha\beta} = \sum_i^{nparticles/2} C_{\alpha,i}^* C_{\beta,i}\)
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
C (np.ndarray) : coefficient matrix

\item[{\sphinxstylestrong{Returns}:}] \leavevmode
density\_matrix (np.ndarray)

\end{description}

\end{fulllineitems}

\index{fill\_fock\_matrix() (do.RHF method)@\spxentry{fill\_fock\_matrix()}\spxextra{do.RHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:do.RHF.fill_fock_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fill\_fock\_matrix}}}{\emph{C}, \emph{t}}{}
Returns the Fock matrix evaluated using the coefficient matrix C evaluated at time t, according to

\(f_{\mu\nu} =  h_{\mu\nu}^{ho} + 2\sum_{j}^{n/2} \sum_{\gamma\delta} C_{\gamma,j}^* C_{\delta,j} u^{\mu\gamma}_{\nu\delta} - \sum_{j}^{n/2} \sum_{\gamma\delta} C_{\gamma,j}^* C_{\delta,j} u^{\mu\gamma}_{\delta\nu}\)
\begin{description}
\item[{\sphinxstylestrong{Args}:}] \leavevmode
C (np.ndarray) : coefficient matrix

t (float) : time instant

\item[{\sphinxstylestrong{Returns}:}] \leavevmode
fock\_matrix (np.ndarray)

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{d}
\item\relax\sphinxstyleindexentry{do}\sphinxstyleindexpageref{index:\detokenize{module-do}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}